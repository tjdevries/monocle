[@@@ocaml.warning "-27-30-39-44"]

type expr = unit

type param_kind =
  | Param_kind_undefined 
  | Param_extern 
  | Param_exec 
  | Param_sublink 
  | Param_multiexpr 

type agg_split =
  | Agg_split_undefined 
  | Aggsplit_simple 
  | Aggsplit_initial_serial 
  | Aggsplit_final_deserial 

type coercion_form =
  | Coercion_form_undefined 
  | Coerce_explicit_call 
  | Coerce_explicit_cast 
  | Coerce_implicit_cast 

type bool_expr_type =
  | Bool_expr_type_undefined 
  | And_expr 
  | Or_expr 
  | Not_expr 

type sub_link_type =
  | Sub_link_type_undefined 
  | Exists_sublink 
  | All_sublink 
  | Any_sublink 
  | Rowcompare_sublink 
  | Expr_sublink 
  | Multiexpr_sublink 
  | Array_sublink 
  | Cte_sublink 

type row_compare_type =
  | Row_compare_type_undefined 
  | Rowcompare_lt 
  | Rowcompare_le 
  | Rowcompare_eq 
  | Rowcompare_ge 
  | Rowcompare_gt 
  | Rowcompare_ne 

type min_max_op =
  | Min_max_op_undefined 
  | Is_greatest 
  | Is_least 

type sqlvalue_function_op =
  | Sqlvalue_function_op_undefined 
  | Svfop_current_date 
  | Svfop_current_time 
  | Svfop_current_time_n 
  | Svfop_current_timestamp 
  | Svfop_current_timestamp_n 
  | Svfop_localtime 
  | Svfop_localtime_n 
  | Svfop_localtimestamp 
  | Svfop_localtimestamp_n 
  | Svfop_current_role 
  | Svfop_current_user 
  | Svfop_user 
  | Svfop_session_user 
  | Svfop_current_catalog 
  | Svfop_current_schema 

type xml_expr_op =
  | Xml_expr_op_undefined 
  | Is_xmlconcat 
  | Is_xmlelement 
  | Is_xmlforest 
  | Is_xmlparse 
  | Is_xmlpi 
  | Is_xmlroot 
  | Is_xmlserialize 
  | Is_document 

type xml_option_type =
  | Xml_option_type_undefined 
  | Xmloption_document 
  | Xmloption_content 

type null_test_type =
  | Null_test_type_undefined 
  | Is_null 
  | Is_not_null 

type bool_test_type =
  | Bool_test_type_undefined 
  | Is_true 
  | Is_not_true 
  | Is_false 
  | Is_not_false 
  | Is_unknown 
  | Is_not_unknown 

type range_tbl_ref = {
  rtindex : int32;
}

type join_type =
  | Join_type_undefined 
  | Join_inner 
  | Join_left 
  | Join_full 
  | Join_right 
  | Join_semi 
  | Join_anti 
  | Join_unique_outer 
  | Join_unique_inner 

type on_conflict_action =
  | On_conflict_action_undefined 
  | Onconflict_none 
  | Onconflict_nothing 
  | Onconflict_update 

type on_commit_action =
  | On_commit_action_undefined 
  | Oncommit_noop 
  | Oncommit_preserve_rows 
  | Oncommit_delete_rows 
  | Oncommit_drop 

type cmd_type =
  | Cmd_type_undefined 
  | Cmd_unknown 
  | Cmd_select 
  | Cmd_update 
  | Cmd_insert 
  | Cmd_delete 
  | Cmd_utility 
  | Cmd_nothing 

type query_source =
  | Query_source_undefined 
  | Qsrc_original 
  | Qsrc_parser 
  | Qsrc_instead_rule 
  | Qsrc_qual_instead_rule 
  | Qsrc_non_instead_rule 

type overriding_kind =
  | Overriding_kind_undefined 
  | Overriding_not_set 
  | Overriding_user_value 
  | Overriding_system_value 

type limit_option =
  | Limit_option_undefined 
  | Limit_option_default 
  | Limit_option_count 
  | Limit_option_with_ties 

type set_operation =
  | Set_operation_undefined 
  | Setop_none 
  | Setop_union 
  | Setop_intersect 
  | Setop_except 

type object_type =
  | Object_type_undefined 
  | Object_access_method 
  | Object_aggregate 
  | Object_amop 
  | Object_amproc 
  | Object_attribute 
  | Object_cast 
  | Object_column 
  | Object_collation 
  | Object_conversion 
  | Object_database 
  | Object_default 
  | Object_defacl 
  | Object_domain 
  | Object_domconstraint 
  | Object_event_trigger 
  | Object_extension 
  | Object_fdw 
  | Object_foreign_server 
  | Object_foreign_table 
  | Object_function 
  | Object_index 
  | Object_language 
  | Object_largeobject 
  | Object_matview 
  | Object_opclass 
  | Object_operator 
  | Object_opfamily 
  | Object_policy 
  | Object_procedure 
  | Object_publication 
  | Object_publication_rel 
  | Object_role 
  | Object_routine 
  | Object_rule 
  | Object_schema 
  | Object_sequence 
  | Object_subscription 
  | Object_statistic_ext 
  | Object_tabconstraint 
  | Object_table 
  | Object_tablespace 
  | Object_transform 
  | Object_trigger 
  | Object_tsconfiguration 
  | Object_tsdictionary 
  | Object_tsparser 
  | Object_tstemplate 
  | Object_type 
  | Object_user_mapping 
  | Object_view 

type alter_table_type =
  | Alter_table_type_undefined 
  | At_add_column 
  | At_add_column_recurse 
  | At_add_column_to_view 
  | At_column_default 
  | At_cooked_column_default 
  | At_drop_not_null 
  | At_set_not_null 
  | At_drop_expression 
  | At_check_not_null 
  | At_set_statistics 
  | At_set_options 
  | At_reset_options 
  | At_set_storage 
  | At_drop_column 
  | At_drop_column_recurse 
  | At_add_index 
  | At_re_add_index 
  | At_add_constraint 
  | At_add_constraint_recurse 
  | At_re_add_constraint 
  | At_re_add_domain_constraint 
  | At_alter_constraint 
  | At_validate_constraint 
  | At_validate_constraint_recurse 
  | At_add_index_constraint 
  | At_drop_constraint 
  | At_drop_constraint_recurse 
  | At_re_add_comment 
  | At_alter_column_type 
  | At_alter_column_generic_options 
  | At_change_owner 
  | At_cluster_on 
  | At_drop_cluster 
  | At_set_logged 
  | At_set_un_logged 
  | At_drop_oids 
  | At_set_table_space 
  | At_set_rel_options 
  | At_reset_rel_options 
  | At_replace_rel_options 
  | At_enable_trig 
  | At_enable_always_trig 
  | At_enable_replica_trig 
  | At_disable_trig 
  | At_enable_trig_all 
  | At_disable_trig_all 
  | At_enable_trig_user 
  | At_disable_trig_user 
  | At_enable_rule 
  | At_enable_always_rule 
  | At_enable_replica_rule 
  | At_disable_rule 
  | At_add_inherit 
  | At_drop_inherit 
  | At_add_of 
  | At_drop_of 
  | At_replica_identity 
  | At_enable_row_security 
  | At_disable_row_security 
  | At_force_row_security 
  | At_no_force_row_security 
  | At_generic_options 
  | At_attach_partition 
  | At_detach_partition 
  | At_add_identity 
  | At_set_identity 
  | At_drop_identity 

type role_spec_type =
  | Role_spec_type_undefined 
  | Rolespec_cstring 
  | Rolespec_current_user 
  | Rolespec_session_user 
  | Rolespec_public 

type role_spec = {
  roletype : role_spec_type;
  rolename : string;
  location : int32;
}

type drop_behavior =
  | Drop_behavior_undefined 
  | Drop_restrict 
  | Drop_cascade 

type grant_target_type =
  | Grant_target_type_undefined 
  | Acl_target_object 
  | Acl_target_all_in_schema 
  | Acl_target_defaults 

type close_portal_stmt = {
  portalname : string;
}

type fetch_direction =
  | Fetch_direction_undefined 
  | Fetch_forward 
  | Fetch_backward 
  | Fetch_absolute 
  | Fetch_relative 

type fetch_stmt = {
  direction : fetch_direction;
  how_many : int64;
  portalname : string;
  ismove : bool;
}

type notify_stmt = {
  conditionname : string;
  payload : string;
}

type listen_stmt = {
  conditionname : string;
}

type unlisten_stmt = {
  conditionname : string;
}

type transaction_stmt_kind =
  | Transaction_stmt_kind_undefined 
  | Trans_stmt_begin 
  | Trans_stmt_start 
  | Trans_stmt_commit 
  | Trans_stmt_rollback 
  | Trans_stmt_savepoint 
  | Trans_stmt_release 
  | Trans_stmt_rollback_to 
  | Trans_stmt_prepare 
  | Trans_stmt_commit_prepared 
  | Trans_stmt_rollback_prepared 

type view_check_option =
  | View_check_option_undefined 
  | No_check_option 
  | Local_check_option 
  | Cascaded_check_option 

type load_stmt = {
  filename : string;
}

type variable_set_kind =
  | Variable_set_kind_undefined 
  | Var_set_value 
  | Var_set_default 
  | Var_set_current 
  | Var_set_multi 
  | Var_reset 
  | Var_reset_all 

type variable_show_stmt = {
  name : string;
}

type discard_mode =
  | Discard_mode_undefined 
  | Discard_all 
  | Discard_plans 
  | Discard_sequences 
  | Discard_temp 

type discard_stmt = {
  target : discard_mode;
}

type role_stmt_type =
  | Role_stmt_type_undefined 
  | Rolestmt_role 
  | Rolestmt_user 
  | Rolestmt_group 

type reindex_object_type =
  | Reindex_object_type_undefined 
  | Reindex_object_index 
  | Reindex_object_table 
  | Reindex_object_schema 
  | Reindex_object_system 
  | Reindex_object_database 

type check_point_stmt = unit

type coercion_context =
  | Coercion_context_undefined 
  | Coercion_implicit 
  | Coercion_assignment 
  | Coercion_explicit 

type deallocate_stmt = {
  name : string;
}

type drop_table_space_stmt = {
  tablespacename : string;
  missing_ok : bool;
}

type alter_tsconfig_type =
  | Alter_tsconfig_type_undefined 
  | Alter_tsconfig_add_mapping 
  | Alter_tsconfig_alter_mapping_for_token 
  | Alter_tsconfig_replace_dict 
  | Alter_tsconfig_replace_dict_for_token 
  | Alter_tsconfig_drop_mapping 

type drop_user_mapping_stmt = {
  user : role_spec option;
  servername : string;
  missing_ok : bool;
}

type import_foreign_schema_type =
  | Import_foreign_schema_type_undefined 
  | Fdw_import_schema_all 
  | Fdw_import_schema_limit_to 
  | Fdw_import_schema_except 

type alter_event_trig_stmt = {
  trigname : string;
  tgenabled : string;
}

type replica_identity_stmt = {
  identity_type : string;
  name : string;
}

type def_elem_action =
  | Def_elem_action_undefined 
  | Defelem_unspec 
  | Defelem_set 
  | Defelem_add 
  | Defelem_drop 

type alter_subscription_type =
  | Alter_subscription_type_undefined 
  | Alter_subscription_options 
  | Alter_subscription_connection 
  | Alter_subscription_publication 
  | Alter_subscription_refresh 
  | Alter_subscription_enabled 

type drop_subscription_stmt = {
  subname : string;
  missing_ok : bool;
  behavior : drop_behavior;
}

type a_expr_kind =
  | A_expr_kind_undefined 
  | Aexpr_op 
  | Aexpr_op_any 
  | Aexpr_op_all 
  | Aexpr_distinct 
  | Aexpr_not_distinct 
  | Aexpr_nullif 
  | Aexpr_of 
  | Aexpr_in 
  | Aexpr_like 
  | Aexpr_ilike 
  | Aexpr_similar 
  | Aexpr_between 
  | Aexpr_not_between 
  | Aexpr_between_sym 
  | Aexpr_not_between_sym 
  | Aexpr_paren 

type param_ref = {
  number : int32;
  location : int32;
}

type a_star = unit

type sort_by_dir =
  | Sort_by_dir_undefined 
  | Sortby_default 
  | Sortby_asc 
  | Sortby_desc 
  | Sortby_using 

type sort_by_nulls =
  | Sort_by_nulls_undefined 
  | Sortby_nulls_default 
  | Sortby_nulls_first 
  | Sortby_nulls_last 

type constr_type =
  | Constr_type_undefined 
  | Constr_null 
  | Constr_notnull 
  | Constr_default 
  | Constr_identity 
  | Constr_generated 
  | Constr_check 
  | Constr_primary 
  | Constr_unique 
  | Constr_exclusion 
  | Constr_foreign 
  | Constr_attr_deferrable 
  | Constr_attr_not_deferrable 
  | Constr_attr_deferred 
  | Constr_attr_immediate 

type rtekind =
  | Rtekind_undefined 
  | Rte_relation 
  | Rte_subquery 
  | Rte_join 
  | Rte_function 
  | Rte_tablefunc 
  | Rte_values 
  | Rte_cte 
  | Rte_namedtuplestore 
  | Rte_result 

type wcokind =
  | Wcokind_undefined 
  | Wco_view_check 
  | Wco_rls_insert_check 
  | Wco_rls_update_check 
  | Wco_rls_conflict_check 

type sort_group_clause = {
  tle_sort_group_ref : int32;
  eqop : int32;
  sortop : int32;
  nulls_first : bool;
  hashable : bool;
}

type grouping_set_kind =
  | Grouping_set_kind_undefined 
  | Grouping_set_empty 
  | Grouping_set_simple 
  | Grouping_set_rollup 
  | Grouping_set_cube 
  | Grouping_set_sets 

type function_parameter_mode =
  | Function_parameter_mode_undefined 
  | Func_param_in 
  | Func_param_out 
  | Func_param_inout 
  | Func_param_variadic 
  | Func_param_table 

type lock_clause_strength =
  | Lock_clause_strength_undefined 
  | Lcs_none 
  | Lcs_forkeyshare 
  | Lcs_forshare 
  | Lcs_fornokeyupdate 
  | Lcs_forupdate 

type lock_wait_policy =
  | Lock_wait_policy_undefined 
  | Lock_wait_block 
  | Lock_wait_skip 
  | Lock_wait_error 

type row_mark_clause = {
  rti : int32;
  strength : lock_clause_strength;
  wait_policy : lock_wait_policy;
  pushed_down : bool;
}

type ctematerialize =
  | Ctematerialize_undefined 
  | Ctematerialize_default 
  | Ctematerialize_always 
  | Ctematerialize_never 

type trigger_transition = {
  name : string;
  is_new : bool;
  is_table : bool;
}

type partition_range_datum_kind =
  | Partition_range_datum_kind_undefined 
  | Partition_range_datum_minvalue 
  | Partition_range_datum_value 
  | Partition_range_datum_maxvalue 

type inline_code_block = {
  source_text : string;
  lang_oid : int32;
  lang_is_trusted : bool;
  atomic : bool;
}

type call_context = {
  atomic : bool;
}

type integer = {
  ival : int32;
}

type pgfloat = {
  str : string;
}

type pgstring = {
  str : string;
}

type bit_string = {
  str : string;
}

type null = unit

type raw_stmt = {
  stmt : node option;
  stmt_location : int32;
  stmt_len : int32;
}

and node =
  | Alias of alias
  | Range_var of range_var
  | Table_func of table_func
  | Expr
  | Var of var
  | Param of param
  | Aggref of aggref
  | Grouping_func of grouping_func
  | Window_func of window_func
  | Subscripting_ref of subscripting_ref
  | Func_expr of func_expr
  | Named_arg_expr of named_arg_expr
  | Op_expr of op_expr
  | Distinct_expr of distinct_expr
  | Null_if_expr of null_if_expr
  | Scalar_array_op_expr of scalar_array_op_expr
  | Bool_expr of bool_expr
  | Sub_link of sub_link
  | Sub_plan of sub_plan
  | Alternative_sub_plan of alternative_sub_plan
  | Field_select of field_select
  | Field_store of field_store
  | Relabel_type of relabel_type
  | Coerce_via_io of coerce_via_io
  | Array_coerce_expr of array_coerce_expr
  | Convert_rowtype_expr of convert_rowtype_expr
  | Collate_expr of collate_expr
  | Case_expr of case_expr
  | Case_when of case_when
  | Case_test_expr of case_test_expr
  | Array_expr of array_expr
  | Row_expr of row_expr
  | Row_compare_expr of row_compare_expr
  | Coalesce_expr of coalesce_expr
  | Min_max_expr of min_max_expr
  | Sqlvalue_function of sqlvalue_function
  | Xml_expr of xml_expr
  | Null_test of null_test
  | Boolean_test of boolean_test
  | Coerce_to_domain of coerce_to_domain
  | Coerce_to_domain_value of coerce_to_domain_value
  | Set_to_default of set_to_default
  | Current_of_expr of current_of_expr
  | Next_value_expr of next_value_expr
  | Inference_elem of inference_elem
  | Target_entry of target_entry
  | Range_tbl_ref of range_tbl_ref
  | Join_expr of join_expr
  | From_expr of from_expr
  | On_conflict_expr of on_conflict_expr
  | Into_clause of into_clause
  | Raw_stmt of raw_stmt
  | Query of query
  | Insert_stmt of insert_stmt
  | Delete_stmt of delete_stmt
  | Update_stmt of update_stmt
  | Select_stmt of select_stmt
  | Alter_table_stmt of alter_table_stmt
  | Alter_table_cmd of alter_table_cmd
  | Alter_domain_stmt of alter_domain_stmt
  | Set_operation_stmt of set_operation_stmt
  | Grant_stmt of grant_stmt
  | Grant_role_stmt of grant_role_stmt
  | Alter_default_privileges_stmt of alter_default_privileges_stmt
  | Close_portal_stmt of close_portal_stmt
  | Cluster_stmt of cluster_stmt
  | Copy_stmt of copy_stmt
  | Create_stmt of create_stmt
  | Define_stmt of define_stmt
  | Drop_stmt of drop_stmt
  | Truncate_stmt of truncate_stmt
  | Comment_stmt of comment_stmt
  | Fetch_stmt of fetch_stmt
  | Index_stmt of index_stmt
  | Create_function_stmt of create_function_stmt
  | Alter_function_stmt of alter_function_stmt
  | Do_stmt of do_stmt
  | Rename_stmt of rename_stmt
  | Rule_stmt of rule_stmt
  | Notify_stmt of notify_stmt
  | Listen_stmt of listen_stmt
  | Unlisten_stmt of unlisten_stmt
  | Transaction_stmt of transaction_stmt
  | View_stmt of view_stmt
  | Load_stmt of load_stmt
  | Create_domain_stmt of create_domain_stmt
  | Createdb_stmt of createdb_stmt
  | Dropdb_stmt of dropdb_stmt
  | Vacuum_stmt of vacuum_stmt
  | Explain_stmt of explain_stmt
  | Create_table_as_stmt of create_table_as_stmt
  | Create_seq_stmt of create_seq_stmt
  | Alter_seq_stmt of alter_seq_stmt
  | Variable_set_stmt of variable_set_stmt
  | Variable_show_stmt of variable_show_stmt
  | Discard_stmt of discard_stmt
  | Create_trig_stmt of create_trig_stmt
  | Create_plang_stmt of create_plang_stmt
  | Create_role_stmt of create_role_stmt
  | Alter_role_stmt of alter_role_stmt
  | Drop_role_stmt of drop_role_stmt
  | Lock_stmt of lock_stmt
  | Constraints_set_stmt of constraints_set_stmt
  | Reindex_stmt of reindex_stmt
  | Check_point_stmt
  | Create_schema_stmt of create_schema_stmt
  | Alter_database_stmt of alter_database_stmt
  | Alter_database_set_stmt of alter_database_set_stmt
  | Alter_role_set_stmt of alter_role_set_stmt
  | Create_conversion_stmt of create_conversion_stmt
  | Create_cast_stmt of create_cast_stmt
  | Create_op_class_stmt of create_op_class_stmt
  | Create_op_family_stmt of create_op_family_stmt
  | Alter_op_family_stmt of alter_op_family_stmt
  | Prepare_stmt of prepare_stmt
  | Execute_stmt of execute_stmt
  | Deallocate_stmt of deallocate_stmt
  | Declare_cursor_stmt of declare_cursor_stmt
  | Create_table_space_stmt of create_table_space_stmt
  | Drop_table_space_stmt of drop_table_space_stmt
  | Alter_object_depends_stmt of alter_object_depends_stmt
  | Alter_object_schema_stmt of alter_object_schema_stmt
  | Alter_owner_stmt of alter_owner_stmt
  | Alter_operator_stmt of alter_operator_stmt
  | Alter_type_stmt of alter_type_stmt
  | Drop_owned_stmt of drop_owned_stmt
  | Reassign_owned_stmt of reassign_owned_stmt
  | Composite_type_stmt of composite_type_stmt
  | Create_enum_stmt of create_enum_stmt
  | Create_range_stmt of create_range_stmt
  | Alter_enum_stmt of alter_enum_stmt
  | Alter_tsdictionary_stmt of alter_tsdictionary_stmt
  | Alter_tsconfiguration_stmt of alter_tsconfiguration_stmt
  | Create_fdw_stmt of create_fdw_stmt
  | Alter_fdw_stmt of alter_fdw_stmt
  | Create_foreign_server_stmt of create_foreign_server_stmt
  | Alter_foreign_server_stmt of alter_foreign_server_stmt
  | Create_user_mapping_stmt of create_user_mapping_stmt
  | Alter_user_mapping_stmt of alter_user_mapping_stmt
  | Drop_user_mapping_stmt of drop_user_mapping_stmt
  | Alter_table_space_options_stmt of alter_table_space_options_stmt
  | Alter_table_move_all_stmt of alter_table_move_all_stmt
  | Sec_label_stmt of sec_label_stmt
  | Create_foreign_table_stmt of create_foreign_table_stmt
  | Import_foreign_schema_stmt of import_foreign_schema_stmt
  | Create_extension_stmt of create_extension_stmt
  | Alter_extension_stmt of alter_extension_stmt
  | Alter_extension_contents_stmt of alter_extension_contents_stmt
  | Create_event_trig_stmt of create_event_trig_stmt
  | Alter_event_trig_stmt of alter_event_trig_stmt
  | Refresh_mat_view_stmt of refresh_mat_view_stmt
  | Replica_identity_stmt of replica_identity_stmt
  | Alter_system_stmt of alter_system_stmt
  | Create_policy_stmt of create_policy_stmt
  | Alter_policy_stmt of alter_policy_stmt
  | Create_transform_stmt of create_transform_stmt
  | Create_am_stmt of create_am_stmt
  | Create_publication_stmt of create_publication_stmt
  | Alter_publication_stmt of alter_publication_stmt
  | Create_subscription_stmt of create_subscription_stmt
  | Alter_subscription_stmt of alter_subscription_stmt
  | Drop_subscription_stmt of drop_subscription_stmt
  | Create_stats_stmt of create_stats_stmt
  | Alter_collation_stmt of alter_collation_stmt
  | Call_stmt of call_stmt
  | Alter_stats_stmt of alter_stats_stmt
  | A_expr of a_expr
  | Column_ref of column_ref
  | Param_ref of param_ref
  | A_const of a_const
  | Func_call of func_call
  | A_star
  | A_indices of a_indices
  | A_indirection of a_indirection
  | A_array_expr of a_array_expr
  | Res_target of res_target
  | Multi_assign_ref of multi_assign_ref
  | Type_cast of type_cast
  | Collate_clause of collate_clause
  | Sort_by of sort_by
  | Window_def of window_def
  | Range_subselect of range_subselect
  | Range_function of range_function
  | Range_table_sample of range_table_sample
  | Range_table_func of range_table_func
  | Range_table_func_col of range_table_func_col
  | Type_name of type_name
  | Column_def of column_def
  | Index_elem of index_elem
  | Constraint of constraint_
  | Def_elem of def_elem
  | Range_tbl_entry of range_tbl_entry
  | Range_tbl_function of range_tbl_function
  | Table_sample_clause of table_sample_clause
  | With_check_option of with_check_option
  | Sort_group_clause of sort_group_clause
  | Grouping_set of grouping_set
  | Window_clause of window_clause
  | Object_with_args of object_with_args
  | Access_priv of access_priv
  | Create_op_class_item of create_op_class_item
  | Table_like_clause of table_like_clause
  | Function_parameter of function_parameter
  | Locking_clause of locking_clause
  | Row_mark_clause of row_mark_clause
  | Xml_serialize of xml_serialize
  | With_clause of with_clause
  | Infer_clause of infer_clause
  | On_conflict_clause of on_conflict_clause
  | Common_table_expr of common_table_expr
  | Role_spec of role_spec
  | Trigger_transition of trigger_transition
  | Partition_elem of partition_elem
  | Partition_spec of partition_spec
  | Partition_bound_spec of partition_bound_spec
  | Partition_range_datum of partition_range_datum
  | Partition_cmd of partition_cmd
  | Vacuum_relation of vacuum_relation
  | Inline_code_block of inline_code_block
  | Call_context of call_context
  | Integer of integer
  | Float of pgfloat
  | String of pgstring
  | Bit_string of bit_string
  | Null
  | List of pglist
  | Int_list of int_list
  | Oid_list of oid_list

and alias = {
  aliasname : string;
  colnames : node list;
}

and range_var = {
  catalogname : string;
  schemaname : string;
  relname : string;
  inh : bool;
  relpersistence : string;
  alias : alias option;
  location : int32;
}

and table_func = {
  ns_uris : node list;
  ns_names : node list;
  docexpr : node option;
  rowexpr : node option;
  colnames : node list;
  coltypes : node list;
  coltypmods : node list;
  colcollations : node list;
  colexprs : node list;
  coldefexprs : node list;
  notnulls : int64 list;
  ordinalitycol : int32;
  location : int32;
}

and var = {
  xpr : node option;
  varno : int32;
  varattno : int32;
  vartype : int32;
  vartypmod : int32;
  varcollid : int32;
  varlevelsup : int32;
  varnosyn : int32;
  varattnosyn : int32;
  location : int32;
}

and param = {
  xpr : node option;
  paramkind : param_kind;
  paramid : int32;
  paramtype : int32;
  paramtypmod : int32;
  paramcollid : int32;
  location : int32;
}

and aggref = {
  xpr : node option;
  aggfnoid : int32;
  aggtype : int32;
  aggcollid : int32;
  inputcollid : int32;
  aggtranstype : int32;
  aggargtypes : node list;
  aggdirectargs : node list;
  args : node list;
  aggorder : node list;
  aggdistinct : node list;
  aggfilter : node option;
  aggstar : bool;
  aggvariadic : bool;
  aggkind : string;
  agglevelsup : int32;
  aggsplit : agg_split;
  location : int32;
}

and grouping_func = {
  xpr : node option;
  args : node list;
  refs : node list;
  cols : node list;
  agglevelsup : int32;
  location : int32;
}

and window_func = {
  xpr : node option;
  winfnoid : int32;
  wintype : int32;
  wincollid : int32;
  inputcollid : int32;
  args : node list;
  aggfilter : node option;
  winref : int32;
  winstar : bool;
  winagg : bool;
  location : int32;
}

and subscripting_ref = {
  xpr : node option;
  refcontainertype : int32;
  refelemtype : int32;
  reftypmod : int32;
  refcollid : int32;
  refupperindexpr : node list;
  reflowerindexpr : node list;
  refexpr : node option;
  refassgnexpr : node option;
}

and func_expr = {
  xpr : node option;
  funcid : int32;
  funcresulttype : int32;
  funcretset : bool;
  funcvariadic : bool;
  funcformat : coercion_form;
  funccollid : int32;
  inputcollid : int32;
  args : node list;
  location : int32;
}

and named_arg_expr = {
  xpr : node option;
  arg : node option;
  name : string;
  argnumber : int32;
  location : int32;
}

and op_expr = {
  xpr : node option;
  opno : int32;
  opfuncid : int32;
  opresulttype : int32;
  opretset : bool;
  opcollid : int32;
  inputcollid : int32;
  args : node list;
  location : int32;
}

and distinct_expr = {
  xpr : node option;
  opno : int32;
  opfuncid : int32;
  opresulttype : int32;
  opretset : bool;
  opcollid : int32;
  inputcollid : int32;
  args : node list;
  location : int32;
}

and null_if_expr = {
  xpr : node option;
  opno : int32;
  opfuncid : int32;
  opresulttype : int32;
  opretset : bool;
  opcollid : int32;
  inputcollid : int32;
  args : node list;
  location : int32;
}

and scalar_array_op_expr = {
  xpr : node option;
  opno : int32;
  opfuncid : int32;
  use_or : bool;
  inputcollid : int32;
  args : node list;
  location : int32;
}

and bool_expr = {
  xpr : node option;
  boolop : bool_expr_type;
  args : node list;
  location : int32;
}

and sub_link = {
  xpr : node option;
  sub_link_type : sub_link_type;
  sub_link_id : int32;
  testexpr : node option;
  oper_name : node list;
  subselect : node option;
  location : int32;
}

and sub_plan = {
  xpr : node option;
  sub_link_type : sub_link_type;
  testexpr : node option;
  param_ids : node list;
  plan_id : int32;
  plan_name : string;
  first_col_type : int32;
  first_col_typmod : int32;
  first_col_collation : int32;
  use_hash_table : bool;
  unknown_eq_false : bool;
  parallel_safe : bool;
  set_param : node list;
  par_param : node list;
  args : node list;
  startup_cost : float;
  per_call_cost : float;
}

and alternative_sub_plan = {
  xpr : node option;
  subplans : node list;
}

and field_select = {
  xpr : node option;
  arg : node option;
  fieldnum : int32;
  resulttype : int32;
  resulttypmod : int32;
  resultcollid : int32;
}

and field_store = {
  xpr : node option;
  arg : node option;
  newvals : node list;
  fieldnums : node list;
  resulttype : int32;
}

and relabel_type = {
  xpr : node option;
  arg : node option;
  resulttype : int32;
  resulttypmod : int32;
  resultcollid : int32;
  relabelformat : coercion_form;
  location : int32;
}

and coerce_via_io = {
  xpr : node option;
  arg : node option;
  resulttype : int32;
  resultcollid : int32;
  coerceformat : coercion_form;
  location : int32;
}

and array_coerce_expr = {
  xpr : node option;
  arg : node option;
  elemexpr : node option;
  resulttype : int32;
  resulttypmod : int32;
  resultcollid : int32;
  coerceformat : coercion_form;
  location : int32;
}

and convert_rowtype_expr = {
  xpr : node option;
  arg : node option;
  resulttype : int32;
  convertformat : coercion_form;
  location : int32;
}

and collate_expr = {
  xpr : node option;
  arg : node option;
  coll_oid : int32;
  location : int32;
}

and case_expr = {
  xpr : node option;
  casetype : int32;
  casecollid : int32;
  arg : node option;
  args : node list;
  defresult : node option;
  location : int32;
}

and case_when = {
  xpr : node option;
  expr : node option;
  result : node option;
  location : int32;
}

and case_test_expr = {
  xpr : node option;
  type_id : int32;
  type_mod : int32;
  collation : int32;
}

and array_expr = {
  xpr : node option;
  array_typeid : int32;
  array_collid : int32;
  element_typeid : int32;
  elements : node list;
  multidims : bool;
  location : int32;
}

and row_expr = {
  xpr : node option;
  args : node list;
  row_typeid : int32;
  row_format : coercion_form;
  colnames : node list;
  location : int32;
}

and row_compare_expr = {
  xpr : node option;
  rctype : row_compare_type;
  opnos : node list;
  opfamilies : node list;
  inputcollids : node list;
  largs : node list;
  rargs : node list;
}

and coalesce_expr = {
  xpr : node option;
  coalescetype : int32;
  coalescecollid : int32;
  args : node list;
  location : int32;
}

and min_max_expr = {
  xpr : node option;
  minmaxtype : int32;
  minmaxcollid : int32;
  inputcollid : int32;
  op : min_max_op;
  args : node list;
  location : int32;
}

and sqlvalue_function = {
  xpr : node option;
  op : sqlvalue_function_op;
  type_ : int32;
  typmod : int32;
  location : int32;
}

and xml_expr = {
  xpr : node option;
  op : xml_expr_op;
  name : string;
  named_args : node list;
  arg_names : node list;
  args : node list;
  xmloption : xml_option_type;
  type_ : int32;
  typmod : int32;
  location : int32;
}

and null_test = {
  xpr : node option;
  arg : node option;
  nulltesttype : null_test_type;
  argisrow : bool;
  location : int32;
}

and boolean_test = {
  xpr : node option;
  arg : node option;
  booltesttype : bool_test_type;
  location : int32;
}

and coerce_to_domain = {
  xpr : node option;
  arg : node option;
  resulttype : int32;
  resulttypmod : int32;
  resultcollid : int32;
  coercionformat : coercion_form;
  location : int32;
}

and coerce_to_domain_value = {
  xpr : node option;
  type_id : int32;
  type_mod : int32;
  collation : int32;
  location : int32;
}

and set_to_default = {
  xpr : node option;
  type_id : int32;
  type_mod : int32;
  collation : int32;
  location : int32;
}

and current_of_expr = {
  xpr : node option;
  cvarno : int32;
  cursor_name : string;
  cursor_param : int32;
}

and next_value_expr = {
  xpr : node option;
  seqid : int32;
  type_id : int32;
}

and inference_elem = {
  xpr : node option;
  expr : node option;
  infercollid : int32;
  inferopclass : int32;
}

and target_entry = {
  xpr : node option;
  expr : node option;
  resno : int32;
  resname : string;
  ressortgroupref : int32;
  resorigtbl : int32;
  resorigcol : int32;
  resjunk : bool;
}

and join_expr = {
  jointype : join_type;
  is_natural : bool;
  larg : node option;
  rarg : node option;
  using_clause : node list;
  quals : node option;
  alias : alias option;
  rtindex : int32;
}

and from_expr = {
  fromlist : node list;
  quals : node option;
}

and on_conflict_expr = {
  action : on_conflict_action;
  arbiter_elems : node list;
  arbiter_where : node option;
  constraint_ : int32;
  on_conflict_set : node list;
  on_conflict_where : node option;
  excl_rel_index : int32;
  excl_rel_tlist : node list;
}

and into_clause = {
  rel : range_var option;
  col_names : node list;
  access_method : string;
  options : node list;
  on_commit : on_commit_action;
  table_space_name : string;
  view_query : node option;
  skip_data : bool;
}

and query = {
  command_type : cmd_type;
  query_source : query_source;
  can_set_tag : bool;
  utility_stmt : node option;
  result_relation : int32;
  has_aggs : bool;
  has_window_funcs : bool;
  has_target_srfs : bool;
  has_sub_links : bool;
  has_distinct_on : bool;
  has_recursive : bool;
  has_modifying_cte : bool;
  has_for_update : bool;
  has_row_security : bool;
  cte_list : node list;
  rtable : node list;
  jointree : from_expr option;
  target_list : node list;
  override : overriding_kind;
  on_conflict : on_conflict_expr option;
  returning_list : node list;
  group_clause : node list;
  grouping_sets : node list;
  having_qual : node option;
  window_clause : node list;
  distinct_clause : node list;
  sort_clause : node list;
  limit_offset : node option;
  limit_count : node option;
  limit_option : limit_option;
  row_marks : node list;
  set_operations : node option;
  constraint_deps : node list;
  with_check_options : node list;
  stmt_location : int32;
  stmt_len : int32;
}

and insert_stmt = {
  relation : range_var option;
  cols : node list;
  select_stmt : node option;
  on_conflict_clause : on_conflict_clause option;
  returning_list : node list;
  with_clause : with_clause option;
  override : overriding_kind;
}

and on_conflict_clause = {
  action : on_conflict_action;
  infer : infer_clause option;
  target_list : node list;
  where_clause : node option;
  location : int32;
}

and infer_clause = {
  index_elems : node list;
  where_clause : node option;
  conname : string;
  location : int32;
}

and with_clause = {
  ctes : node list;
  recursive : bool;
  location : int32;
}

and delete_stmt = {
  relation : range_var option;
  using_clause : node list;
  where_clause : node option;
  returning_list : node list;
  with_clause : with_clause option;
}

and update_stmt = {
  relation : range_var option;
  target_list : node list;
  where_clause : node option;
  from_clause : node list;
  returning_list : node list;
  with_clause : with_clause option;
}

and select_stmt = {
  distinct_clause : node list;
  into_clause : into_clause option;
  target_list : node list;
  from_clause : node list;
  where_clause : node option;
  group_clause : node list;
  having_clause : node option;
  window_clause : node list;
  values_lists : node list;
  sort_clause : node list;
  limit_offset : node option;
  limit_count : node option;
  limit_option : limit_option;
  locking_clause : node list;
  with_clause : with_clause option;
  op : set_operation;
  all : bool;
  larg : select_stmt option;
  rarg : select_stmt option;
}

and alter_table_stmt = {
  relation : range_var option;
  cmds : node list;
  relkind : object_type;
  missing_ok : bool;
}

and alter_table_cmd = {
  subtype : alter_table_type;
  name : string;
  num : int32;
  newowner : role_spec option;
  def : node option;
  behavior : drop_behavior;
  missing_ok : bool;
  recurse : bool;
}

and alter_domain_stmt = {
  subtype : string;
  type_name : node list;
  name : string;
  def : node option;
  behavior : drop_behavior;
  missing_ok : bool;
}

and set_operation_stmt = {
  op : set_operation;
  all : bool;
  larg : node option;
  rarg : node option;
  col_types : node list;
  col_typmods : node list;
  col_collations : node list;
  group_clauses : node list;
}

and grant_stmt = {
  is_grant : bool;
  targtype : grant_target_type;
  objtype : object_type;
  objects : node list;
  privileges : node list;
  grantees : node list;
  grant_option : bool;
  behavior : drop_behavior;
}

and grant_role_stmt = {
  granted_roles : node list;
  grantee_roles : node list;
  is_grant : bool;
  admin_opt : bool;
  grantor : role_spec option;
  behavior : drop_behavior;
}

and alter_default_privileges_stmt = {
  options : node list;
  action : grant_stmt option;
}

and cluster_stmt = {
  relation : range_var option;
  indexname : string;
  options : int32;
}

and copy_stmt = {
  relation : range_var option;
  query : node option;
  attlist : node list;
  is_from : bool;
  is_program : bool;
  filename : string;
  options : node list;
  where_clause : node option;
}

and create_stmt = {
  relation : range_var option;
  table_elts : node list;
  inh_relations : node list;
  partbound : partition_bound_spec option;
  partspec : partition_spec option;
  of_typename : type_name option;
  constraints : node list;
  options : node list;
  oncommit : on_commit_action;
  tablespacename : string;
  access_method : string;
  if_not_exists : bool;
}

and partition_bound_spec = {
  strategy : string;
  is_default : bool;
  modulus : int32;
  remainder : int32;
  listdatums : node list;
  lowerdatums : node list;
  upperdatums : node list;
  location : int32;
}

and partition_spec = {
  strategy : string;
  part_params : node list;
  location : int32;
}

and type_name = {
  names : node list;
  type_oid : int32;
  setof : bool;
  pct_type : bool;
  typmods : node list;
  typemod : int32;
  array_bounds : node list;
  location : int32;
}

and define_stmt = {
  kind : object_type;
  oldstyle : bool;
  defnames : node list;
  args : node list;
  definition : node list;
  if_not_exists : bool;
  replace : bool;
}

and drop_stmt = {
  objects : node list;
  remove_type : object_type;
  behavior : drop_behavior;
  missing_ok : bool;
  concurrent : bool;
}

and truncate_stmt = {
  relations : node list;
  restart_seqs : bool;
  behavior : drop_behavior;
}

and comment_stmt = {
  objtype : object_type;
  object_ : node option;
  comment : string;
}

and index_stmt = {
  idxname : string;
  relation : range_var option;
  access_method : string;
  table_space : string;
  index_params : node list;
  index_including_params : node list;
  options : node list;
  where_clause : node option;
  exclude_op_names : node list;
  idxcomment : string;
  index_oid : int32;
  old_node : int32;
  old_create_subid : int32;
  old_first_relfilenode_subid : int32;
  unique : bool;
  primary : bool;
  isconstraint : bool;
  deferrable : bool;
  initdeferred : bool;
  transformed : bool;
  concurrent : bool;
  if_not_exists : bool;
  reset_default_tblspc : bool;
}

and create_function_stmt = {
  is_procedure : bool;
  replace : bool;
  funcname : node list;
  parameters : node list;
  return_type : type_name option;
  options : node list;
}

and alter_function_stmt = {
  objtype : object_type;
  func : object_with_args option;
  actions : node list;
}

and object_with_args = {
  objname : node list;
  objargs : node list;
  args_unspecified : bool;
}

and do_stmt = {
  args : node list;
}

and rename_stmt = {
  rename_type : object_type;
  relation_type : object_type;
  relation : range_var option;
  object_ : node option;
  subname : string;
  newname : string;
  behavior : drop_behavior;
  missing_ok : bool;
}

and rule_stmt = {
  relation : range_var option;
  rulename : string;
  where_clause : node option;
  event : cmd_type;
  instead : bool;
  actions : node list;
  replace : bool;
}

and transaction_stmt = {
  kind : transaction_stmt_kind;
  options : node list;
  savepoint_name : string;
  gid : string;
  chain : bool;
}

and view_stmt = {
  view : range_var option;
  aliases : node list;
  query : node option;
  replace : bool;
  options : node list;
  with_check_option : view_check_option;
}

and create_domain_stmt = {
  domainname : node list;
  type_name : type_name option;
  coll_clause : collate_clause option;
  constraints : node list;
}

and collate_clause = {
  arg : node option;
  collname : node list;
  location : int32;
}

and createdb_stmt = {
  dbname : string;
  options : node list;
}

and dropdb_stmt = {
  dbname : string;
  missing_ok : bool;
  options : node list;
}

and vacuum_stmt = {
  options : node list;
  rels : node list;
  is_vacuumcmd : bool;
}

and explain_stmt = {
  query : node option;
  options : node list;
}

and create_table_as_stmt = {
  query : node option;
  into : into_clause option;
  relkind : object_type;
  is_select_into : bool;
  if_not_exists : bool;
}

and create_seq_stmt = {
  sequence : range_var option;
  options : node list;
  owner_id : int32;
  for_identity : bool;
  if_not_exists : bool;
}

and alter_seq_stmt = {
  sequence : range_var option;
  options : node list;
  for_identity : bool;
  missing_ok : bool;
}

and variable_set_stmt = {
  kind : variable_set_kind;
  name : string;
  args : node list;
  is_local : bool;
}

and create_trig_stmt = {
  trigname : string;
  relation : range_var option;
  funcname : node list;
  args : node list;
  row : bool;
  timing : int32;
  events : int32;
  columns : node list;
  when_clause : node option;
  isconstraint : bool;
  transition_rels : node list;
  deferrable : bool;
  initdeferred : bool;
  constrrel : range_var option;
}

and create_plang_stmt = {
  replace : bool;
  plname : string;
  plhandler : node list;
  plinline : node list;
  plvalidator : node list;
  pltrusted : bool;
}

and create_role_stmt = {
  stmt_type : role_stmt_type;
  role : string;
  options : node list;
}

and alter_role_stmt = {
  role : role_spec option;
  options : node list;
  action : int32;
}

and drop_role_stmt = {
  roles : node list;
  missing_ok : bool;
}

and lock_stmt = {
  relations : node list;
  mode : int32;
  nowait : bool;
}

and constraints_set_stmt = {
  constraints : node list;
  deferred : bool;
}

and reindex_stmt = {
  kind : reindex_object_type;
  relation : range_var option;
  name : string;
  options : int32;
  concurrent : bool;
}

and create_schema_stmt = {
  schemaname : string;
  authrole : role_spec option;
  schema_elts : node list;
  if_not_exists : bool;
}

and alter_database_stmt = {
  dbname : string;
  options : node list;
}

and alter_database_set_stmt = {
  dbname : string;
  setstmt : variable_set_stmt option;
}

and alter_role_set_stmt = {
  role : role_spec option;
  database : string;
  setstmt : variable_set_stmt option;
}

and create_conversion_stmt = {
  conversion_name : node list;
  for_encoding_name : string;
  to_encoding_name : string;
  func_name : node list;
  def : bool;
}

and create_cast_stmt = {
  sourcetype : type_name option;
  targettype : type_name option;
  func : object_with_args option;
  context : coercion_context;
  inout : bool;
}

and create_op_class_stmt = {
  opclassname : node list;
  opfamilyname : node list;
  amname : string;
  datatype : type_name option;
  items : node list;
  is_default : bool;
}

and create_op_family_stmt = {
  opfamilyname : node list;
  amname : string;
}

and alter_op_family_stmt = {
  opfamilyname : node list;
  amname : string;
  is_drop : bool;
  items : node list;
}

and prepare_stmt = {
  name : string;
  argtypes : node list;
  query : node option;
}

and execute_stmt = {
  name : string;
  params : node list;
}

and declare_cursor_stmt = {
  portalname : string;
  options : int32;
  query : node option;
}

and create_table_space_stmt = {
  tablespacename : string;
  owner : role_spec option;
  location : string;
  options : node list;
}

and alter_object_depends_stmt = {
  object_type : object_type;
  relation : range_var option;
  object_ : node option;
  extname : node option;
  remove : bool;
}

and alter_object_schema_stmt = {
  object_type : object_type;
  relation : range_var option;
  object_ : node option;
  newschema : string;
  missing_ok : bool;
}

and alter_owner_stmt = {
  object_type : object_type;
  relation : range_var option;
  object_ : node option;
  newowner : role_spec option;
}

and alter_operator_stmt = {
  opername : object_with_args option;
  options : node list;
}

and alter_type_stmt = {
  type_name : node list;
  options : node list;
}

and drop_owned_stmt = {
  roles : node list;
  behavior : drop_behavior;
}

and reassign_owned_stmt = {
  roles : node list;
  newrole : role_spec option;
}

and composite_type_stmt = {
  typevar : range_var option;
  coldeflist : node list;
}

and create_enum_stmt = {
  type_name : node list;
  vals : node list;
}

and create_range_stmt = {
  type_name : node list;
  params : node list;
}

and alter_enum_stmt = {
  type_name : node list;
  old_val : string;
  new_val : string;
  new_val_neighbor : string;
  new_val_is_after : bool;
  skip_if_new_val_exists : bool;
}

and alter_tsdictionary_stmt = {
  dictname : node list;
  options : node list;
}

and alter_tsconfiguration_stmt = {
  kind : alter_tsconfig_type;
  cfgname : node list;
  tokentype : node list;
  dicts : node list;
  override : bool;
  replace : bool;
  missing_ok : bool;
}

and create_fdw_stmt = {
  fdwname : string;
  func_options : node list;
  options : node list;
}

and alter_fdw_stmt = {
  fdwname : string;
  func_options : node list;
  options : node list;
}

and create_foreign_server_stmt = {
  servername : string;
  servertype : string;
  version : string;
  fdwname : string;
  if_not_exists : bool;
  options : node list;
}

and alter_foreign_server_stmt = {
  servername : string;
  version : string;
  options : node list;
  has_version : bool;
}

and create_user_mapping_stmt = {
  user : role_spec option;
  servername : string;
  if_not_exists : bool;
  options : node list;
}

and alter_user_mapping_stmt = {
  user : role_spec option;
  servername : string;
  options : node list;
}

and alter_table_space_options_stmt = {
  tablespacename : string;
  options : node list;
  is_reset : bool;
}

and alter_table_move_all_stmt = {
  orig_tablespacename : string;
  objtype : object_type;
  roles : node list;
  new_tablespacename : string;
  nowait : bool;
}

and sec_label_stmt = {
  objtype : object_type;
  object_ : node option;
  provider : string;
  label : string;
}

and create_foreign_table_stmt = {
  base_stmt : create_stmt option;
  servername : string;
  options : node list;
}

and import_foreign_schema_stmt = {
  server_name : string;
  remote_schema : string;
  local_schema : string;
  list_type : import_foreign_schema_type;
  table_list : node list;
  options : node list;
}

and create_extension_stmt = {
  extname : string;
  if_not_exists : bool;
  options : node list;
}

and alter_extension_stmt = {
  extname : string;
  options : node list;
}

and alter_extension_contents_stmt = {
  extname : string;
  action : int32;
  objtype : object_type;
  object_ : node option;
}

and create_event_trig_stmt = {
  trigname : string;
  eventname : string;
  whenclause : node list;
  funcname : node list;
}

and refresh_mat_view_stmt = {
  concurrent : bool;
  skip_data : bool;
  relation : range_var option;
}

and alter_system_stmt = {
  setstmt : variable_set_stmt option;
}

and create_policy_stmt = {
  policy_name : string;
  table : range_var option;
  cmd_name : string;
  permissive : bool;
  roles : node list;
  qual : node option;
  with_check : node option;
}

and alter_policy_stmt = {
  policy_name : string;
  table : range_var option;
  roles : node list;
  qual : node option;
  with_check : node option;
}

and create_transform_stmt = {
  replace : bool;
  type_name : type_name option;
  lang : string;
  fromsql : object_with_args option;
  tosql : object_with_args option;
}

and create_am_stmt = {
  amname : string;
  handler_name : node list;
  amtype : string;
}

and create_publication_stmt = {
  pubname : string;
  options : node list;
  tables : node list;
  for_all_tables : bool;
}

and alter_publication_stmt = {
  pubname : string;
  options : node list;
  tables : node list;
  for_all_tables : bool;
  table_action : def_elem_action;
}

and create_subscription_stmt = {
  subname : string;
  conninfo : string;
  publication : node list;
  options : node list;
}

and alter_subscription_stmt = {
  kind : alter_subscription_type;
  subname : string;
  conninfo : string;
  publication : node list;
  options : node list;
}

and create_stats_stmt = {
  defnames : node list;
  stat_types : node list;
  exprs : node list;
  relations : node list;
  stxcomment : string;
  if_not_exists : bool;
}

and alter_collation_stmt = {
  collname : node list;
}

and call_stmt = {
  funccall : func_call option;
  funcexpr : func_expr option;
}

and func_call = {
  funcname : node list;
  args : node list;
  agg_order : node list;
  agg_filter : node option;
  agg_within_group : bool;
  agg_star : bool;
  agg_distinct : bool;
  func_variadic : bool;
  over : window_def option;
  location : int32;
}

and window_def = {
  name : string;
  refname : string;
  partition_clause : node list;
  order_clause : node list;
  frame_options : int32;
  start_offset : node option;
  end_offset : node option;
  location : int32;
}

and alter_stats_stmt = {
  defnames : node list;
  stxstattarget : int32;
  missing_ok : bool;
}

and a_expr = {
  kind : a_expr_kind;
  name : node list;
  lexpr : node option;
  rexpr : node option;
  location : int32;
}

and column_ref = {
  fields : node list;
  location : int32;
}

and a_const = {
  val_ : node option;
  location : int32;
}

and a_indices = {
  is_slice : bool;
  lidx : node option;
  uidx : node option;
}

and a_indirection = {
  arg : node option;
  indirection : node list;
}

and a_array_expr = {
  elements : node list;
  location : int32;
}

and res_target = {
  name : string;
  indirection : node list;
  val_ : node option;
  location : int32;
}

and multi_assign_ref = {
  source : node option;
  colno : int32;
  ncolumns : int32;
}

and type_cast = {
  arg : node option;
  type_name : type_name option;
  location : int32;
}

and sort_by = {
  node : node option;
  sortby_dir : sort_by_dir;
  sortby_nulls : sort_by_nulls;
  use_op : node list;
  location : int32;
}

and range_subselect = {
  lateral : bool;
  subquery : node option;
  alias : alias option;
}

and range_function = {
  lateral : bool;
  ordinality : bool;
  is_rowsfrom : bool;
  functions : node list;
  alias : alias option;
  coldeflist : node list;
}

and range_table_sample = {
  relation : node option;
  method_ : node list;
  args : node list;
  repeatable : node option;
  location : int32;
}

and range_table_func = {
  lateral : bool;
  docexpr : node option;
  rowexpr : node option;
  namespaces : node list;
  columns : node list;
  alias : alias option;
  location : int32;
}

and range_table_func_col = {
  colname : string;
  type_name : type_name option;
  for_ordinality : bool;
  is_not_null : bool;
  colexpr : node option;
  coldefexpr : node option;
  location : int32;
}

and column_def = {
  colname : string;
  type_name : type_name option;
  inhcount : int32;
  is_local : bool;
  is_not_null : bool;
  is_from_type : bool;
  storage : string;
  raw_default : node option;
  cooked_default : node option;
  identity : string;
  identity_sequence : range_var option;
  generated : string;
  coll_clause : collate_clause option;
  coll_oid : int32;
  constraints : node list;
  fdwoptions : node list;
  location : int32;
}

and index_elem = {
  name : string;
  expr : node option;
  indexcolname : string;
  collation : node list;
  opclass : node list;
  opclassopts : node list;
  ordering : sort_by_dir;
  nulls_ordering : sort_by_nulls;
}

and constraint_ = {
  contype : constr_type;
  conname : string;
  deferrable : bool;
  initdeferred : bool;
  location : int32;
  is_no_inherit : bool;
  raw_expr : node option;
  cooked_expr : string;
  generated_when : string;
  keys : node list;
  including : node list;
  exclusions : node list;
  options : node list;
  indexname : string;
  indexspace : string;
  reset_default_tblspc : bool;
  access_method : string;
  where_clause : node option;
  pktable : range_var option;
  fk_attrs : node list;
  pk_attrs : node list;
  fk_matchtype : string;
  fk_upd_action : string;
  fk_del_action : string;
  old_conpfeqop : node list;
  old_pktable_oid : int32;
  skip_validation : bool;
  initially_valid : bool;
}

and def_elem = {
  defnamespace : string;
  defname : string;
  arg : node option;
  defaction : def_elem_action;
  location : int32;
}

and range_tbl_entry = {
  rtekind : rtekind;
  relid : int32;
  relkind : string;
  rellockmode : int32;
  tablesample : table_sample_clause option;
  subquery : query option;
  security_barrier : bool;
  jointype : join_type;
  joinmergedcols : int32;
  joinaliasvars : node list;
  joinleftcols : node list;
  joinrightcols : node list;
  functions : node list;
  funcordinality : bool;
  tablefunc : table_func option;
  values_lists : node list;
  ctename : string;
  ctelevelsup : int32;
  self_reference : bool;
  coltypes : node list;
  coltypmods : node list;
  colcollations : node list;
  enrname : string;
  enrtuples : float;
  alias : alias option;
  eref : alias option;
  lateral : bool;
  inh : bool;
  in_from_cl : bool;
  required_perms : int32;
  check_as_user : int32;
  selected_cols : int64 list;
  inserted_cols : int64 list;
  updated_cols : int64 list;
  extra_updated_cols : int64 list;
  security_quals : node list;
}

and table_sample_clause = {
  tsmhandler : int32;
  args : node list;
  repeatable : node option;
}

and range_tbl_function = {
  funcexpr : node option;
  funccolcount : int32;
  funccolnames : node list;
  funccoltypes : node list;
  funccoltypmods : node list;
  funccolcollations : node list;
  funcparams : int64 list;
}

and with_check_option = {
  kind : wcokind;
  relname : string;
  polname : string;
  qual : node option;
  cascaded : bool;
}

and grouping_set = {
  kind : grouping_set_kind;
  content : node list;
  location : int32;
}

and window_clause = {
  name : string;
  refname : string;
  partition_clause : node list;
  order_clause : node list;
  frame_options : int32;
  start_offset : node option;
  end_offset : node option;
  start_in_range_func : int32;
  end_in_range_func : int32;
  in_range_coll : int32;
  in_range_asc : bool;
  in_range_nulls_first : bool;
  winref : int32;
  copied_order : bool;
}

and access_priv = {
  priv_name : string;
  cols : node list;
}

and create_op_class_item = {
  itemtype : int32;
  name : object_with_args option;
  number : int32;
  order_family : node list;
  class_args : node list;
  storedtype : type_name option;
}

and table_like_clause = {
  relation : range_var option;
  options : int32;
  relation_oid : int32;
}

and function_parameter = {
  name : string;
  arg_type : type_name option;
  mode : function_parameter_mode;
  defexpr : node option;
}

and locking_clause = {
  locked_rels : node list;
  strength : lock_clause_strength;
  wait_policy : lock_wait_policy;
}

and xml_serialize = {
  xmloption : xml_option_type;
  expr : node option;
  type_name : type_name option;
  location : int32;
}

and common_table_expr = {
  ctename : string;
  aliascolnames : node list;
  ctematerialized : ctematerialize;
  ctequery : node option;
  location : int32;
  cterecursive : bool;
  cterefcount : int32;
  ctecolnames : node list;
  ctecoltypes : node list;
  ctecoltypmods : node list;
  ctecolcollations : node list;
}

and partition_elem = {
  name : string;
  expr : node option;
  collation : node list;
  opclass : node list;
  location : int32;
}

and partition_range_datum = {
  kind : partition_range_datum_kind;
  value : node option;
  location : int32;
}

and partition_cmd = {
  name : range_var option;
  bound : partition_bound_spec option;
}

and vacuum_relation = {
  relation : range_var option;
  oid : int32;
  va_cols : node list;
}

and pglist = {
  items : node list;
}

and int_list = {
  items : node list;
}

and oid_list = {
  items : node list;
}

type parse_result = {
  version : int32;
  stmts : raw_stmt list;
}

type token =
  | Nul 
  | Ascii_37 
  | Ascii_40 
  | Ascii_41 
  | Ascii_42 
  | Ascii_43 
  | Ascii_44 
  | Ascii_45 
  | Ascii_46 
  | Ascii_47 
  | Ascii_58 
  | Ascii_59 
  | Ascii_60 
  | Ascii_61 
  | Ascii_62 
  | Ascii_63 
  | Ascii_91 
  | Ascii_92 
  | Ascii_93 
  | Ascii_94 
  | Ident 
  | Uident 
  | Fconst 
  | Sconst 
  | Usconst 
  | Bconst 
  | Xconst 
  | Op 
  | Iconst 
  | Param 
  | Typecast 
  | Dot_dot 
  | Colon_equals 
  | Equals_greater 
  | Less_equals 
  | Greater_equals 
  | Not_equals 
  | Sql_comment 
  | C_comment 
  | Abort_p 
  | Absolute_p 
  | Access 
  | Action 
  | Add_p 
  | Admin 
  | After 
  | Aggregate 
  | All 
  | Also 
  | Alter 
  | Always 
  | Analyse 
  | Analyze 
  | And 
  | Any 
  | Array 
  | As 
  | Asc 
  | Assertion 
  | Assignment 
  | Asymmetric 
  | At 
  | Attach 
  | Attribute 
  | Authorization 
  | Backward 
  | Before 
  | Begin_p 
  | Between 
  | Bigint 
  | Binary 
  | Bit 
  | Boolean_p 
  | Both 
  | By 
  | Cache 
  | Call 
  | Called 
  | Cascade 
  | Cascaded 
  | Case 
  | Cast 
  | Catalog_p 
  | Chain 
  | Char_p 
  | Character 
  | Characteristics 
  | Check 
  | Checkpoint 
  | Class 
  | Close 
  | Cluster 
  | Coalesce 
  | Collate 
  | Collation 
  | Column 
  | Columns 
  | Comment 
  | Comments 
  | Commit 
  | Committed 
  | Concurrently 
  | Configuration 
  | Conflict 
  | Connection 
  | Constraint 
  | Constraints 
  | Content_p 
  | Continue_p 
  | Conversion_p 
  | Copy 
  | Cost 
  | Create 
  | Cross 
  | Csv 
  | Cube 
  | Current_p 
  | Current_catalog 
  | Current_date 
  | Current_role 
  | Current_schema 
  | Current_time 
  | Current_timestamp 
  | Current_user 
  | Cursor 
  | Cycle 
  | Data_p 
  | Database 
  | Day_p 
  | Deallocate 
  | Dec 
  | Decimal_p 
  | Declare 
  | Default 
  | Defaults 
  | Deferrable 
  | Deferred 
  | Definer 
  | Delete_p 
  | Delimiter 
  | Delimiters 
  | Depends 
  | Desc 
  | Detach 
  | Dictionary 
  | Disable_p 
  | Discard 
  | Distinct 
  | Do 
  | Document_p 
  | Domain_p 
  | Double_p 
  | Drop 
  | Each 
  | Else 
  | Enable_p 
  | Encoding 
  | Encrypted 
  | End_p 
  | Enum_p 
  | Escape 
  | Event 
  | Except 
  | Exclude 
  | Excluding 
  | Exclusive 
  | Execute 
  | Exists 
  | Explain 
  | Expression 
  | Extension 
  | External 
  | Extract 
  | False_p 
  | Family 
  | Fetch 
  | Filter 
  | First_p 
  | Float_p 
  | Following 
  | For 
  | Force 
  | Foreign 
  | Forward 
  | Freeze 
  | From 
  | Full 
  | Function 
  | Functions 
  | Generated 
  | Global 
  | Grant 
  | Granted 
  | Greatest 
  | Group_p 
  | Grouping 
  | Groups 
  | Handler 
  | Having 
  | Header_p 
  | Hold 
  | Hour_p 
  | Identity_p 
  | If_p 
  | Ilike 
  | Immediate 
  | Immutable 
  | Implicit_p 
  | Import_p 
  | In_p 
  | Include 
  | Including 
  | Increment 
  | Index 
  | Indexes 
  | Inherit 
  | Inherits 
  | Initially 
  | Inline_p 
  | Inner_p 
  | Inout 
  | Input_p 
  | Insensitive 
  | Insert 
  | Instead 
  | Int_p 
  | Integer 
  | Intersect 
  | Interval 
  | Into 
  | Invoker 
  | Is 
  | Isnull 
  | Isolation 
  | Join 
  | Key 
  | Label 
  | Language 
  | Large_p 
  | Last_p 
  | Lateral_p 
  | Leading 
  | Leakproof 
  | Least 
  | Left 
  | Level 
  | Like 
  | Limit 
  | Listen 
  | Load 
  | Local 
  | Localtime 
  | Localtimestamp 
  | Location 
  | Lock_p 
  | Locked 
  | Logged 
  | Mapping 
  | Match 
  | Materialized 
  | Maxvalue 
  | Method 
  | Minute_p 
  | Minvalue 
  | Mode 
  | Month_p 
  | Move 
  | Name_p 
  | Names 
  | National 
  | Natural 
  | Nchar 
  | New 
  | Next 
  | Nfc 
  | Nfd 
  | Nfkc 
  | Nfkd 
  | No 
  | None 
  | Normalize 
  | Normalized 
  | Not 
  | Nothing 
  | Notify 
  | Notnull 
  | Nowait 
  | Null_p 
  | Nullif 
  | Nulls_p 
  | Numeric 
  | Object_p 
  | Of 
  | Off 
  | Offset 
  | Oids 
  | Old 
  | On 
  | Only 
  | Operator 
  | Option 
  | Options 
  | Or 
  | Order 
  | Ordinality 
  | Others 
  | Out_p 
  | Outer_p 
  | Over 
  | Overlaps 
  | Overlay 
  | Overriding 
  | Owned 
  | Owner 
  | Parallel 
  | Parser 
  | Partial 
  | Partition 
  | Passing 
  | Password 
  | Placing 
  | Plans 
  | Policy 
  | Position 
  | Preceding 
  | Precision 
  | Preserve 
  | Prepare 
  | Prepared 
  | Primary 
  | Prior 
  | Privileges 
  | Procedural 
  | Procedure 
  | Procedures 
  | Program 
  | Publication 
  | Quote 
  | Range 
  | Read 
  | Real 
  | Reassign 
  | Recheck 
  | Recursive 
  | Ref_p 
  | References 
  | Referencing 
  | Refresh 
  | Reindex 
  | Relative_p 
  | Release 
  | Rename 
  | Repeatable 
  | Replace 
  | Replica 
  | Reset 
  | Restart 
  | Restrict 
  | Returning 
  | Returns 
  | Revoke 
  | Right 
  | Role 
  | Rollback 
  | Rollup 
  | Routine 
  | Routines 
  | Row 
  | Rows 
  | Rule 
  | Savepoint 
  | Schema 
  | Schemas 
  | Scroll 
  | Search 
  | Second_p 
  | Security 
  | Select 
  | Sequence 
  | Sequences 
  | Serializable 
  | Server 
  | Session 
  | Session_user 
  | Set 
  | Sets 
  | Setof 
  | Share 
  | Show 
  | Similar 
  | Simple 
  | Skip 
  | Smallint 
  | Snapshot 
  | Some 
  | Sql_p 
  | Stable 
  | Standalone_p 
  | Start 
  | Statement 
  | Statistics 
  | Stdin 
  | Stdout 
  | Storage 
  | Stored 
  | Strict_p 
  | Strip_p 
  | Subscription 
  | Substring 
  | Support 
  | Symmetric 
  | Sysid 
  | System_p 
  | Table 
  | Tables 
  | Tablesample 
  | Tablespace 
  | Temp 
  | Template 
  | Temporary 
  | Text_p 
  | Then 
  | Ties 
  | Time 
  | Timestamp 
  | To 
  | Trailing 
  | Transaction 
  | Transform 
  | Treat 
  | Trigger 
  | Trim 
  | True_p 
  | Truncate 
  | Trusted 
  | Type_p 
  | Types_p 
  | Uescape 
  | Unbounded 
  | Uncommitted 
  | Unencrypted 
  | Union 
  | Unique 
  | Unknown 
  | Unlisten 
  | Unlogged 
  | Until 
  | Update 
  | User 
  | Using 
  | Vacuum 
  | Valid 
  | Validate 
  | Validator 
  | Value_p 
  | Values 
  | Varchar 
  | Variadic 
  | Varying 
  | Verbose 
  | Version_p 
  | View 
  | Views 
  | Volatile 
  | When 
  | Where 
  | Whitespace_p 
  | Window 
  | With 
  | Within 
  | Without 
  | Work 
  | Wrapper 
  | Write 
  | Xml_p 
  | Xmlattributes 
  | Xmlconcat 
  | Xmlelement 
  | Xmlexists 
  | Xmlforest 
  | Xmlnamespaces 
  | Xmlparse 
  | Xmlpi 
  | Xmlroot 
  | Xmlserialize 
  | Xmltable 
  | Year_p 
  | Yes_p 
  | Zone 
  | Not_la 
  | Nulls_la 
  | With_la 
  | Postfixop 
  | Uminus 

type keyword_kind =
  | No_keyword 
  | Unreserved_keyword 
  | Col_name_keyword 
  | Type_func_name_keyword 
  | Reserved_keyword 

type scan_token = {
  start : int32;
  end_ : int32;
  token : token;
  keyword_kind : keyword_kind;
}

type scan_result = {
  version : int32;
  tokens : scan_token list;
}

type table_like_option =
  | Table_like_option_undefined 
  | Create_table_like_comments 
  | Create_table_like_constraints 
  | Create_table_like_defaults 
  | Create_table_like_generated 
  | Create_table_like_identity 
  | Create_table_like_indexes 
  | Create_table_like_statistics 
  | Create_table_like_storage 
  | Create_table_like_all 

type cluster_option =
  | Cluster_option_undefined 
  | Cluopt_recheck 
  | Cluopt_verbose 

type agg_strategy =
  | Agg_strategy_undefined 
  | Agg_plain 
  | Agg_sorted 
  | Agg_hashed 
  | Agg_mixed 

type set_op_cmd =
  | Set_op_cmd_undefined 
  | Setopcmd_intersect 
  | Setopcmd_intersect_all 
  | Setopcmd_except 
  | Setopcmd_except_all 

type set_op_strategy =
  | Set_op_strategy_undefined 
  | Setop_sorted 
  | Setop_hashed 

type lock_tuple_mode =
  | Lock_tuple_mode_undefined 
  | Lock_tuple_key_share 
  | Lock_tuple_share 
  | Lock_tuple_no_key_exclusive 
  | Lock_tuple_exclusive 

let rec default_expr = ()

let rec default_param_kind () = (Param_kind_undefined:param_kind)

let rec default_agg_split () = (Agg_split_undefined:agg_split)

let rec default_coercion_form () = (Coercion_form_undefined:coercion_form)

let rec default_bool_expr_type () = (Bool_expr_type_undefined:bool_expr_type)

let rec default_sub_link_type () = (Sub_link_type_undefined:sub_link_type)

let rec default_row_compare_type () = (Row_compare_type_undefined:row_compare_type)

let rec default_min_max_op () = (Min_max_op_undefined:min_max_op)

let rec default_sqlvalue_function_op () = (Sqlvalue_function_op_undefined:sqlvalue_function_op)

let rec default_xml_expr_op () = (Xml_expr_op_undefined:xml_expr_op)

let rec default_xml_option_type () = (Xml_option_type_undefined:xml_option_type)

let rec default_null_test_type () = (Null_test_type_undefined:null_test_type)

let rec default_bool_test_type () = (Bool_test_type_undefined:bool_test_type)

let rec default_range_tbl_ref 
  ?rtindex:((rtindex:int32) = 0l)
  () : range_tbl_ref  = {
  rtindex;
}

let rec default_join_type () = (Join_type_undefined:join_type)

let rec default_on_conflict_action () = (On_conflict_action_undefined:on_conflict_action)

let rec default_on_commit_action () = (On_commit_action_undefined:on_commit_action)

let rec default_cmd_type () = (Cmd_type_undefined:cmd_type)

let rec default_query_source () = (Query_source_undefined:query_source)

let rec default_overriding_kind () = (Overriding_kind_undefined:overriding_kind)

let rec default_limit_option () = (Limit_option_undefined:limit_option)

let rec default_set_operation () = (Set_operation_undefined:set_operation)

let rec default_object_type () = (Object_type_undefined:object_type)

let rec default_alter_table_type () = (Alter_table_type_undefined:alter_table_type)

let rec default_role_spec_type () = (Role_spec_type_undefined:role_spec_type)

let rec default_role_spec 
  ?roletype:((roletype:role_spec_type) = default_role_spec_type ())
  ?rolename:((rolename:string) = "")
  ?location:((location:int32) = 0l)
  () : role_spec  = {
  roletype;
  rolename;
  location;
}

let rec default_drop_behavior () = (Drop_behavior_undefined:drop_behavior)

let rec default_grant_target_type () = (Grant_target_type_undefined:grant_target_type)

let rec default_close_portal_stmt 
  ?portalname:((portalname:string) = "")
  () : close_portal_stmt  = {
  portalname;
}

let rec default_fetch_direction () = (Fetch_direction_undefined:fetch_direction)

let rec default_fetch_stmt 
  ?direction:((direction:fetch_direction) = default_fetch_direction ())
  ?how_many:((how_many:int64) = 0L)
  ?portalname:((portalname:string) = "")
  ?ismove:((ismove:bool) = false)
  () : fetch_stmt  = {
  direction;
  how_many;
  portalname;
  ismove;
}

let rec default_notify_stmt 
  ?conditionname:((conditionname:string) = "")
  ?payload:((payload:string) = "")
  () : notify_stmt  = {
  conditionname;
  payload;
}

let rec default_listen_stmt 
  ?conditionname:((conditionname:string) = "")
  () : listen_stmt  = {
  conditionname;
}

let rec default_unlisten_stmt 
  ?conditionname:((conditionname:string) = "")
  () : unlisten_stmt  = {
  conditionname;
}

let rec default_transaction_stmt_kind () = (Transaction_stmt_kind_undefined:transaction_stmt_kind)

let rec default_view_check_option () = (View_check_option_undefined:view_check_option)

let rec default_load_stmt 
  ?filename:((filename:string) = "")
  () : load_stmt  = {
  filename;
}

let rec default_variable_set_kind () = (Variable_set_kind_undefined:variable_set_kind)

let rec default_variable_show_stmt 
  ?name:((name:string) = "")
  () : variable_show_stmt  = {
  name;
}

let rec default_discard_mode () = (Discard_mode_undefined:discard_mode)

let rec default_discard_stmt 
  ?target:((target:discard_mode) = default_discard_mode ())
  () : discard_stmt  = {
  target;
}

let rec default_role_stmt_type () = (Role_stmt_type_undefined:role_stmt_type)

let rec default_reindex_object_type () = (Reindex_object_type_undefined:reindex_object_type)

let rec default_check_point_stmt = ()

let rec default_coercion_context () = (Coercion_context_undefined:coercion_context)

let rec default_deallocate_stmt 
  ?name:((name:string) = "")
  () : deallocate_stmt  = {
  name;
}

let rec default_drop_table_space_stmt 
  ?tablespacename:((tablespacename:string) = "")
  ?missing_ok:((missing_ok:bool) = false)
  () : drop_table_space_stmt  = {
  tablespacename;
  missing_ok;
}

let rec default_alter_tsconfig_type () = (Alter_tsconfig_type_undefined:alter_tsconfig_type)

let rec default_drop_user_mapping_stmt 
  ?user:((user:role_spec option) = None)
  ?servername:((servername:string) = "")
  ?missing_ok:((missing_ok:bool) = false)
  () : drop_user_mapping_stmt  = {
  user;
  servername;
  missing_ok;
}

let rec default_import_foreign_schema_type () = (Import_foreign_schema_type_undefined:import_foreign_schema_type)

let rec default_alter_event_trig_stmt 
  ?trigname:((trigname:string) = "")
  ?tgenabled:((tgenabled:string) = "")
  () : alter_event_trig_stmt  = {
  trigname;
  tgenabled;
}

let rec default_replica_identity_stmt 
  ?identity_type:((identity_type:string) = "")
  ?name:((name:string) = "")
  () : replica_identity_stmt  = {
  identity_type;
  name;
}

let rec default_def_elem_action () = (Def_elem_action_undefined:def_elem_action)

let rec default_alter_subscription_type () = (Alter_subscription_type_undefined:alter_subscription_type)

let rec default_drop_subscription_stmt 
  ?subname:((subname:string) = "")
  ?missing_ok:((missing_ok:bool) = false)
  ?behavior:((behavior:drop_behavior) = default_drop_behavior ())
  () : drop_subscription_stmt  = {
  subname;
  missing_ok;
  behavior;
}

let rec default_a_expr_kind () = (A_expr_kind_undefined:a_expr_kind)

let rec default_param_ref 
  ?number:((number:int32) = 0l)
  ?location:((location:int32) = 0l)
  () : param_ref  = {
  number;
  location;
}

let rec default_a_star = ()

let rec default_sort_by_dir () = (Sort_by_dir_undefined:sort_by_dir)

let rec default_sort_by_nulls () = (Sort_by_nulls_undefined:sort_by_nulls)

let rec default_constr_type () = (Constr_type_undefined:constr_type)

let rec default_rtekind () = (Rtekind_undefined:rtekind)

let rec default_wcokind () = (Wcokind_undefined:wcokind)

let rec default_sort_group_clause 
  ?tle_sort_group_ref:((tle_sort_group_ref:int32) = 0l)
  ?eqop:((eqop:int32) = 0l)
  ?sortop:((sortop:int32) = 0l)
  ?nulls_first:((nulls_first:bool) = false)
  ?hashable:((hashable:bool) = false)
  () : sort_group_clause  = {
  tle_sort_group_ref;
  eqop;
  sortop;
  nulls_first;
  hashable;
}

let rec default_grouping_set_kind () = (Grouping_set_kind_undefined:grouping_set_kind)

let rec default_function_parameter_mode () = (Function_parameter_mode_undefined:function_parameter_mode)

let rec default_lock_clause_strength () = (Lock_clause_strength_undefined:lock_clause_strength)

let rec default_lock_wait_policy () = (Lock_wait_policy_undefined:lock_wait_policy)

let rec default_row_mark_clause 
  ?rti:((rti:int32) = 0l)
  ?strength:((strength:lock_clause_strength) = default_lock_clause_strength ())
  ?wait_policy:((wait_policy:lock_wait_policy) = default_lock_wait_policy ())
  ?pushed_down:((pushed_down:bool) = false)
  () : row_mark_clause  = {
  rti;
  strength;
  wait_policy;
  pushed_down;
}

let rec default_ctematerialize () = (Ctematerialize_undefined:ctematerialize)

let rec default_trigger_transition 
  ?name:((name:string) = "")
  ?is_new:((is_new:bool) = false)
  ?is_table:((is_table:bool) = false)
  () : trigger_transition  = {
  name;
  is_new;
  is_table;
}

let rec default_partition_range_datum_kind () = (Partition_range_datum_kind_undefined:partition_range_datum_kind)

let rec default_inline_code_block 
  ?source_text:((source_text:string) = "")
  ?lang_oid:((lang_oid:int32) = 0l)
  ?lang_is_trusted:((lang_is_trusted:bool) = false)
  ?atomic:((atomic:bool) = false)
  () : inline_code_block  = {
  source_text;
  lang_oid;
  lang_is_trusted;
  atomic;
}

let rec default_call_context 
  ?atomic:((atomic:bool) = false)
  () : call_context  = {
  atomic;
}

let rec default_integer 
  ?ival:((ival:int32) = 0l)
  () : integer  = {
  ival;
}

let rec default_pgfloat 
  ?str:((str:string) = "")
  () : pgfloat  = {
  str;
}

let rec default_pgstring 
  ?str:((str:string) = "")
  () : pgstring  = {
  str;
}

let rec default_bit_string 
  ?str:((str:string) = "")
  () : bit_string  = {
  str;
}

let rec default_null = ()

let rec default_raw_stmt 
  ?stmt:((stmt:node option) = None)
  ?stmt_location:((stmt_location:int32) = 0l)
  ?stmt_len:((stmt_len:int32) = 0l)
  () : raw_stmt  = {
  stmt;
  stmt_location;
  stmt_len;
}

and default_node () : node = Alias (default_alias ())

and default_alias 
  ?aliasname:((aliasname:string) = "")
  ?colnames:((colnames:node list) = [])
  () : alias  = {
  aliasname;
  colnames;
}

and default_range_var 
  ?catalogname:((catalogname:string) = "")
  ?schemaname:((schemaname:string) = "")
  ?relname:((relname:string) = "")
  ?inh:((inh:bool) = false)
  ?relpersistence:((relpersistence:string) = "")
  ?alias:((alias:alias option) = None)
  ?location:((location:int32) = 0l)
  () : range_var  = {
  catalogname;
  schemaname;
  relname;
  inh;
  relpersistence;
  alias;
  location;
}

and default_table_func 
  ?ns_uris:((ns_uris:node list) = [])
  ?ns_names:((ns_names:node list) = [])
  ?docexpr:((docexpr:node option) = None)
  ?rowexpr:((rowexpr:node option) = None)
  ?colnames:((colnames:node list) = [])
  ?coltypes:((coltypes:node list) = [])
  ?coltypmods:((coltypmods:node list) = [])
  ?colcollations:((colcollations:node list) = [])
  ?colexprs:((colexprs:node list) = [])
  ?coldefexprs:((coldefexprs:node list) = [])
  ?notnulls:((notnulls:int64 list) = [])
  ?ordinalitycol:((ordinalitycol:int32) = 0l)
  ?location:((location:int32) = 0l)
  () : table_func  = {
  ns_uris;
  ns_names;
  docexpr;
  rowexpr;
  colnames;
  coltypes;
  coltypmods;
  colcollations;
  colexprs;
  coldefexprs;
  notnulls;
  ordinalitycol;
  location;
}

and default_var 
  ?xpr:((xpr:node option) = None)
  ?varno:((varno:int32) = 0l)
  ?varattno:((varattno:int32) = 0l)
  ?vartype:((vartype:int32) = 0l)
  ?vartypmod:((vartypmod:int32) = 0l)
  ?varcollid:((varcollid:int32) = 0l)
  ?varlevelsup:((varlevelsup:int32) = 0l)
  ?varnosyn:((varnosyn:int32) = 0l)
  ?varattnosyn:((varattnosyn:int32) = 0l)
  ?location:((location:int32) = 0l)
  () : var  = {
  xpr;
  varno;
  varattno;
  vartype;
  vartypmod;
  varcollid;
  varlevelsup;
  varnosyn;
  varattnosyn;
  location;
}

and default_param 
  ?xpr:((xpr:node option) = None)
  ?paramkind:((paramkind:param_kind) = default_param_kind ())
  ?paramid:((paramid:int32) = 0l)
  ?paramtype:((paramtype:int32) = 0l)
  ?paramtypmod:((paramtypmod:int32) = 0l)
  ?paramcollid:((paramcollid:int32) = 0l)
  ?location:((location:int32) = 0l)
  () : param  = {
  xpr;
  paramkind;
  paramid;
  paramtype;
  paramtypmod;
  paramcollid;
  location;
}

and default_aggref 
  ?xpr:((xpr:node option) = None)
  ?aggfnoid:((aggfnoid:int32) = 0l)
  ?aggtype:((aggtype:int32) = 0l)
  ?aggcollid:((aggcollid:int32) = 0l)
  ?inputcollid:((inputcollid:int32) = 0l)
  ?aggtranstype:((aggtranstype:int32) = 0l)
  ?aggargtypes:((aggargtypes:node list) = [])
  ?aggdirectargs:((aggdirectargs:node list) = [])
  ?args:((args:node list) = [])
  ?aggorder:((aggorder:node list) = [])
  ?aggdistinct:((aggdistinct:node list) = [])
  ?aggfilter:((aggfilter:node option) = None)
  ?aggstar:((aggstar:bool) = false)
  ?aggvariadic:((aggvariadic:bool) = false)
  ?aggkind:((aggkind:string) = "")
  ?agglevelsup:((agglevelsup:int32) = 0l)
  ?aggsplit:((aggsplit:agg_split) = default_agg_split ())
  ?location:((location:int32) = 0l)
  () : aggref  = {
  xpr;
  aggfnoid;
  aggtype;
  aggcollid;
  inputcollid;
  aggtranstype;
  aggargtypes;
  aggdirectargs;
  args;
  aggorder;
  aggdistinct;
  aggfilter;
  aggstar;
  aggvariadic;
  aggkind;
  agglevelsup;
  aggsplit;
  location;
}

and default_grouping_func 
  ?xpr:((xpr:node option) = None)
  ?args:((args:node list) = [])
  ?refs:((refs:node list) = [])
  ?cols:((cols:node list) = [])
  ?agglevelsup:((agglevelsup:int32) = 0l)
  ?location:((location:int32) = 0l)
  () : grouping_func  = {
  xpr;
  args;
  refs;
  cols;
  agglevelsup;
  location;
}

and default_window_func 
  ?xpr:((xpr:node option) = None)
  ?winfnoid:((winfnoid:int32) = 0l)
  ?wintype:((wintype:int32) = 0l)
  ?wincollid:((wincollid:int32) = 0l)
  ?inputcollid:((inputcollid:int32) = 0l)
  ?args:((args:node list) = [])
  ?aggfilter:((aggfilter:node option) = None)
  ?winref:((winref:int32) = 0l)
  ?winstar:((winstar:bool) = false)
  ?winagg:((winagg:bool) = false)
  ?location:((location:int32) = 0l)
  () : window_func  = {
  xpr;
  winfnoid;
  wintype;
  wincollid;
  inputcollid;
  args;
  aggfilter;
  winref;
  winstar;
  winagg;
  location;
}

and default_subscripting_ref 
  ?xpr:((xpr:node option) = None)
  ?refcontainertype:((refcontainertype:int32) = 0l)
  ?refelemtype:((refelemtype:int32) = 0l)
  ?reftypmod:((reftypmod:int32) = 0l)
  ?refcollid:((refcollid:int32) = 0l)
  ?refupperindexpr:((refupperindexpr:node list) = [])
  ?reflowerindexpr:((reflowerindexpr:node list) = [])
  ?refexpr:((refexpr:node option) = None)
  ?refassgnexpr:((refassgnexpr:node option) = None)
  () : subscripting_ref  = {
  xpr;
  refcontainertype;
  refelemtype;
  reftypmod;
  refcollid;
  refupperindexpr;
  reflowerindexpr;
  refexpr;
  refassgnexpr;
}

and default_func_expr 
  ?xpr:((xpr:node option) = None)
  ?funcid:((funcid:int32) = 0l)
  ?funcresulttype:((funcresulttype:int32) = 0l)
  ?funcretset:((funcretset:bool) = false)
  ?funcvariadic:((funcvariadic:bool) = false)
  ?funcformat:((funcformat:coercion_form) = default_coercion_form ())
  ?funccollid:((funccollid:int32) = 0l)
  ?inputcollid:((inputcollid:int32) = 0l)
  ?args:((args:node list) = [])
  ?location:((location:int32) = 0l)
  () : func_expr  = {
  xpr;
  funcid;
  funcresulttype;
  funcretset;
  funcvariadic;
  funcformat;
  funccollid;
  inputcollid;
  args;
  location;
}

and default_named_arg_expr 
  ?xpr:((xpr:node option) = None)
  ?arg:((arg:node option) = None)
  ?name:((name:string) = "")
  ?argnumber:((argnumber:int32) = 0l)
  ?location:((location:int32) = 0l)
  () : named_arg_expr  = {
  xpr;
  arg;
  name;
  argnumber;
  location;
}

and default_op_expr 
  ?xpr:((xpr:node option) = None)
  ?opno:((opno:int32) = 0l)
  ?opfuncid:((opfuncid:int32) = 0l)
  ?opresulttype:((opresulttype:int32) = 0l)
  ?opretset:((opretset:bool) = false)
  ?opcollid:((opcollid:int32) = 0l)
  ?inputcollid:((inputcollid:int32) = 0l)
  ?args:((args:node list) = [])
  ?location:((location:int32) = 0l)
  () : op_expr  = {
  xpr;
  opno;
  opfuncid;
  opresulttype;
  opretset;
  opcollid;
  inputcollid;
  args;
  location;
}

and default_distinct_expr 
  ?xpr:((xpr:node option) = None)
  ?opno:((opno:int32) = 0l)
  ?opfuncid:((opfuncid:int32) = 0l)
  ?opresulttype:((opresulttype:int32) = 0l)
  ?opretset:((opretset:bool) = false)
  ?opcollid:((opcollid:int32) = 0l)
  ?inputcollid:((inputcollid:int32) = 0l)
  ?args:((args:node list) = [])
  ?location:((location:int32) = 0l)
  () : distinct_expr  = {
  xpr;
  opno;
  opfuncid;
  opresulttype;
  opretset;
  opcollid;
  inputcollid;
  args;
  location;
}

and default_null_if_expr 
  ?xpr:((xpr:node option) = None)
  ?opno:((opno:int32) = 0l)
  ?opfuncid:((opfuncid:int32) = 0l)
  ?opresulttype:((opresulttype:int32) = 0l)
  ?opretset:((opretset:bool) = false)
  ?opcollid:((opcollid:int32) = 0l)
  ?inputcollid:((inputcollid:int32) = 0l)
  ?args:((args:node list) = [])
  ?location:((location:int32) = 0l)
  () : null_if_expr  = {
  xpr;
  opno;
  opfuncid;
  opresulttype;
  opretset;
  opcollid;
  inputcollid;
  args;
  location;
}

and default_scalar_array_op_expr 
  ?xpr:((xpr:node option) = None)
  ?opno:((opno:int32) = 0l)
  ?opfuncid:((opfuncid:int32) = 0l)
  ?use_or:((use_or:bool) = false)
  ?inputcollid:((inputcollid:int32) = 0l)
  ?args:((args:node list) = [])
  ?location:((location:int32) = 0l)
  () : scalar_array_op_expr  = {
  xpr;
  opno;
  opfuncid;
  use_or;
  inputcollid;
  args;
  location;
}

and default_bool_expr 
  ?xpr:((xpr:node option) = None)
  ?boolop:((boolop:bool_expr_type) = default_bool_expr_type ())
  ?args:((args:node list) = [])
  ?location:((location:int32) = 0l)
  () : bool_expr  = {
  xpr;
  boolop;
  args;
  location;
}

and default_sub_link 
  ?xpr:((xpr:node option) = None)
  ?sub_link_type:((sub_link_type:sub_link_type) = default_sub_link_type ())
  ?sub_link_id:((sub_link_id:int32) = 0l)
  ?testexpr:((testexpr:node option) = None)
  ?oper_name:((oper_name:node list) = [])
  ?subselect:((subselect:node option) = None)
  ?location:((location:int32) = 0l)
  () : sub_link  = {
  xpr;
  sub_link_type;
  sub_link_id;
  testexpr;
  oper_name;
  subselect;
  location;
}

and default_sub_plan 
  ?xpr:((xpr:node option) = None)
  ?sub_link_type:((sub_link_type:sub_link_type) = default_sub_link_type ())
  ?testexpr:((testexpr:node option) = None)
  ?param_ids:((param_ids:node list) = [])
  ?plan_id:((plan_id:int32) = 0l)
  ?plan_name:((plan_name:string) = "")
  ?first_col_type:((first_col_type:int32) = 0l)
  ?first_col_typmod:((first_col_typmod:int32) = 0l)
  ?first_col_collation:((first_col_collation:int32) = 0l)
  ?use_hash_table:((use_hash_table:bool) = false)
  ?unknown_eq_false:((unknown_eq_false:bool) = false)
  ?parallel_safe:((parallel_safe:bool) = false)
  ?set_param:((set_param:node list) = [])
  ?par_param:((par_param:node list) = [])
  ?args:((args:node list) = [])
  ?startup_cost:((startup_cost:float) = 0.)
  ?per_call_cost:((per_call_cost:float) = 0.)
  () : sub_plan  = {
  xpr;
  sub_link_type;
  testexpr;
  param_ids;
  plan_id;
  plan_name;
  first_col_type;
  first_col_typmod;
  first_col_collation;
  use_hash_table;
  unknown_eq_false;
  parallel_safe;
  set_param;
  par_param;
  args;
  startup_cost;
  per_call_cost;
}

and default_alternative_sub_plan 
  ?xpr:((xpr:node option) = None)
  ?subplans:((subplans:node list) = [])
  () : alternative_sub_plan  = {
  xpr;
  subplans;
}

and default_field_select 
  ?xpr:((xpr:node option) = None)
  ?arg:((arg:node option) = None)
  ?fieldnum:((fieldnum:int32) = 0l)
  ?resulttype:((resulttype:int32) = 0l)
  ?resulttypmod:((resulttypmod:int32) = 0l)
  ?resultcollid:((resultcollid:int32) = 0l)
  () : field_select  = {
  xpr;
  arg;
  fieldnum;
  resulttype;
  resulttypmod;
  resultcollid;
}

and default_field_store 
  ?xpr:((xpr:node option) = None)
  ?arg:((arg:node option) = None)
  ?newvals:((newvals:node list) = [])
  ?fieldnums:((fieldnums:node list) = [])
  ?resulttype:((resulttype:int32) = 0l)
  () : field_store  = {
  xpr;
  arg;
  newvals;
  fieldnums;
  resulttype;
}

and default_relabel_type 
  ?xpr:((xpr:node option) = None)
  ?arg:((arg:node option) = None)
  ?resulttype:((resulttype:int32) = 0l)
  ?resulttypmod:((resulttypmod:int32) = 0l)
  ?resultcollid:((resultcollid:int32) = 0l)
  ?relabelformat:((relabelformat:coercion_form) = default_coercion_form ())
  ?location:((location:int32) = 0l)
  () : relabel_type  = {
  xpr;
  arg;
  resulttype;
  resulttypmod;
  resultcollid;
  relabelformat;
  location;
}

and default_coerce_via_io 
  ?xpr:((xpr:node option) = None)
  ?arg:((arg:node option) = None)
  ?resulttype:((resulttype:int32) = 0l)
  ?resultcollid:((resultcollid:int32) = 0l)
  ?coerceformat:((coerceformat:coercion_form) = default_coercion_form ())
  ?location:((location:int32) = 0l)
  () : coerce_via_io  = {
  xpr;
  arg;
  resulttype;
  resultcollid;
  coerceformat;
  location;
}

and default_array_coerce_expr 
  ?xpr:((xpr:node option) = None)
  ?arg:((arg:node option) = None)
  ?elemexpr:((elemexpr:node option) = None)
  ?resulttype:((resulttype:int32) = 0l)
  ?resulttypmod:((resulttypmod:int32) = 0l)
  ?resultcollid:((resultcollid:int32) = 0l)
  ?coerceformat:((coerceformat:coercion_form) = default_coercion_form ())
  ?location:((location:int32) = 0l)
  () : array_coerce_expr  = {
  xpr;
  arg;
  elemexpr;
  resulttype;
  resulttypmod;
  resultcollid;
  coerceformat;
  location;
}

and default_convert_rowtype_expr 
  ?xpr:((xpr:node option) = None)
  ?arg:((arg:node option) = None)
  ?resulttype:((resulttype:int32) = 0l)
  ?convertformat:((convertformat:coercion_form) = default_coercion_form ())
  ?location:((location:int32) = 0l)
  () : convert_rowtype_expr  = {
  xpr;
  arg;
  resulttype;
  convertformat;
  location;
}

and default_collate_expr 
  ?xpr:((xpr:node option) = None)
  ?arg:((arg:node option) = None)
  ?coll_oid:((coll_oid:int32) = 0l)
  ?location:((location:int32) = 0l)
  () : collate_expr  = {
  xpr;
  arg;
  coll_oid;
  location;
}

and default_case_expr 
  ?xpr:((xpr:node option) = None)
  ?casetype:((casetype:int32) = 0l)
  ?casecollid:((casecollid:int32) = 0l)
  ?arg:((arg:node option) = None)
  ?args:((args:node list) = [])
  ?defresult:((defresult:node option) = None)
  ?location:((location:int32) = 0l)
  () : case_expr  = {
  xpr;
  casetype;
  casecollid;
  arg;
  args;
  defresult;
  location;
}

and default_case_when 
  ?xpr:((xpr:node option) = None)
  ?expr:((expr:node option) = None)
  ?result:((result:node option) = None)
  ?location:((location:int32) = 0l)
  () : case_when  = {
  xpr;
  expr;
  result;
  location;
}

and default_case_test_expr 
  ?xpr:((xpr:node option) = None)
  ?type_id:((type_id:int32) = 0l)
  ?type_mod:((type_mod:int32) = 0l)
  ?collation:((collation:int32) = 0l)
  () : case_test_expr  = {
  xpr;
  type_id;
  type_mod;
  collation;
}

and default_array_expr 
  ?xpr:((xpr:node option) = None)
  ?array_typeid:((array_typeid:int32) = 0l)
  ?array_collid:((array_collid:int32) = 0l)
  ?element_typeid:((element_typeid:int32) = 0l)
  ?elements:((elements:node list) = [])
  ?multidims:((multidims:bool) = false)
  ?location:((location:int32) = 0l)
  () : array_expr  = {
  xpr;
  array_typeid;
  array_collid;
  element_typeid;
  elements;
  multidims;
  location;
}

and default_row_expr 
  ?xpr:((xpr:node option) = None)
  ?args:((args:node list) = [])
  ?row_typeid:((row_typeid:int32) = 0l)
  ?row_format:((row_format:coercion_form) = default_coercion_form ())
  ?colnames:((colnames:node list) = [])
  ?location:((location:int32) = 0l)
  () : row_expr  = {
  xpr;
  args;
  row_typeid;
  row_format;
  colnames;
  location;
}

and default_row_compare_expr 
  ?xpr:((xpr:node option) = None)
  ?rctype:((rctype:row_compare_type) = default_row_compare_type ())
  ?opnos:((opnos:node list) = [])
  ?opfamilies:((opfamilies:node list) = [])
  ?inputcollids:((inputcollids:node list) = [])
  ?largs:((largs:node list) = [])
  ?rargs:((rargs:node list) = [])
  () : row_compare_expr  = {
  xpr;
  rctype;
  opnos;
  opfamilies;
  inputcollids;
  largs;
  rargs;
}

and default_coalesce_expr 
  ?xpr:((xpr:node option) = None)
  ?coalescetype:((coalescetype:int32) = 0l)
  ?coalescecollid:((coalescecollid:int32) = 0l)
  ?args:((args:node list) = [])
  ?location:((location:int32) = 0l)
  () : coalesce_expr  = {
  xpr;
  coalescetype;
  coalescecollid;
  args;
  location;
}

and default_min_max_expr 
  ?xpr:((xpr:node option) = None)
  ?minmaxtype:((minmaxtype:int32) = 0l)
  ?minmaxcollid:((minmaxcollid:int32) = 0l)
  ?inputcollid:((inputcollid:int32) = 0l)
  ?op:((op:min_max_op) = default_min_max_op ())
  ?args:((args:node list) = [])
  ?location:((location:int32) = 0l)
  () : min_max_expr  = {
  xpr;
  minmaxtype;
  minmaxcollid;
  inputcollid;
  op;
  args;
  location;
}

and default_sqlvalue_function 
  ?xpr:((xpr:node option) = None)
  ?op:((op:sqlvalue_function_op) = default_sqlvalue_function_op ())
  ?type_:((type_:int32) = 0l)
  ?typmod:((typmod:int32) = 0l)
  ?location:((location:int32) = 0l)
  () : sqlvalue_function  = {
  xpr;
  op;
  type_;
  typmod;
  location;
}

and default_xml_expr 
  ?xpr:((xpr:node option) = None)
  ?op:((op:xml_expr_op) = default_xml_expr_op ())
  ?name:((name:string) = "")
  ?named_args:((named_args:node list) = [])
  ?arg_names:((arg_names:node list) = [])
  ?args:((args:node list) = [])
  ?xmloption:((xmloption:xml_option_type) = default_xml_option_type ())
  ?type_:((type_:int32) = 0l)
  ?typmod:((typmod:int32) = 0l)
  ?location:((location:int32) = 0l)
  () : xml_expr  = {
  xpr;
  op;
  name;
  named_args;
  arg_names;
  args;
  xmloption;
  type_;
  typmod;
  location;
}

and default_null_test 
  ?xpr:((xpr:node option) = None)
  ?arg:((arg:node option) = None)
  ?nulltesttype:((nulltesttype:null_test_type) = default_null_test_type ())
  ?argisrow:((argisrow:bool) = false)
  ?location:((location:int32) = 0l)
  () : null_test  = {
  xpr;
  arg;
  nulltesttype;
  argisrow;
  location;
}

and default_boolean_test 
  ?xpr:((xpr:node option) = None)
  ?arg:((arg:node option) = None)
  ?booltesttype:((booltesttype:bool_test_type) = default_bool_test_type ())
  ?location:((location:int32) = 0l)
  () : boolean_test  = {
  xpr;
  arg;
  booltesttype;
  location;
}

and default_coerce_to_domain 
  ?xpr:((xpr:node option) = None)
  ?arg:((arg:node option) = None)
  ?resulttype:((resulttype:int32) = 0l)
  ?resulttypmod:((resulttypmod:int32) = 0l)
  ?resultcollid:((resultcollid:int32) = 0l)
  ?coercionformat:((coercionformat:coercion_form) = default_coercion_form ())
  ?location:((location:int32) = 0l)
  () : coerce_to_domain  = {
  xpr;
  arg;
  resulttype;
  resulttypmod;
  resultcollid;
  coercionformat;
  location;
}

and default_coerce_to_domain_value 
  ?xpr:((xpr:node option) = None)
  ?type_id:((type_id:int32) = 0l)
  ?type_mod:((type_mod:int32) = 0l)
  ?collation:((collation:int32) = 0l)
  ?location:((location:int32) = 0l)
  () : coerce_to_domain_value  = {
  xpr;
  type_id;
  type_mod;
  collation;
  location;
}

and default_set_to_default 
  ?xpr:((xpr:node option) = None)
  ?type_id:((type_id:int32) = 0l)
  ?type_mod:((type_mod:int32) = 0l)
  ?collation:((collation:int32) = 0l)
  ?location:((location:int32) = 0l)
  () : set_to_default  = {
  xpr;
  type_id;
  type_mod;
  collation;
  location;
}

and default_current_of_expr 
  ?xpr:((xpr:node option) = None)
  ?cvarno:((cvarno:int32) = 0l)
  ?cursor_name:((cursor_name:string) = "")
  ?cursor_param:((cursor_param:int32) = 0l)
  () : current_of_expr  = {
  xpr;
  cvarno;
  cursor_name;
  cursor_param;
}

and default_next_value_expr 
  ?xpr:((xpr:node option) = None)
  ?seqid:((seqid:int32) = 0l)
  ?type_id:((type_id:int32) = 0l)
  () : next_value_expr  = {
  xpr;
  seqid;
  type_id;
}

and default_inference_elem 
  ?xpr:((xpr:node option) = None)
  ?expr:((expr:node option) = None)
  ?infercollid:((infercollid:int32) = 0l)
  ?inferopclass:((inferopclass:int32) = 0l)
  () : inference_elem  = {
  xpr;
  expr;
  infercollid;
  inferopclass;
}

and default_target_entry 
  ?xpr:((xpr:node option) = None)
  ?expr:((expr:node option) = None)
  ?resno:((resno:int32) = 0l)
  ?resname:((resname:string) = "")
  ?ressortgroupref:((ressortgroupref:int32) = 0l)
  ?resorigtbl:((resorigtbl:int32) = 0l)
  ?resorigcol:((resorigcol:int32) = 0l)
  ?resjunk:((resjunk:bool) = false)
  () : target_entry  = {
  xpr;
  expr;
  resno;
  resname;
  ressortgroupref;
  resorigtbl;
  resorigcol;
  resjunk;
}

and default_join_expr 
  ?jointype:((jointype:join_type) = default_join_type ())
  ?is_natural:((is_natural:bool) = false)
  ?larg:((larg:node option) = None)
  ?rarg:((rarg:node option) = None)
  ?using_clause:((using_clause:node list) = [])
  ?quals:((quals:node option) = None)
  ?alias:((alias:alias option) = None)
  ?rtindex:((rtindex:int32) = 0l)
  () : join_expr  = {
  jointype;
  is_natural;
  larg;
  rarg;
  using_clause;
  quals;
  alias;
  rtindex;
}

and default_from_expr 
  ?fromlist:((fromlist:node list) = [])
  ?quals:((quals:node option) = None)
  () : from_expr  = {
  fromlist;
  quals;
}

and default_on_conflict_expr 
  ?action:((action:on_conflict_action) = default_on_conflict_action ())
  ?arbiter_elems:((arbiter_elems:node list) = [])
  ?arbiter_where:((arbiter_where:node option) = None)
  ?constraint_:((constraint_:int32) = 0l)
  ?on_conflict_set:((on_conflict_set:node list) = [])
  ?on_conflict_where:((on_conflict_where:node option) = None)
  ?excl_rel_index:((excl_rel_index:int32) = 0l)
  ?excl_rel_tlist:((excl_rel_tlist:node list) = [])
  () : on_conflict_expr  = {
  action;
  arbiter_elems;
  arbiter_where;
  constraint_;
  on_conflict_set;
  on_conflict_where;
  excl_rel_index;
  excl_rel_tlist;
}

and default_into_clause 
  ?rel:((rel:range_var option) = None)
  ?col_names:((col_names:node list) = [])
  ?access_method:((access_method:string) = "")
  ?options:((options:node list) = [])
  ?on_commit:((on_commit:on_commit_action) = default_on_commit_action ())
  ?table_space_name:((table_space_name:string) = "")
  ?view_query:((view_query:node option) = None)
  ?skip_data:((skip_data:bool) = false)
  () : into_clause  = {
  rel;
  col_names;
  access_method;
  options;
  on_commit;
  table_space_name;
  view_query;
  skip_data;
}

and default_query 
  ?command_type:((command_type:cmd_type) = default_cmd_type ())
  ?query_source:((query_source:query_source) = default_query_source ())
  ?can_set_tag:((can_set_tag:bool) = false)
  ?utility_stmt:((utility_stmt:node option) = None)
  ?result_relation:((result_relation:int32) = 0l)
  ?has_aggs:((has_aggs:bool) = false)
  ?has_window_funcs:((has_window_funcs:bool) = false)
  ?has_target_srfs:((has_target_srfs:bool) = false)
  ?has_sub_links:((has_sub_links:bool) = false)
  ?has_distinct_on:((has_distinct_on:bool) = false)
  ?has_recursive:((has_recursive:bool) = false)
  ?has_modifying_cte:((has_modifying_cte:bool) = false)
  ?has_for_update:((has_for_update:bool) = false)
  ?has_row_security:((has_row_security:bool) = false)
  ?cte_list:((cte_list:node list) = [])
  ?rtable:((rtable:node list) = [])
  ?jointree:((jointree:from_expr option) = None)
  ?target_list:((target_list:node list) = [])
  ?override:((override:overriding_kind) = default_overriding_kind ())
  ?on_conflict:((on_conflict:on_conflict_expr option) = None)
  ?returning_list:((returning_list:node list) = [])
  ?group_clause:((group_clause:node list) = [])
  ?grouping_sets:((grouping_sets:node list) = [])
  ?having_qual:((having_qual:node option) = None)
  ?window_clause:((window_clause:node list) = [])
  ?distinct_clause:((distinct_clause:node list) = [])
  ?sort_clause:((sort_clause:node list) = [])
  ?limit_offset:((limit_offset:node option) = None)
  ?limit_count:((limit_count:node option) = None)
  ?limit_option:((limit_option:limit_option) = default_limit_option ())
  ?row_marks:((row_marks:node list) = [])
  ?set_operations:((set_operations:node option) = None)
  ?constraint_deps:((constraint_deps:node list) = [])
  ?with_check_options:((with_check_options:node list) = [])
  ?stmt_location:((stmt_location:int32) = 0l)
  ?stmt_len:((stmt_len:int32) = 0l)
  () : query  = {
  command_type;
  query_source;
  can_set_tag;
  utility_stmt;
  result_relation;
  has_aggs;
  has_window_funcs;
  has_target_srfs;
  has_sub_links;
  has_distinct_on;
  has_recursive;
  has_modifying_cte;
  has_for_update;
  has_row_security;
  cte_list;
  rtable;
  jointree;
  target_list;
  override;
  on_conflict;
  returning_list;
  group_clause;
  grouping_sets;
  having_qual;
  window_clause;
  distinct_clause;
  sort_clause;
  limit_offset;
  limit_count;
  limit_option;
  row_marks;
  set_operations;
  constraint_deps;
  with_check_options;
  stmt_location;
  stmt_len;
}

and default_insert_stmt 
  ?relation:((relation:range_var option) = None)
  ?cols:((cols:node list) = [])
  ?select_stmt:((select_stmt:node option) = None)
  ?on_conflict_clause:((on_conflict_clause:on_conflict_clause option) = None)
  ?returning_list:((returning_list:node list) = [])
  ?with_clause:((with_clause:with_clause option) = None)
  ?override:((override:overriding_kind) = default_overriding_kind ())
  () : insert_stmt  = {
  relation;
  cols;
  select_stmt;
  on_conflict_clause;
  returning_list;
  with_clause;
  override;
}

and default_on_conflict_clause 
  ?action:((action:on_conflict_action) = default_on_conflict_action ())
  ?infer:((infer:infer_clause option) = None)
  ?target_list:((target_list:node list) = [])
  ?where_clause:((where_clause:node option) = None)
  ?location:((location:int32) = 0l)
  () : on_conflict_clause  = {
  action;
  infer;
  target_list;
  where_clause;
  location;
}

and default_infer_clause 
  ?index_elems:((index_elems:node list) = [])
  ?where_clause:((where_clause:node option) = None)
  ?conname:((conname:string) = "")
  ?location:((location:int32) = 0l)
  () : infer_clause  = {
  index_elems;
  where_clause;
  conname;
  location;
}

and default_with_clause 
  ?ctes:((ctes:node list) = [])
  ?recursive:((recursive:bool) = false)
  ?location:((location:int32) = 0l)
  () : with_clause  = {
  ctes;
  recursive;
  location;
}

and default_delete_stmt 
  ?relation:((relation:range_var option) = None)
  ?using_clause:((using_clause:node list) = [])
  ?where_clause:((where_clause:node option) = None)
  ?returning_list:((returning_list:node list) = [])
  ?with_clause:((with_clause:with_clause option) = None)
  () : delete_stmt  = {
  relation;
  using_clause;
  where_clause;
  returning_list;
  with_clause;
}

and default_update_stmt 
  ?relation:((relation:range_var option) = None)
  ?target_list:((target_list:node list) = [])
  ?where_clause:((where_clause:node option) = None)
  ?from_clause:((from_clause:node list) = [])
  ?returning_list:((returning_list:node list) = [])
  ?with_clause:((with_clause:with_clause option) = None)
  () : update_stmt  = {
  relation;
  target_list;
  where_clause;
  from_clause;
  returning_list;
  with_clause;
}

and default_select_stmt 
  ?distinct_clause:((distinct_clause:node list) = [])
  ?into_clause:((into_clause:into_clause option) = None)
  ?target_list:((target_list:node list) = [])
  ?from_clause:((from_clause:node list) = [])
  ?where_clause:((where_clause:node option) = None)
  ?group_clause:((group_clause:node list) = [])
  ?having_clause:((having_clause:node option) = None)
  ?window_clause:((window_clause:node list) = [])
  ?values_lists:((values_lists:node list) = [])
  ?sort_clause:((sort_clause:node list) = [])
  ?limit_offset:((limit_offset:node option) = None)
  ?limit_count:((limit_count:node option) = None)
  ?limit_option:((limit_option:limit_option) = default_limit_option ())
  ?locking_clause:((locking_clause:node list) = [])
  ?with_clause:((with_clause:with_clause option) = None)
  ?op:((op:set_operation) = default_set_operation ())
  ?all:((all:bool) = false)
  ?larg:((larg:select_stmt option) = None)
  ?rarg:((rarg:select_stmt option) = None)
  () : select_stmt  = {
  distinct_clause;
  into_clause;
  target_list;
  from_clause;
  where_clause;
  group_clause;
  having_clause;
  window_clause;
  values_lists;
  sort_clause;
  limit_offset;
  limit_count;
  limit_option;
  locking_clause;
  with_clause;
  op;
  all;
  larg;
  rarg;
}

and default_alter_table_stmt 
  ?relation:((relation:range_var option) = None)
  ?cmds:((cmds:node list) = [])
  ?relkind:((relkind:object_type) = default_object_type ())
  ?missing_ok:((missing_ok:bool) = false)
  () : alter_table_stmt  = {
  relation;
  cmds;
  relkind;
  missing_ok;
}

and default_alter_table_cmd 
  ?subtype:((subtype:alter_table_type) = default_alter_table_type ())
  ?name:((name:string) = "")
  ?num:((num:int32) = 0l)
  ?newowner:((newowner:role_spec option) = None)
  ?def:((def:node option) = None)
  ?behavior:((behavior:drop_behavior) = default_drop_behavior ())
  ?missing_ok:((missing_ok:bool) = false)
  ?recurse:((recurse:bool) = false)
  () : alter_table_cmd  = {
  subtype;
  name;
  num;
  newowner;
  def;
  behavior;
  missing_ok;
  recurse;
}

and default_alter_domain_stmt 
  ?subtype:((subtype:string) = "")
  ?type_name:((type_name:node list) = [])
  ?name:((name:string) = "")
  ?def:((def:node option) = None)
  ?behavior:((behavior:drop_behavior) = default_drop_behavior ())
  ?missing_ok:((missing_ok:bool) = false)
  () : alter_domain_stmt  = {
  subtype;
  type_name;
  name;
  def;
  behavior;
  missing_ok;
}

and default_set_operation_stmt 
  ?op:((op:set_operation) = default_set_operation ())
  ?all:((all:bool) = false)
  ?larg:((larg:node option) = None)
  ?rarg:((rarg:node option) = None)
  ?col_types:((col_types:node list) = [])
  ?col_typmods:((col_typmods:node list) = [])
  ?col_collations:((col_collations:node list) = [])
  ?group_clauses:((group_clauses:node list) = [])
  () : set_operation_stmt  = {
  op;
  all;
  larg;
  rarg;
  col_types;
  col_typmods;
  col_collations;
  group_clauses;
}

and default_grant_stmt 
  ?is_grant:((is_grant:bool) = false)
  ?targtype:((targtype:grant_target_type) = default_grant_target_type ())
  ?objtype:((objtype:object_type) = default_object_type ())
  ?objects:((objects:node list) = [])
  ?privileges:((privileges:node list) = [])
  ?grantees:((grantees:node list) = [])
  ?grant_option:((grant_option:bool) = false)
  ?behavior:((behavior:drop_behavior) = default_drop_behavior ())
  () : grant_stmt  = {
  is_grant;
  targtype;
  objtype;
  objects;
  privileges;
  grantees;
  grant_option;
  behavior;
}

and default_grant_role_stmt 
  ?granted_roles:((granted_roles:node list) = [])
  ?grantee_roles:((grantee_roles:node list) = [])
  ?is_grant:((is_grant:bool) = false)
  ?admin_opt:((admin_opt:bool) = false)
  ?grantor:((grantor:role_spec option) = None)
  ?behavior:((behavior:drop_behavior) = default_drop_behavior ())
  () : grant_role_stmt  = {
  granted_roles;
  grantee_roles;
  is_grant;
  admin_opt;
  grantor;
  behavior;
}

and default_alter_default_privileges_stmt 
  ?options:((options:node list) = [])
  ?action:((action:grant_stmt option) = None)
  () : alter_default_privileges_stmt  = {
  options;
  action;
}

and default_cluster_stmt 
  ?relation:((relation:range_var option) = None)
  ?indexname:((indexname:string) = "")
  ?options:((options:int32) = 0l)
  () : cluster_stmt  = {
  relation;
  indexname;
  options;
}

and default_copy_stmt 
  ?relation:((relation:range_var option) = None)
  ?query:((query:node option) = None)
  ?attlist:((attlist:node list) = [])
  ?is_from:((is_from:bool) = false)
  ?is_program:((is_program:bool) = false)
  ?filename:((filename:string) = "")
  ?options:((options:node list) = [])
  ?where_clause:((where_clause:node option) = None)
  () : copy_stmt  = {
  relation;
  query;
  attlist;
  is_from;
  is_program;
  filename;
  options;
  where_clause;
}

and default_create_stmt 
  ?relation:((relation:range_var option) = None)
  ?table_elts:((table_elts:node list) = [])
  ?inh_relations:((inh_relations:node list) = [])
  ?partbound:((partbound:partition_bound_spec option) = None)
  ?partspec:((partspec:partition_spec option) = None)
  ?of_typename:((of_typename:type_name option) = None)
  ?constraints:((constraints:node list) = [])
  ?options:((options:node list) = [])
  ?oncommit:((oncommit:on_commit_action) = default_on_commit_action ())
  ?tablespacename:((tablespacename:string) = "")
  ?access_method:((access_method:string) = "")
  ?if_not_exists:((if_not_exists:bool) = false)
  () : create_stmt  = {
  relation;
  table_elts;
  inh_relations;
  partbound;
  partspec;
  of_typename;
  constraints;
  options;
  oncommit;
  tablespacename;
  access_method;
  if_not_exists;
}

and default_partition_bound_spec 
  ?strategy:((strategy:string) = "")
  ?is_default:((is_default:bool) = false)
  ?modulus:((modulus:int32) = 0l)
  ?remainder:((remainder:int32) = 0l)
  ?listdatums:((listdatums:node list) = [])
  ?lowerdatums:((lowerdatums:node list) = [])
  ?upperdatums:((upperdatums:node list) = [])
  ?location:((location:int32) = 0l)
  () : partition_bound_spec  = {
  strategy;
  is_default;
  modulus;
  remainder;
  listdatums;
  lowerdatums;
  upperdatums;
  location;
}

and default_partition_spec 
  ?strategy:((strategy:string) = "")
  ?part_params:((part_params:node list) = [])
  ?location:((location:int32) = 0l)
  () : partition_spec  = {
  strategy;
  part_params;
  location;
}

and default_type_name 
  ?names:((names:node list) = [])
  ?type_oid:((type_oid:int32) = 0l)
  ?setof:((setof:bool) = false)
  ?pct_type:((pct_type:bool) = false)
  ?typmods:((typmods:node list) = [])
  ?typemod:((typemod:int32) = 0l)
  ?array_bounds:((array_bounds:node list) = [])
  ?location:((location:int32) = 0l)
  () : type_name  = {
  names;
  type_oid;
  setof;
  pct_type;
  typmods;
  typemod;
  array_bounds;
  location;
}

and default_define_stmt 
  ?kind:((kind:object_type) = default_object_type ())
  ?oldstyle:((oldstyle:bool) = false)
  ?defnames:((defnames:node list) = [])
  ?args:((args:node list) = [])
  ?definition:((definition:node list) = [])
  ?if_not_exists:((if_not_exists:bool) = false)
  ?replace:((replace:bool) = false)
  () : define_stmt  = {
  kind;
  oldstyle;
  defnames;
  args;
  definition;
  if_not_exists;
  replace;
}

and default_drop_stmt 
  ?objects:((objects:node list) = [])
  ?remove_type:((remove_type:object_type) = default_object_type ())
  ?behavior:((behavior:drop_behavior) = default_drop_behavior ())
  ?missing_ok:((missing_ok:bool) = false)
  ?concurrent:((concurrent:bool) = false)
  () : drop_stmt  = {
  objects;
  remove_type;
  behavior;
  missing_ok;
  concurrent;
}

and default_truncate_stmt 
  ?relations:((relations:node list) = [])
  ?restart_seqs:((restart_seqs:bool) = false)
  ?behavior:((behavior:drop_behavior) = default_drop_behavior ())
  () : truncate_stmt  = {
  relations;
  restart_seqs;
  behavior;
}

and default_comment_stmt 
  ?objtype:((objtype:object_type) = default_object_type ())
  ?object_:((object_:node option) = None)
  ?comment:((comment:string) = "")
  () : comment_stmt  = {
  objtype;
  object_;
  comment;
}

and default_index_stmt 
  ?idxname:((idxname:string) = "")
  ?relation:((relation:range_var option) = None)
  ?access_method:((access_method:string) = "")
  ?table_space:((table_space:string) = "")
  ?index_params:((index_params:node list) = [])
  ?index_including_params:((index_including_params:node list) = [])
  ?options:((options:node list) = [])
  ?where_clause:((where_clause:node option) = None)
  ?exclude_op_names:((exclude_op_names:node list) = [])
  ?idxcomment:((idxcomment:string) = "")
  ?index_oid:((index_oid:int32) = 0l)
  ?old_node:((old_node:int32) = 0l)
  ?old_create_subid:((old_create_subid:int32) = 0l)
  ?old_first_relfilenode_subid:((old_first_relfilenode_subid:int32) = 0l)
  ?unique:((unique:bool) = false)
  ?primary:((primary:bool) = false)
  ?isconstraint:((isconstraint:bool) = false)
  ?deferrable:((deferrable:bool) = false)
  ?initdeferred:((initdeferred:bool) = false)
  ?transformed:((transformed:bool) = false)
  ?concurrent:((concurrent:bool) = false)
  ?if_not_exists:((if_not_exists:bool) = false)
  ?reset_default_tblspc:((reset_default_tblspc:bool) = false)
  () : index_stmt  = {
  idxname;
  relation;
  access_method;
  table_space;
  index_params;
  index_including_params;
  options;
  where_clause;
  exclude_op_names;
  idxcomment;
  index_oid;
  old_node;
  old_create_subid;
  old_first_relfilenode_subid;
  unique;
  primary;
  isconstraint;
  deferrable;
  initdeferred;
  transformed;
  concurrent;
  if_not_exists;
  reset_default_tblspc;
}

and default_create_function_stmt 
  ?is_procedure:((is_procedure:bool) = false)
  ?replace:((replace:bool) = false)
  ?funcname:((funcname:node list) = [])
  ?parameters:((parameters:node list) = [])
  ?return_type:((return_type:type_name option) = None)
  ?options:((options:node list) = [])
  () : create_function_stmt  = {
  is_procedure;
  replace;
  funcname;
  parameters;
  return_type;
  options;
}

and default_alter_function_stmt 
  ?objtype:((objtype:object_type) = default_object_type ())
  ?func:((func:object_with_args option) = None)
  ?actions:((actions:node list) = [])
  () : alter_function_stmt  = {
  objtype;
  func;
  actions;
}

and default_object_with_args 
  ?objname:((objname:node list) = [])
  ?objargs:((objargs:node list) = [])
  ?args_unspecified:((args_unspecified:bool) = false)
  () : object_with_args  = {
  objname;
  objargs;
  args_unspecified;
}

and default_do_stmt 
  ?args:((args:node list) = [])
  () : do_stmt  = {
  args;
}

and default_rename_stmt 
  ?rename_type:((rename_type:object_type) = default_object_type ())
  ?relation_type:((relation_type:object_type) = default_object_type ())
  ?relation:((relation:range_var option) = None)
  ?object_:((object_:node option) = None)
  ?subname:((subname:string) = "")
  ?newname:((newname:string) = "")
  ?behavior:((behavior:drop_behavior) = default_drop_behavior ())
  ?missing_ok:((missing_ok:bool) = false)
  () : rename_stmt  = {
  rename_type;
  relation_type;
  relation;
  object_;
  subname;
  newname;
  behavior;
  missing_ok;
}

and default_rule_stmt 
  ?relation:((relation:range_var option) = None)
  ?rulename:((rulename:string) = "")
  ?where_clause:((where_clause:node option) = None)
  ?event:((event:cmd_type) = default_cmd_type ())
  ?instead:((instead:bool) = false)
  ?actions:((actions:node list) = [])
  ?replace:((replace:bool) = false)
  () : rule_stmt  = {
  relation;
  rulename;
  where_clause;
  event;
  instead;
  actions;
  replace;
}

and default_transaction_stmt 
  ?kind:((kind:transaction_stmt_kind) = default_transaction_stmt_kind ())
  ?options:((options:node list) = [])
  ?savepoint_name:((savepoint_name:string) = "")
  ?gid:((gid:string) = "")
  ?chain:((chain:bool) = false)
  () : transaction_stmt  = {
  kind;
  options;
  savepoint_name;
  gid;
  chain;
}

and default_view_stmt 
  ?view:((view:range_var option) = None)
  ?aliases:((aliases:node list) = [])
  ?query:((query:node option) = None)
  ?replace:((replace:bool) = false)
  ?options:((options:node list) = [])
  ?with_check_option:((with_check_option:view_check_option) = default_view_check_option ())
  () : view_stmt  = {
  view;
  aliases;
  query;
  replace;
  options;
  with_check_option;
}

and default_create_domain_stmt 
  ?domainname:((domainname:node list) = [])
  ?type_name:((type_name:type_name option) = None)
  ?coll_clause:((coll_clause:collate_clause option) = None)
  ?constraints:((constraints:node list) = [])
  () : create_domain_stmt  = {
  domainname;
  type_name;
  coll_clause;
  constraints;
}

and default_collate_clause 
  ?arg:((arg:node option) = None)
  ?collname:((collname:node list) = [])
  ?location:((location:int32) = 0l)
  () : collate_clause  = {
  arg;
  collname;
  location;
}

and default_createdb_stmt 
  ?dbname:((dbname:string) = "")
  ?options:((options:node list) = [])
  () : createdb_stmt  = {
  dbname;
  options;
}

and default_dropdb_stmt 
  ?dbname:((dbname:string) = "")
  ?missing_ok:((missing_ok:bool) = false)
  ?options:((options:node list) = [])
  () : dropdb_stmt  = {
  dbname;
  missing_ok;
  options;
}

and default_vacuum_stmt 
  ?options:((options:node list) = [])
  ?rels:((rels:node list) = [])
  ?is_vacuumcmd:((is_vacuumcmd:bool) = false)
  () : vacuum_stmt  = {
  options;
  rels;
  is_vacuumcmd;
}

and default_explain_stmt 
  ?query:((query:node option) = None)
  ?options:((options:node list) = [])
  () : explain_stmt  = {
  query;
  options;
}

and default_create_table_as_stmt 
  ?query:((query:node option) = None)
  ?into:((into:into_clause option) = None)
  ?relkind:((relkind:object_type) = default_object_type ())
  ?is_select_into:((is_select_into:bool) = false)
  ?if_not_exists:((if_not_exists:bool) = false)
  () : create_table_as_stmt  = {
  query;
  into;
  relkind;
  is_select_into;
  if_not_exists;
}

and default_create_seq_stmt 
  ?sequence:((sequence:range_var option) = None)
  ?options:((options:node list) = [])
  ?owner_id:((owner_id:int32) = 0l)
  ?for_identity:((for_identity:bool) = false)
  ?if_not_exists:((if_not_exists:bool) = false)
  () : create_seq_stmt  = {
  sequence;
  options;
  owner_id;
  for_identity;
  if_not_exists;
}

and default_alter_seq_stmt 
  ?sequence:((sequence:range_var option) = None)
  ?options:((options:node list) = [])
  ?for_identity:((for_identity:bool) = false)
  ?missing_ok:((missing_ok:bool) = false)
  () : alter_seq_stmt  = {
  sequence;
  options;
  for_identity;
  missing_ok;
}

and default_variable_set_stmt 
  ?kind:((kind:variable_set_kind) = default_variable_set_kind ())
  ?name:((name:string) = "")
  ?args:((args:node list) = [])
  ?is_local:((is_local:bool) = false)
  () : variable_set_stmt  = {
  kind;
  name;
  args;
  is_local;
}

and default_create_trig_stmt 
  ?trigname:((trigname:string) = "")
  ?relation:((relation:range_var option) = None)
  ?funcname:((funcname:node list) = [])
  ?args:((args:node list) = [])
  ?row:((row:bool) = false)
  ?timing:((timing:int32) = 0l)
  ?events:((events:int32) = 0l)
  ?columns:((columns:node list) = [])
  ?when_clause:((when_clause:node option) = None)
  ?isconstraint:((isconstraint:bool) = false)
  ?transition_rels:((transition_rels:node list) = [])
  ?deferrable:((deferrable:bool) = false)
  ?initdeferred:((initdeferred:bool) = false)
  ?constrrel:((constrrel:range_var option) = None)
  () : create_trig_stmt  = {
  trigname;
  relation;
  funcname;
  args;
  row;
  timing;
  events;
  columns;
  when_clause;
  isconstraint;
  transition_rels;
  deferrable;
  initdeferred;
  constrrel;
}

and default_create_plang_stmt 
  ?replace:((replace:bool) = false)
  ?plname:((plname:string) = "")
  ?plhandler:((plhandler:node list) = [])
  ?plinline:((plinline:node list) = [])
  ?plvalidator:((plvalidator:node list) = [])
  ?pltrusted:((pltrusted:bool) = false)
  () : create_plang_stmt  = {
  replace;
  plname;
  plhandler;
  plinline;
  plvalidator;
  pltrusted;
}

and default_create_role_stmt 
  ?stmt_type:((stmt_type:role_stmt_type) = default_role_stmt_type ())
  ?role:((role:string) = "")
  ?options:((options:node list) = [])
  () : create_role_stmt  = {
  stmt_type;
  role;
  options;
}

and default_alter_role_stmt 
  ?role:((role:role_spec option) = None)
  ?options:((options:node list) = [])
  ?action:((action:int32) = 0l)
  () : alter_role_stmt  = {
  role;
  options;
  action;
}

and default_drop_role_stmt 
  ?roles:((roles:node list) = [])
  ?missing_ok:((missing_ok:bool) = false)
  () : drop_role_stmt  = {
  roles;
  missing_ok;
}

and default_lock_stmt 
  ?relations:((relations:node list) = [])
  ?mode:((mode:int32) = 0l)
  ?nowait:((nowait:bool) = false)
  () : lock_stmt  = {
  relations;
  mode;
  nowait;
}

and default_constraints_set_stmt 
  ?constraints:((constraints:node list) = [])
  ?deferred:((deferred:bool) = false)
  () : constraints_set_stmt  = {
  constraints;
  deferred;
}

and default_reindex_stmt 
  ?kind:((kind:reindex_object_type) = default_reindex_object_type ())
  ?relation:((relation:range_var option) = None)
  ?name:((name:string) = "")
  ?options:((options:int32) = 0l)
  ?concurrent:((concurrent:bool) = false)
  () : reindex_stmt  = {
  kind;
  relation;
  name;
  options;
  concurrent;
}

and default_create_schema_stmt 
  ?schemaname:((schemaname:string) = "")
  ?authrole:((authrole:role_spec option) = None)
  ?schema_elts:((schema_elts:node list) = [])
  ?if_not_exists:((if_not_exists:bool) = false)
  () : create_schema_stmt  = {
  schemaname;
  authrole;
  schema_elts;
  if_not_exists;
}

and default_alter_database_stmt 
  ?dbname:((dbname:string) = "")
  ?options:((options:node list) = [])
  () : alter_database_stmt  = {
  dbname;
  options;
}

and default_alter_database_set_stmt 
  ?dbname:((dbname:string) = "")
  ?setstmt:((setstmt:variable_set_stmt option) = None)
  () : alter_database_set_stmt  = {
  dbname;
  setstmt;
}

and default_alter_role_set_stmt 
  ?role:((role:role_spec option) = None)
  ?database:((database:string) = "")
  ?setstmt:((setstmt:variable_set_stmt option) = None)
  () : alter_role_set_stmt  = {
  role;
  database;
  setstmt;
}

and default_create_conversion_stmt 
  ?conversion_name:((conversion_name:node list) = [])
  ?for_encoding_name:((for_encoding_name:string) = "")
  ?to_encoding_name:((to_encoding_name:string) = "")
  ?func_name:((func_name:node list) = [])
  ?def:((def:bool) = false)
  () : create_conversion_stmt  = {
  conversion_name;
  for_encoding_name;
  to_encoding_name;
  func_name;
  def;
}

and default_create_cast_stmt 
  ?sourcetype:((sourcetype:type_name option) = None)
  ?targettype:((targettype:type_name option) = None)
  ?func:((func:object_with_args option) = None)
  ?context:((context:coercion_context) = default_coercion_context ())
  ?inout:((inout:bool) = false)
  () : create_cast_stmt  = {
  sourcetype;
  targettype;
  func;
  context;
  inout;
}

and default_create_op_class_stmt 
  ?opclassname:((opclassname:node list) = [])
  ?opfamilyname:((opfamilyname:node list) = [])
  ?amname:((amname:string) = "")
  ?datatype:((datatype:type_name option) = None)
  ?items:((items:node list) = [])
  ?is_default:((is_default:bool) = false)
  () : create_op_class_stmt  = {
  opclassname;
  opfamilyname;
  amname;
  datatype;
  items;
  is_default;
}

and default_create_op_family_stmt 
  ?opfamilyname:((opfamilyname:node list) = [])
  ?amname:((amname:string) = "")
  () : create_op_family_stmt  = {
  opfamilyname;
  amname;
}

and default_alter_op_family_stmt 
  ?opfamilyname:((opfamilyname:node list) = [])
  ?amname:((amname:string) = "")
  ?is_drop:((is_drop:bool) = false)
  ?items:((items:node list) = [])
  () : alter_op_family_stmt  = {
  opfamilyname;
  amname;
  is_drop;
  items;
}

and default_prepare_stmt 
  ?name:((name:string) = "")
  ?argtypes:((argtypes:node list) = [])
  ?query:((query:node option) = None)
  () : prepare_stmt  = {
  name;
  argtypes;
  query;
}

and default_execute_stmt 
  ?name:((name:string) = "")
  ?params:((params:node list) = [])
  () : execute_stmt  = {
  name;
  params;
}

and default_declare_cursor_stmt 
  ?portalname:((portalname:string) = "")
  ?options:((options:int32) = 0l)
  ?query:((query:node option) = None)
  () : declare_cursor_stmt  = {
  portalname;
  options;
  query;
}

and default_create_table_space_stmt 
  ?tablespacename:((tablespacename:string) = "")
  ?owner:((owner:role_spec option) = None)
  ?location:((location:string) = "")
  ?options:((options:node list) = [])
  () : create_table_space_stmt  = {
  tablespacename;
  owner;
  location;
  options;
}

and default_alter_object_depends_stmt 
  ?object_type:((object_type:object_type) = default_object_type ())
  ?relation:((relation:range_var option) = None)
  ?object_:((object_:node option) = None)
  ?extname:((extname:node option) = None)
  ?remove:((remove:bool) = false)
  () : alter_object_depends_stmt  = {
  object_type;
  relation;
  object_;
  extname;
  remove;
}

and default_alter_object_schema_stmt 
  ?object_type:((object_type:object_type) = default_object_type ())
  ?relation:((relation:range_var option) = None)
  ?object_:((object_:node option) = None)
  ?newschema:((newschema:string) = "")
  ?missing_ok:((missing_ok:bool) = false)
  () : alter_object_schema_stmt  = {
  object_type;
  relation;
  object_;
  newschema;
  missing_ok;
}

and default_alter_owner_stmt 
  ?object_type:((object_type:object_type) = default_object_type ())
  ?relation:((relation:range_var option) = None)
  ?object_:((object_:node option) = None)
  ?newowner:((newowner:role_spec option) = None)
  () : alter_owner_stmt  = {
  object_type;
  relation;
  object_;
  newowner;
}

and default_alter_operator_stmt 
  ?opername:((opername:object_with_args option) = None)
  ?options:((options:node list) = [])
  () : alter_operator_stmt  = {
  opername;
  options;
}

and default_alter_type_stmt 
  ?type_name:((type_name:node list) = [])
  ?options:((options:node list) = [])
  () : alter_type_stmt  = {
  type_name;
  options;
}

and default_drop_owned_stmt 
  ?roles:((roles:node list) = [])
  ?behavior:((behavior:drop_behavior) = default_drop_behavior ())
  () : drop_owned_stmt  = {
  roles;
  behavior;
}

and default_reassign_owned_stmt 
  ?roles:((roles:node list) = [])
  ?newrole:((newrole:role_spec option) = None)
  () : reassign_owned_stmt  = {
  roles;
  newrole;
}

and default_composite_type_stmt 
  ?typevar:((typevar:range_var option) = None)
  ?coldeflist:((coldeflist:node list) = [])
  () : composite_type_stmt  = {
  typevar;
  coldeflist;
}

and default_create_enum_stmt 
  ?type_name:((type_name:node list) = [])
  ?vals:((vals:node list) = [])
  () : create_enum_stmt  = {
  type_name;
  vals;
}

and default_create_range_stmt 
  ?type_name:((type_name:node list) = [])
  ?params:((params:node list) = [])
  () : create_range_stmt  = {
  type_name;
  params;
}

and default_alter_enum_stmt 
  ?type_name:((type_name:node list) = [])
  ?old_val:((old_val:string) = "")
  ?new_val:((new_val:string) = "")
  ?new_val_neighbor:((new_val_neighbor:string) = "")
  ?new_val_is_after:((new_val_is_after:bool) = false)
  ?skip_if_new_val_exists:((skip_if_new_val_exists:bool) = false)
  () : alter_enum_stmt  = {
  type_name;
  old_val;
  new_val;
  new_val_neighbor;
  new_val_is_after;
  skip_if_new_val_exists;
}

and default_alter_tsdictionary_stmt 
  ?dictname:((dictname:node list) = [])
  ?options:((options:node list) = [])
  () : alter_tsdictionary_stmt  = {
  dictname;
  options;
}

and default_alter_tsconfiguration_stmt 
  ?kind:((kind:alter_tsconfig_type) = default_alter_tsconfig_type ())
  ?cfgname:((cfgname:node list) = [])
  ?tokentype:((tokentype:node list) = [])
  ?dicts:((dicts:node list) = [])
  ?override:((override:bool) = false)
  ?replace:((replace:bool) = false)
  ?missing_ok:((missing_ok:bool) = false)
  () : alter_tsconfiguration_stmt  = {
  kind;
  cfgname;
  tokentype;
  dicts;
  override;
  replace;
  missing_ok;
}

and default_create_fdw_stmt 
  ?fdwname:((fdwname:string) = "")
  ?func_options:((func_options:node list) = [])
  ?options:((options:node list) = [])
  () : create_fdw_stmt  = {
  fdwname;
  func_options;
  options;
}

and default_alter_fdw_stmt 
  ?fdwname:((fdwname:string) = "")
  ?func_options:((func_options:node list) = [])
  ?options:((options:node list) = [])
  () : alter_fdw_stmt  = {
  fdwname;
  func_options;
  options;
}

and default_create_foreign_server_stmt 
  ?servername:((servername:string) = "")
  ?servertype:((servertype:string) = "")
  ?version:((version:string) = "")
  ?fdwname:((fdwname:string) = "")
  ?if_not_exists:((if_not_exists:bool) = false)
  ?options:((options:node list) = [])
  () : create_foreign_server_stmt  = {
  servername;
  servertype;
  version;
  fdwname;
  if_not_exists;
  options;
}

and default_alter_foreign_server_stmt 
  ?servername:((servername:string) = "")
  ?version:((version:string) = "")
  ?options:((options:node list) = [])
  ?has_version:((has_version:bool) = false)
  () : alter_foreign_server_stmt  = {
  servername;
  version;
  options;
  has_version;
}

and default_create_user_mapping_stmt 
  ?user:((user:role_spec option) = None)
  ?servername:((servername:string) = "")
  ?if_not_exists:((if_not_exists:bool) = false)
  ?options:((options:node list) = [])
  () : create_user_mapping_stmt  = {
  user;
  servername;
  if_not_exists;
  options;
}

and default_alter_user_mapping_stmt 
  ?user:((user:role_spec option) = None)
  ?servername:((servername:string) = "")
  ?options:((options:node list) = [])
  () : alter_user_mapping_stmt  = {
  user;
  servername;
  options;
}

and default_alter_table_space_options_stmt 
  ?tablespacename:((tablespacename:string) = "")
  ?options:((options:node list) = [])
  ?is_reset:((is_reset:bool) = false)
  () : alter_table_space_options_stmt  = {
  tablespacename;
  options;
  is_reset;
}

and default_alter_table_move_all_stmt 
  ?orig_tablespacename:((orig_tablespacename:string) = "")
  ?objtype:((objtype:object_type) = default_object_type ())
  ?roles:((roles:node list) = [])
  ?new_tablespacename:((new_tablespacename:string) = "")
  ?nowait:((nowait:bool) = false)
  () : alter_table_move_all_stmt  = {
  orig_tablespacename;
  objtype;
  roles;
  new_tablespacename;
  nowait;
}

and default_sec_label_stmt 
  ?objtype:((objtype:object_type) = default_object_type ())
  ?object_:((object_:node option) = None)
  ?provider:((provider:string) = "")
  ?label:((label:string) = "")
  () : sec_label_stmt  = {
  objtype;
  object_;
  provider;
  label;
}

and default_create_foreign_table_stmt 
  ?base_stmt:((base_stmt:create_stmt option) = None)
  ?servername:((servername:string) = "")
  ?options:((options:node list) = [])
  () : create_foreign_table_stmt  = {
  base_stmt;
  servername;
  options;
}

and default_import_foreign_schema_stmt 
  ?server_name:((server_name:string) = "")
  ?remote_schema:((remote_schema:string) = "")
  ?local_schema:((local_schema:string) = "")
  ?list_type:((list_type:import_foreign_schema_type) = default_import_foreign_schema_type ())
  ?table_list:((table_list:node list) = [])
  ?options:((options:node list) = [])
  () : import_foreign_schema_stmt  = {
  server_name;
  remote_schema;
  local_schema;
  list_type;
  table_list;
  options;
}

and default_create_extension_stmt 
  ?extname:((extname:string) = "")
  ?if_not_exists:((if_not_exists:bool) = false)
  ?options:((options:node list) = [])
  () : create_extension_stmt  = {
  extname;
  if_not_exists;
  options;
}

and default_alter_extension_stmt 
  ?extname:((extname:string) = "")
  ?options:((options:node list) = [])
  () : alter_extension_stmt  = {
  extname;
  options;
}

and default_alter_extension_contents_stmt 
  ?extname:((extname:string) = "")
  ?action:((action:int32) = 0l)
  ?objtype:((objtype:object_type) = default_object_type ())
  ?object_:((object_:node option) = None)
  () : alter_extension_contents_stmt  = {
  extname;
  action;
  objtype;
  object_;
}

and default_create_event_trig_stmt 
  ?trigname:((trigname:string) = "")
  ?eventname:((eventname:string) = "")
  ?whenclause:((whenclause:node list) = [])
  ?funcname:((funcname:node list) = [])
  () : create_event_trig_stmt  = {
  trigname;
  eventname;
  whenclause;
  funcname;
}

and default_refresh_mat_view_stmt 
  ?concurrent:((concurrent:bool) = false)
  ?skip_data:((skip_data:bool) = false)
  ?relation:((relation:range_var option) = None)
  () : refresh_mat_view_stmt  = {
  concurrent;
  skip_data;
  relation;
}

and default_alter_system_stmt 
  ?setstmt:((setstmt:variable_set_stmt option) = None)
  () : alter_system_stmt  = {
  setstmt;
}

and default_create_policy_stmt 
  ?policy_name:((policy_name:string) = "")
  ?table:((table:range_var option) = None)
  ?cmd_name:((cmd_name:string) = "")
  ?permissive:((permissive:bool) = false)
  ?roles:((roles:node list) = [])
  ?qual:((qual:node option) = None)
  ?with_check:((with_check:node option) = None)
  () : create_policy_stmt  = {
  policy_name;
  table;
  cmd_name;
  permissive;
  roles;
  qual;
  with_check;
}

and default_alter_policy_stmt 
  ?policy_name:((policy_name:string) = "")
  ?table:((table:range_var option) = None)
  ?roles:((roles:node list) = [])
  ?qual:((qual:node option) = None)
  ?with_check:((with_check:node option) = None)
  () : alter_policy_stmt  = {
  policy_name;
  table;
  roles;
  qual;
  with_check;
}

and default_create_transform_stmt 
  ?replace:((replace:bool) = false)
  ?type_name:((type_name:type_name option) = None)
  ?lang:((lang:string) = "")
  ?fromsql:((fromsql:object_with_args option) = None)
  ?tosql:((tosql:object_with_args option) = None)
  () : create_transform_stmt  = {
  replace;
  type_name;
  lang;
  fromsql;
  tosql;
}

and default_create_am_stmt 
  ?amname:((amname:string) = "")
  ?handler_name:((handler_name:node list) = [])
  ?amtype:((amtype:string) = "")
  () : create_am_stmt  = {
  amname;
  handler_name;
  amtype;
}

and default_create_publication_stmt 
  ?pubname:((pubname:string) = "")
  ?options:((options:node list) = [])
  ?tables:((tables:node list) = [])
  ?for_all_tables:((for_all_tables:bool) = false)
  () : create_publication_stmt  = {
  pubname;
  options;
  tables;
  for_all_tables;
}

and default_alter_publication_stmt 
  ?pubname:((pubname:string) = "")
  ?options:((options:node list) = [])
  ?tables:((tables:node list) = [])
  ?for_all_tables:((for_all_tables:bool) = false)
  ?table_action:((table_action:def_elem_action) = default_def_elem_action ())
  () : alter_publication_stmt  = {
  pubname;
  options;
  tables;
  for_all_tables;
  table_action;
}

and default_create_subscription_stmt 
  ?subname:((subname:string) = "")
  ?conninfo:((conninfo:string) = "")
  ?publication:((publication:node list) = [])
  ?options:((options:node list) = [])
  () : create_subscription_stmt  = {
  subname;
  conninfo;
  publication;
  options;
}

and default_alter_subscription_stmt 
  ?kind:((kind:alter_subscription_type) = default_alter_subscription_type ())
  ?subname:((subname:string) = "")
  ?conninfo:((conninfo:string) = "")
  ?publication:((publication:node list) = [])
  ?options:((options:node list) = [])
  () : alter_subscription_stmt  = {
  kind;
  subname;
  conninfo;
  publication;
  options;
}

and default_create_stats_stmt 
  ?defnames:((defnames:node list) = [])
  ?stat_types:((stat_types:node list) = [])
  ?exprs:((exprs:node list) = [])
  ?relations:((relations:node list) = [])
  ?stxcomment:((stxcomment:string) = "")
  ?if_not_exists:((if_not_exists:bool) = false)
  () : create_stats_stmt  = {
  defnames;
  stat_types;
  exprs;
  relations;
  stxcomment;
  if_not_exists;
}

and default_alter_collation_stmt 
  ?collname:((collname:node list) = [])
  () : alter_collation_stmt  = {
  collname;
}

and default_call_stmt 
  ?funccall:((funccall:func_call option) = None)
  ?funcexpr:((funcexpr:func_expr option) = None)
  () : call_stmt  = {
  funccall;
  funcexpr;
}

and default_func_call 
  ?funcname:((funcname:node list) = [])
  ?args:((args:node list) = [])
  ?agg_order:((agg_order:node list) = [])
  ?agg_filter:((agg_filter:node option) = None)
  ?agg_within_group:((agg_within_group:bool) = false)
  ?agg_star:((agg_star:bool) = false)
  ?agg_distinct:((agg_distinct:bool) = false)
  ?func_variadic:((func_variadic:bool) = false)
  ?over:((over:window_def option) = None)
  ?location:((location:int32) = 0l)
  () : func_call  = {
  funcname;
  args;
  agg_order;
  agg_filter;
  agg_within_group;
  agg_star;
  agg_distinct;
  func_variadic;
  over;
  location;
}

and default_window_def 
  ?name:((name:string) = "")
  ?refname:((refname:string) = "")
  ?partition_clause:((partition_clause:node list) = [])
  ?order_clause:((order_clause:node list) = [])
  ?frame_options:((frame_options:int32) = 0l)
  ?start_offset:((start_offset:node option) = None)
  ?end_offset:((end_offset:node option) = None)
  ?location:((location:int32) = 0l)
  () : window_def  = {
  name;
  refname;
  partition_clause;
  order_clause;
  frame_options;
  start_offset;
  end_offset;
  location;
}

and default_alter_stats_stmt 
  ?defnames:((defnames:node list) = [])
  ?stxstattarget:((stxstattarget:int32) = 0l)
  ?missing_ok:((missing_ok:bool) = false)
  () : alter_stats_stmt  = {
  defnames;
  stxstattarget;
  missing_ok;
}

and default_a_expr 
  ?kind:((kind:a_expr_kind) = default_a_expr_kind ())
  ?name:((name:node list) = [])
  ?lexpr:((lexpr:node option) = None)
  ?rexpr:((rexpr:node option) = None)
  ?location:((location:int32) = 0l)
  () : a_expr  = {
  kind;
  name;
  lexpr;
  rexpr;
  location;
}

and default_column_ref 
  ?fields:((fields:node list) = [])
  ?location:((location:int32) = 0l)
  () : column_ref  = {
  fields;
  location;
}

and default_a_const 
  ?val_:((val_:node option) = None)
  ?location:((location:int32) = 0l)
  () : a_const  = {
  val_;
  location;
}

and default_a_indices 
  ?is_slice:((is_slice:bool) = false)
  ?lidx:((lidx:node option) = None)
  ?uidx:((uidx:node option) = None)
  () : a_indices  = {
  is_slice;
  lidx;
  uidx;
}

and default_a_indirection 
  ?arg:((arg:node option) = None)
  ?indirection:((indirection:node list) = [])
  () : a_indirection  = {
  arg;
  indirection;
}

and default_a_array_expr 
  ?elements:((elements:node list) = [])
  ?location:((location:int32) = 0l)
  () : a_array_expr  = {
  elements;
  location;
}

and default_res_target 
  ?name:((name:string) = "")
  ?indirection:((indirection:node list) = [])
  ?val_:((val_:node option) = None)
  ?location:((location:int32) = 0l)
  () : res_target  = {
  name;
  indirection;
  val_;
  location;
}

and default_multi_assign_ref 
  ?source:((source:node option) = None)
  ?colno:((colno:int32) = 0l)
  ?ncolumns:((ncolumns:int32) = 0l)
  () : multi_assign_ref  = {
  source;
  colno;
  ncolumns;
}

and default_type_cast 
  ?arg:((arg:node option) = None)
  ?type_name:((type_name:type_name option) = None)
  ?location:((location:int32) = 0l)
  () : type_cast  = {
  arg;
  type_name;
  location;
}

and default_sort_by 
  ?node:((node:node option) = None)
  ?sortby_dir:((sortby_dir:sort_by_dir) = default_sort_by_dir ())
  ?sortby_nulls:((sortby_nulls:sort_by_nulls) = default_sort_by_nulls ())
  ?use_op:((use_op:node list) = [])
  ?location:((location:int32) = 0l)
  () : sort_by  = {
  node;
  sortby_dir;
  sortby_nulls;
  use_op;
  location;
}

and default_range_subselect 
  ?lateral:((lateral:bool) = false)
  ?subquery:((subquery:node option) = None)
  ?alias:((alias:alias option) = None)
  () : range_subselect  = {
  lateral;
  subquery;
  alias;
}

and default_range_function 
  ?lateral:((lateral:bool) = false)
  ?ordinality:((ordinality:bool) = false)
  ?is_rowsfrom:((is_rowsfrom:bool) = false)
  ?functions:((functions:node list) = [])
  ?alias:((alias:alias option) = None)
  ?coldeflist:((coldeflist:node list) = [])
  () : range_function  = {
  lateral;
  ordinality;
  is_rowsfrom;
  functions;
  alias;
  coldeflist;
}

and default_range_table_sample 
  ?relation:((relation:node option) = None)
  ?method_:((method_:node list) = [])
  ?args:((args:node list) = [])
  ?repeatable:((repeatable:node option) = None)
  ?location:((location:int32) = 0l)
  () : range_table_sample  = {
  relation;
  method_;
  args;
  repeatable;
  location;
}

and default_range_table_func 
  ?lateral:((lateral:bool) = false)
  ?docexpr:((docexpr:node option) = None)
  ?rowexpr:((rowexpr:node option) = None)
  ?namespaces:((namespaces:node list) = [])
  ?columns:((columns:node list) = [])
  ?alias:((alias:alias option) = None)
  ?location:((location:int32) = 0l)
  () : range_table_func  = {
  lateral;
  docexpr;
  rowexpr;
  namespaces;
  columns;
  alias;
  location;
}

and default_range_table_func_col 
  ?colname:((colname:string) = "")
  ?type_name:((type_name:type_name option) = None)
  ?for_ordinality:((for_ordinality:bool) = false)
  ?is_not_null:((is_not_null:bool) = false)
  ?colexpr:((colexpr:node option) = None)
  ?coldefexpr:((coldefexpr:node option) = None)
  ?location:((location:int32) = 0l)
  () : range_table_func_col  = {
  colname;
  type_name;
  for_ordinality;
  is_not_null;
  colexpr;
  coldefexpr;
  location;
}

and default_column_def 
  ?colname:((colname:string) = "")
  ?type_name:((type_name:type_name option) = None)
  ?inhcount:((inhcount:int32) = 0l)
  ?is_local:((is_local:bool) = false)
  ?is_not_null:((is_not_null:bool) = false)
  ?is_from_type:((is_from_type:bool) = false)
  ?storage:((storage:string) = "")
  ?raw_default:((raw_default:node option) = None)
  ?cooked_default:((cooked_default:node option) = None)
  ?identity:((identity:string) = "")
  ?identity_sequence:((identity_sequence:range_var option) = None)
  ?generated:((generated:string) = "")
  ?coll_clause:((coll_clause:collate_clause option) = None)
  ?coll_oid:((coll_oid:int32) = 0l)
  ?constraints:((constraints:node list) = [])
  ?fdwoptions:((fdwoptions:node list) = [])
  ?location:((location:int32) = 0l)
  () : column_def  = {
  colname;
  type_name;
  inhcount;
  is_local;
  is_not_null;
  is_from_type;
  storage;
  raw_default;
  cooked_default;
  identity;
  identity_sequence;
  generated;
  coll_clause;
  coll_oid;
  constraints;
  fdwoptions;
  location;
}

and default_index_elem 
  ?name:((name:string) = "")
  ?expr:((expr:node option) = None)
  ?indexcolname:((indexcolname:string) = "")
  ?collation:((collation:node list) = [])
  ?opclass:((opclass:node list) = [])
  ?opclassopts:((opclassopts:node list) = [])
  ?ordering:((ordering:sort_by_dir) = default_sort_by_dir ())
  ?nulls_ordering:((nulls_ordering:sort_by_nulls) = default_sort_by_nulls ())
  () : index_elem  = {
  name;
  expr;
  indexcolname;
  collation;
  opclass;
  opclassopts;
  ordering;
  nulls_ordering;
}

and default_constraint_ 
  ?contype:((contype:constr_type) = default_constr_type ())
  ?conname:((conname:string) = "")
  ?deferrable:((deferrable:bool) = false)
  ?initdeferred:((initdeferred:bool) = false)
  ?location:((location:int32) = 0l)
  ?is_no_inherit:((is_no_inherit:bool) = false)
  ?raw_expr:((raw_expr:node option) = None)
  ?cooked_expr:((cooked_expr:string) = "")
  ?generated_when:((generated_when:string) = "")
  ?keys:((keys:node list) = [])
  ?including:((including:node list) = [])
  ?exclusions:((exclusions:node list) = [])
  ?options:((options:node list) = [])
  ?indexname:((indexname:string) = "")
  ?indexspace:((indexspace:string) = "")
  ?reset_default_tblspc:((reset_default_tblspc:bool) = false)
  ?access_method:((access_method:string) = "")
  ?where_clause:((where_clause:node option) = None)
  ?pktable:((pktable:range_var option) = None)
  ?fk_attrs:((fk_attrs:node list) = [])
  ?pk_attrs:((pk_attrs:node list) = [])
  ?fk_matchtype:((fk_matchtype:string) = "")
  ?fk_upd_action:((fk_upd_action:string) = "")
  ?fk_del_action:((fk_del_action:string) = "")
  ?old_conpfeqop:((old_conpfeqop:node list) = [])
  ?old_pktable_oid:((old_pktable_oid:int32) = 0l)
  ?skip_validation:((skip_validation:bool) = false)
  ?initially_valid:((initially_valid:bool) = false)
  () : constraint_  = {
  contype;
  conname;
  deferrable;
  initdeferred;
  location;
  is_no_inherit;
  raw_expr;
  cooked_expr;
  generated_when;
  keys;
  including;
  exclusions;
  options;
  indexname;
  indexspace;
  reset_default_tblspc;
  access_method;
  where_clause;
  pktable;
  fk_attrs;
  pk_attrs;
  fk_matchtype;
  fk_upd_action;
  fk_del_action;
  old_conpfeqop;
  old_pktable_oid;
  skip_validation;
  initially_valid;
}

and default_def_elem 
  ?defnamespace:((defnamespace:string) = "")
  ?defname:((defname:string) = "")
  ?arg:((arg:node option) = None)
  ?defaction:((defaction:def_elem_action) = default_def_elem_action ())
  ?location:((location:int32) = 0l)
  () : def_elem  = {
  defnamespace;
  defname;
  arg;
  defaction;
  location;
}

and default_range_tbl_entry 
  ?rtekind:((rtekind:rtekind) = default_rtekind ())
  ?relid:((relid:int32) = 0l)
  ?relkind:((relkind:string) = "")
  ?rellockmode:((rellockmode:int32) = 0l)
  ?tablesample:((tablesample:table_sample_clause option) = None)
  ?subquery:((subquery:query option) = None)
  ?security_barrier:((security_barrier:bool) = false)
  ?jointype:((jointype:join_type) = default_join_type ())
  ?joinmergedcols:((joinmergedcols:int32) = 0l)
  ?joinaliasvars:((joinaliasvars:node list) = [])
  ?joinleftcols:((joinleftcols:node list) = [])
  ?joinrightcols:((joinrightcols:node list) = [])
  ?functions:((functions:node list) = [])
  ?funcordinality:((funcordinality:bool) = false)
  ?tablefunc:((tablefunc:table_func option) = None)
  ?values_lists:((values_lists:node list) = [])
  ?ctename:((ctename:string) = "")
  ?ctelevelsup:((ctelevelsup:int32) = 0l)
  ?self_reference:((self_reference:bool) = false)
  ?coltypes:((coltypes:node list) = [])
  ?coltypmods:((coltypmods:node list) = [])
  ?colcollations:((colcollations:node list) = [])
  ?enrname:((enrname:string) = "")
  ?enrtuples:((enrtuples:float) = 0.)
  ?alias:((alias:alias option) = None)
  ?eref:((eref:alias option) = None)
  ?lateral:((lateral:bool) = false)
  ?inh:((inh:bool) = false)
  ?in_from_cl:((in_from_cl:bool) = false)
  ?required_perms:((required_perms:int32) = 0l)
  ?check_as_user:((check_as_user:int32) = 0l)
  ?selected_cols:((selected_cols:int64 list) = [])
  ?inserted_cols:((inserted_cols:int64 list) = [])
  ?updated_cols:((updated_cols:int64 list) = [])
  ?extra_updated_cols:((extra_updated_cols:int64 list) = [])
  ?security_quals:((security_quals:node list) = [])
  () : range_tbl_entry  = {
  rtekind;
  relid;
  relkind;
  rellockmode;
  tablesample;
  subquery;
  security_barrier;
  jointype;
  joinmergedcols;
  joinaliasvars;
  joinleftcols;
  joinrightcols;
  functions;
  funcordinality;
  tablefunc;
  values_lists;
  ctename;
  ctelevelsup;
  self_reference;
  coltypes;
  coltypmods;
  colcollations;
  enrname;
  enrtuples;
  alias;
  eref;
  lateral;
  inh;
  in_from_cl;
  required_perms;
  check_as_user;
  selected_cols;
  inserted_cols;
  updated_cols;
  extra_updated_cols;
  security_quals;
}

and default_table_sample_clause 
  ?tsmhandler:((tsmhandler:int32) = 0l)
  ?args:((args:node list) = [])
  ?repeatable:((repeatable:node option) = None)
  () : table_sample_clause  = {
  tsmhandler;
  args;
  repeatable;
}

and default_range_tbl_function 
  ?funcexpr:((funcexpr:node option) = None)
  ?funccolcount:((funccolcount:int32) = 0l)
  ?funccolnames:((funccolnames:node list) = [])
  ?funccoltypes:((funccoltypes:node list) = [])
  ?funccoltypmods:((funccoltypmods:node list) = [])
  ?funccolcollations:((funccolcollations:node list) = [])
  ?funcparams:((funcparams:int64 list) = [])
  () : range_tbl_function  = {
  funcexpr;
  funccolcount;
  funccolnames;
  funccoltypes;
  funccoltypmods;
  funccolcollations;
  funcparams;
}

and default_with_check_option 
  ?kind:((kind:wcokind) = default_wcokind ())
  ?relname:((relname:string) = "")
  ?polname:((polname:string) = "")
  ?qual:((qual:node option) = None)
  ?cascaded:((cascaded:bool) = false)
  () : with_check_option  = {
  kind;
  relname;
  polname;
  qual;
  cascaded;
}

and default_grouping_set 
  ?kind:((kind:grouping_set_kind) = default_grouping_set_kind ())
  ?content:((content:node list) = [])
  ?location:((location:int32) = 0l)
  () : grouping_set  = {
  kind;
  content;
  location;
}

and default_window_clause 
  ?name:((name:string) = "")
  ?refname:((refname:string) = "")
  ?partition_clause:((partition_clause:node list) = [])
  ?order_clause:((order_clause:node list) = [])
  ?frame_options:((frame_options:int32) = 0l)
  ?start_offset:((start_offset:node option) = None)
  ?end_offset:((end_offset:node option) = None)
  ?start_in_range_func:((start_in_range_func:int32) = 0l)
  ?end_in_range_func:((end_in_range_func:int32) = 0l)
  ?in_range_coll:((in_range_coll:int32) = 0l)
  ?in_range_asc:((in_range_asc:bool) = false)
  ?in_range_nulls_first:((in_range_nulls_first:bool) = false)
  ?winref:((winref:int32) = 0l)
  ?copied_order:((copied_order:bool) = false)
  () : window_clause  = {
  name;
  refname;
  partition_clause;
  order_clause;
  frame_options;
  start_offset;
  end_offset;
  start_in_range_func;
  end_in_range_func;
  in_range_coll;
  in_range_asc;
  in_range_nulls_first;
  winref;
  copied_order;
}

and default_access_priv 
  ?priv_name:((priv_name:string) = "")
  ?cols:((cols:node list) = [])
  () : access_priv  = {
  priv_name;
  cols;
}

and default_create_op_class_item 
  ?itemtype:((itemtype:int32) = 0l)
  ?name:((name:object_with_args option) = None)
  ?number:((number:int32) = 0l)
  ?order_family:((order_family:node list) = [])
  ?class_args:((class_args:node list) = [])
  ?storedtype:((storedtype:type_name option) = None)
  () : create_op_class_item  = {
  itemtype;
  name;
  number;
  order_family;
  class_args;
  storedtype;
}

and default_table_like_clause 
  ?relation:((relation:range_var option) = None)
  ?options:((options:int32) = 0l)
  ?relation_oid:((relation_oid:int32) = 0l)
  () : table_like_clause  = {
  relation;
  options;
  relation_oid;
}

and default_function_parameter 
  ?name:((name:string) = "")
  ?arg_type:((arg_type:type_name option) = None)
  ?mode:((mode:function_parameter_mode) = default_function_parameter_mode ())
  ?defexpr:((defexpr:node option) = None)
  () : function_parameter  = {
  name;
  arg_type;
  mode;
  defexpr;
}

and default_locking_clause 
  ?locked_rels:((locked_rels:node list) = [])
  ?strength:((strength:lock_clause_strength) = default_lock_clause_strength ())
  ?wait_policy:((wait_policy:lock_wait_policy) = default_lock_wait_policy ())
  () : locking_clause  = {
  locked_rels;
  strength;
  wait_policy;
}

and default_xml_serialize 
  ?xmloption:((xmloption:xml_option_type) = default_xml_option_type ())
  ?expr:((expr:node option) = None)
  ?type_name:((type_name:type_name option) = None)
  ?location:((location:int32) = 0l)
  () : xml_serialize  = {
  xmloption;
  expr;
  type_name;
  location;
}

and default_common_table_expr 
  ?ctename:((ctename:string) = "")
  ?aliascolnames:((aliascolnames:node list) = [])
  ?ctematerialized:((ctematerialized:ctematerialize) = default_ctematerialize ())
  ?ctequery:((ctequery:node option) = None)
  ?location:((location:int32) = 0l)
  ?cterecursive:((cterecursive:bool) = false)
  ?cterefcount:((cterefcount:int32) = 0l)
  ?ctecolnames:((ctecolnames:node list) = [])
  ?ctecoltypes:((ctecoltypes:node list) = [])
  ?ctecoltypmods:((ctecoltypmods:node list) = [])
  ?ctecolcollations:((ctecolcollations:node list) = [])
  () : common_table_expr  = {
  ctename;
  aliascolnames;
  ctematerialized;
  ctequery;
  location;
  cterecursive;
  cterefcount;
  ctecolnames;
  ctecoltypes;
  ctecoltypmods;
  ctecolcollations;
}

and default_partition_elem 
  ?name:((name:string) = "")
  ?expr:((expr:node option) = None)
  ?collation:((collation:node list) = [])
  ?opclass:((opclass:node list) = [])
  ?location:((location:int32) = 0l)
  () : partition_elem  = {
  name;
  expr;
  collation;
  opclass;
  location;
}

and default_partition_range_datum 
  ?kind:((kind:partition_range_datum_kind) = default_partition_range_datum_kind ())
  ?value:((value:node option) = None)
  ?location:((location:int32) = 0l)
  () : partition_range_datum  = {
  kind;
  value;
  location;
}

and default_partition_cmd 
  ?name:((name:range_var option) = None)
  ?bound:((bound:partition_bound_spec option) = None)
  () : partition_cmd  = {
  name;
  bound;
}

and default_vacuum_relation 
  ?relation:((relation:range_var option) = None)
  ?oid:((oid:int32) = 0l)
  ?va_cols:((va_cols:node list) = [])
  () : vacuum_relation  = {
  relation;
  oid;
  va_cols;
}

and default_pglist 
  ?items:((items:node list) = [])
  () : pglist  = {
  items;
}

and default_int_list 
  ?items:((items:node list) = [])
  () : int_list  = {
  items;
}

and default_oid_list 
  ?items:((items:node list) = [])
  () : oid_list  = {
  items;
}

let rec default_parse_result 
  ?version:((version:int32) = 0l)
  ?stmts:((stmts:raw_stmt list) = [])
  () : parse_result  = {
  version;
  stmts;
}

let rec default_token () = (Nul:token)

let rec default_keyword_kind () = (No_keyword:keyword_kind)

let rec default_scan_token 
  ?start:((start:int32) = 0l)
  ?end_:((end_:int32) = 0l)
  ?token:((token:token) = default_token ())
  ?keyword_kind:((keyword_kind:keyword_kind) = default_keyword_kind ())
  () : scan_token  = {
  start;
  end_;
  token;
  keyword_kind;
}

let rec default_scan_result 
  ?version:((version:int32) = 0l)
  ?tokens:((tokens:scan_token list) = [])
  () : scan_result  = {
  version;
  tokens;
}

let rec default_table_like_option () = (Table_like_option_undefined:table_like_option)

let rec default_cluster_option () = (Cluster_option_undefined:cluster_option)

let rec default_agg_strategy () = (Agg_strategy_undefined:agg_strategy)

let rec default_set_op_cmd () = (Set_op_cmd_undefined:set_op_cmd)

let rec default_set_op_strategy () = (Set_op_strategy_undefined:set_op_strategy)

let rec default_lock_tuple_mode () = (Lock_tuple_mode_undefined:lock_tuple_mode)

type range_tbl_ref_mutable = {
  mutable rtindex : int32;
}

let default_range_tbl_ref_mutable () : range_tbl_ref_mutable = {
  rtindex = 0l;
}

type role_spec_mutable = {
  mutable roletype : role_spec_type;
  mutable rolename : string;
  mutable location : int32;
}

let default_role_spec_mutable () : role_spec_mutable = {
  roletype = default_role_spec_type ();
  rolename = "";
  location = 0l;
}

type close_portal_stmt_mutable = {
  mutable portalname : string;
}

let default_close_portal_stmt_mutable () : close_portal_stmt_mutable = {
  portalname = "";
}

type fetch_stmt_mutable = {
  mutable direction : fetch_direction;
  mutable how_many : int64;
  mutable portalname : string;
  mutable ismove : bool;
}

let default_fetch_stmt_mutable () : fetch_stmt_mutable = {
  direction = default_fetch_direction ();
  how_many = 0L;
  portalname = "";
  ismove = false;
}

type notify_stmt_mutable = {
  mutable conditionname : string;
  mutable payload : string;
}

let default_notify_stmt_mutable () : notify_stmt_mutable = {
  conditionname = "";
  payload = "";
}

type listen_stmt_mutable = {
  mutable conditionname : string;
}

let default_listen_stmt_mutable () : listen_stmt_mutable = {
  conditionname = "";
}

type unlisten_stmt_mutable = {
  mutable conditionname : string;
}

let default_unlisten_stmt_mutable () : unlisten_stmt_mutable = {
  conditionname = "";
}

type load_stmt_mutable = {
  mutable filename : string;
}

let default_load_stmt_mutable () : load_stmt_mutable = {
  filename = "";
}

type variable_show_stmt_mutable = {
  mutable name : string;
}

let default_variable_show_stmt_mutable () : variable_show_stmt_mutable = {
  name = "";
}

type discard_stmt_mutable = {
  mutable target : discard_mode;
}

let default_discard_stmt_mutable () : discard_stmt_mutable = {
  target = default_discard_mode ();
}

type deallocate_stmt_mutable = {
  mutable name : string;
}

let default_deallocate_stmt_mutable () : deallocate_stmt_mutable = {
  name = "";
}

type drop_table_space_stmt_mutable = {
  mutable tablespacename : string;
  mutable missing_ok : bool;
}

let default_drop_table_space_stmt_mutable () : drop_table_space_stmt_mutable = {
  tablespacename = "";
  missing_ok = false;
}

type drop_user_mapping_stmt_mutable = {
  mutable user : role_spec option;
  mutable servername : string;
  mutable missing_ok : bool;
}

let default_drop_user_mapping_stmt_mutable () : drop_user_mapping_stmt_mutable = {
  user = None;
  servername = "";
  missing_ok = false;
}

type alter_event_trig_stmt_mutable = {
  mutable trigname : string;
  mutable tgenabled : string;
}

let default_alter_event_trig_stmt_mutable () : alter_event_trig_stmt_mutable = {
  trigname = "";
  tgenabled = "";
}

type replica_identity_stmt_mutable = {
  mutable identity_type : string;
  mutable name : string;
}

let default_replica_identity_stmt_mutable () : replica_identity_stmt_mutable = {
  identity_type = "";
  name = "";
}

type drop_subscription_stmt_mutable = {
  mutable subname : string;
  mutable missing_ok : bool;
  mutable behavior : drop_behavior;
}

let default_drop_subscription_stmt_mutable () : drop_subscription_stmt_mutable = {
  subname = "";
  missing_ok = false;
  behavior = default_drop_behavior ();
}

type param_ref_mutable = {
  mutable number : int32;
  mutable location : int32;
}

let default_param_ref_mutable () : param_ref_mutable = {
  number = 0l;
  location = 0l;
}

type sort_group_clause_mutable = {
  mutable tle_sort_group_ref : int32;
  mutable eqop : int32;
  mutable sortop : int32;
  mutable nulls_first : bool;
  mutable hashable : bool;
}

let default_sort_group_clause_mutable () : sort_group_clause_mutable = {
  tle_sort_group_ref = 0l;
  eqop = 0l;
  sortop = 0l;
  nulls_first = false;
  hashable = false;
}

type row_mark_clause_mutable = {
  mutable rti : int32;
  mutable strength : lock_clause_strength;
  mutable wait_policy : lock_wait_policy;
  mutable pushed_down : bool;
}

let default_row_mark_clause_mutable () : row_mark_clause_mutable = {
  rti = 0l;
  strength = default_lock_clause_strength ();
  wait_policy = default_lock_wait_policy ();
  pushed_down = false;
}

type trigger_transition_mutable = {
  mutable name : string;
  mutable is_new : bool;
  mutable is_table : bool;
}

let default_trigger_transition_mutable () : trigger_transition_mutable = {
  name = "";
  is_new = false;
  is_table = false;
}

type inline_code_block_mutable = {
  mutable source_text : string;
  mutable lang_oid : int32;
  mutable lang_is_trusted : bool;
  mutable atomic : bool;
}

let default_inline_code_block_mutable () : inline_code_block_mutable = {
  source_text = "";
  lang_oid = 0l;
  lang_is_trusted = false;
  atomic = false;
}

type call_context_mutable = {
  mutable atomic : bool;
}

let default_call_context_mutable () : call_context_mutable = {
  atomic = false;
}

type integer_mutable = {
  mutable ival : int32;
}

let default_integer_mutable () : integer_mutable = {
  ival = 0l;
}

type pgfloat_mutable = {
  mutable str : string;
}

let default_pgfloat_mutable () : pgfloat_mutable = {
  str = "";
}

type pgstring_mutable = {
  mutable str : string;
}

let default_pgstring_mutable () : pgstring_mutable = {
  str = "";
}

type bit_string_mutable = {
  mutable str : string;
}

let default_bit_string_mutable () : bit_string_mutable = {
  str = "";
}

type raw_stmt_mutable = {
  mutable stmt : node option;
  mutable stmt_location : int32;
  mutable stmt_len : int32;
}

let default_raw_stmt_mutable () : raw_stmt_mutable = {
  stmt = None;
  stmt_location = 0l;
  stmt_len = 0l;
}

type alias_mutable = {
  mutable aliasname : string;
  mutable colnames : node list;
}

let default_alias_mutable () : alias_mutable = {
  aliasname = "";
  colnames = [];
}

type range_var_mutable = {
  mutable catalogname : string;
  mutable schemaname : string;
  mutable relname : string;
  mutable inh : bool;
  mutable relpersistence : string;
  mutable alias : alias option;
  mutable location : int32;
}

let default_range_var_mutable () : range_var_mutable = {
  catalogname = "";
  schemaname = "";
  relname = "";
  inh = false;
  relpersistence = "";
  alias = None;
  location = 0l;
}

type table_func_mutable = {
  mutable ns_uris : node list;
  mutable ns_names : node list;
  mutable docexpr : node option;
  mutable rowexpr : node option;
  mutable colnames : node list;
  mutable coltypes : node list;
  mutable coltypmods : node list;
  mutable colcollations : node list;
  mutable colexprs : node list;
  mutable coldefexprs : node list;
  mutable notnulls : int64 list;
  mutable ordinalitycol : int32;
  mutable location : int32;
}

let default_table_func_mutable () : table_func_mutable = {
  ns_uris = [];
  ns_names = [];
  docexpr = None;
  rowexpr = None;
  colnames = [];
  coltypes = [];
  coltypmods = [];
  colcollations = [];
  colexprs = [];
  coldefexprs = [];
  notnulls = [];
  ordinalitycol = 0l;
  location = 0l;
}

type var_mutable = {
  mutable xpr : node option;
  mutable varno : int32;
  mutable varattno : int32;
  mutable vartype : int32;
  mutable vartypmod : int32;
  mutable varcollid : int32;
  mutable varlevelsup : int32;
  mutable varnosyn : int32;
  mutable varattnosyn : int32;
  mutable location : int32;
}

let default_var_mutable () : var_mutable = {
  xpr = None;
  varno = 0l;
  varattno = 0l;
  vartype = 0l;
  vartypmod = 0l;
  varcollid = 0l;
  varlevelsup = 0l;
  varnosyn = 0l;
  varattnosyn = 0l;
  location = 0l;
}

type param_mutable = {
  mutable xpr : node option;
  mutable paramkind : param_kind;
  mutable paramid : int32;
  mutable paramtype : int32;
  mutable paramtypmod : int32;
  mutable paramcollid : int32;
  mutable location : int32;
}

let default_param_mutable () : param_mutable = {
  xpr = None;
  paramkind = default_param_kind ();
  paramid = 0l;
  paramtype = 0l;
  paramtypmod = 0l;
  paramcollid = 0l;
  location = 0l;
}

type aggref_mutable = {
  mutable xpr : node option;
  mutable aggfnoid : int32;
  mutable aggtype : int32;
  mutable aggcollid : int32;
  mutable inputcollid : int32;
  mutable aggtranstype : int32;
  mutable aggargtypes : node list;
  mutable aggdirectargs : node list;
  mutable args : node list;
  mutable aggorder : node list;
  mutable aggdistinct : node list;
  mutable aggfilter : node option;
  mutable aggstar : bool;
  mutable aggvariadic : bool;
  mutable aggkind : string;
  mutable agglevelsup : int32;
  mutable aggsplit : agg_split;
  mutable location : int32;
}

let default_aggref_mutable () : aggref_mutable = {
  xpr = None;
  aggfnoid = 0l;
  aggtype = 0l;
  aggcollid = 0l;
  inputcollid = 0l;
  aggtranstype = 0l;
  aggargtypes = [];
  aggdirectargs = [];
  args = [];
  aggorder = [];
  aggdistinct = [];
  aggfilter = None;
  aggstar = false;
  aggvariadic = false;
  aggkind = "";
  agglevelsup = 0l;
  aggsplit = default_agg_split ();
  location = 0l;
}

type grouping_func_mutable = {
  mutable xpr : node option;
  mutable args : node list;
  mutable refs : node list;
  mutable cols : node list;
  mutable agglevelsup : int32;
  mutable location : int32;
}

let default_grouping_func_mutable () : grouping_func_mutable = {
  xpr = None;
  args = [];
  refs = [];
  cols = [];
  agglevelsup = 0l;
  location = 0l;
}

type window_func_mutable = {
  mutable xpr : node option;
  mutable winfnoid : int32;
  mutable wintype : int32;
  mutable wincollid : int32;
  mutable inputcollid : int32;
  mutable args : node list;
  mutable aggfilter : node option;
  mutable winref : int32;
  mutable winstar : bool;
  mutable winagg : bool;
  mutable location : int32;
}

let default_window_func_mutable () : window_func_mutable = {
  xpr = None;
  winfnoid = 0l;
  wintype = 0l;
  wincollid = 0l;
  inputcollid = 0l;
  args = [];
  aggfilter = None;
  winref = 0l;
  winstar = false;
  winagg = false;
  location = 0l;
}

type subscripting_ref_mutable = {
  mutable xpr : node option;
  mutable refcontainertype : int32;
  mutable refelemtype : int32;
  mutable reftypmod : int32;
  mutable refcollid : int32;
  mutable refupperindexpr : node list;
  mutable reflowerindexpr : node list;
  mutable refexpr : node option;
  mutable refassgnexpr : node option;
}

let default_subscripting_ref_mutable () : subscripting_ref_mutable = {
  xpr = None;
  refcontainertype = 0l;
  refelemtype = 0l;
  reftypmod = 0l;
  refcollid = 0l;
  refupperindexpr = [];
  reflowerindexpr = [];
  refexpr = None;
  refassgnexpr = None;
}

type func_expr_mutable = {
  mutable xpr : node option;
  mutable funcid : int32;
  mutable funcresulttype : int32;
  mutable funcretset : bool;
  mutable funcvariadic : bool;
  mutable funcformat : coercion_form;
  mutable funccollid : int32;
  mutable inputcollid : int32;
  mutable args : node list;
  mutable location : int32;
}

let default_func_expr_mutable () : func_expr_mutable = {
  xpr = None;
  funcid = 0l;
  funcresulttype = 0l;
  funcretset = false;
  funcvariadic = false;
  funcformat = default_coercion_form ();
  funccollid = 0l;
  inputcollid = 0l;
  args = [];
  location = 0l;
}

type named_arg_expr_mutable = {
  mutable xpr : node option;
  mutable arg : node option;
  mutable name : string;
  mutable argnumber : int32;
  mutable location : int32;
}

let default_named_arg_expr_mutable () : named_arg_expr_mutable = {
  xpr = None;
  arg = None;
  name = "";
  argnumber = 0l;
  location = 0l;
}

type op_expr_mutable = {
  mutable xpr : node option;
  mutable opno : int32;
  mutable opfuncid : int32;
  mutable opresulttype : int32;
  mutable opretset : bool;
  mutable opcollid : int32;
  mutable inputcollid : int32;
  mutable args : node list;
  mutable location : int32;
}

let default_op_expr_mutable () : op_expr_mutable = {
  xpr = None;
  opno = 0l;
  opfuncid = 0l;
  opresulttype = 0l;
  opretset = false;
  opcollid = 0l;
  inputcollid = 0l;
  args = [];
  location = 0l;
}

type distinct_expr_mutable = {
  mutable xpr : node option;
  mutable opno : int32;
  mutable opfuncid : int32;
  mutable opresulttype : int32;
  mutable opretset : bool;
  mutable opcollid : int32;
  mutable inputcollid : int32;
  mutable args : node list;
  mutable location : int32;
}

let default_distinct_expr_mutable () : distinct_expr_mutable = {
  xpr = None;
  opno = 0l;
  opfuncid = 0l;
  opresulttype = 0l;
  opretset = false;
  opcollid = 0l;
  inputcollid = 0l;
  args = [];
  location = 0l;
}

type null_if_expr_mutable = {
  mutable xpr : node option;
  mutable opno : int32;
  mutable opfuncid : int32;
  mutable opresulttype : int32;
  mutable opretset : bool;
  mutable opcollid : int32;
  mutable inputcollid : int32;
  mutable args : node list;
  mutable location : int32;
}

let default_null_if_expr_mutable () : null_if_expr_mutable = {
  xpr = None;
  opno = 0l;
  opfuncid = 0l;
  opresulttype = 0l;
  opretset = false;
  opcollid = 0l;
  inputcollid = 0l;
  args = [];
  location = 0l;
}

type scalar_array_op_expr_mutable = {
  mutable xpr : node option;
  mutable opno : int32;
  mutable opfuncid : int32;
  mutable use_or : bool;
  mutable inputcollid : int32;
  mutable args : node list;
  mutable location : int32;
}

let default_scalar_array_op_expr_mutable () : scalar_array_op_expr_mutable = {
  xpr = None;
  opno = 0l;
  opfuncid = 0l;
  use_or = false;
  inputcollid = 0l;
  args = [];
  location = 0l;
}

type bool_expr_mutable = {
  mutable xpr : node option;
  mutable boolop : bool_expr_type;
  mutable args : node list;
  mutable location : int32;
}

let default_bool_expr_mutable () : bool_expr_mutable = {
  xpr = None;
  boolop = default_bool_expr_type ();
  args = [];
  location = 0l;
}

type sub_link_mutable = {
  mutable xpr : node option;
  mutable sub_link_type : sub_link_type;
  mutable sub_link_id : int32;
  mutable testexpr : node option;
  mutable oper_name : node list;
  mutable subselect : node option;
  mutable location : int32;
}

let default_sub_link_mutable () : sub_link_mutable = {
  xpr = None;
  sub_link_type = default_sub_link_type ();
  sub_link_id = 0l;
  testexpr = None;
  oper_name = [];
  subselect = None;
  location = 0l;
}

type sub_plan_mutable = {
  mutable xpr : node option;
  mutable sub_link_type : sub_link_type;
  mutable testexpr : node option;
  mutable param_ids : node list;
  mutable plan_id : int32;
  mutable plan_name : string;
  mutable first_col_type : int32;
  mutable first_col_typmod : int32;
  mutable first_col_collation : int32;
  mutable use_hash_table : bool;
  mutable unknown_eq_false : bool;
  mutable parallel_safe : bool;
  mutable set_param : node list;
  mutable par_param : node list;
  mutable args : node list;
  mutable startup_cost : float;
  mutable per_call_cost : float;
}

let default_sub_plan_mutable () : sub_plan_mutable = {
  xpr = None;
  sub_link_type = default_sub_link_type ();
  testexpr = None;
  param_ids = [];
  plan_id = 0l;
  plan_name = "";
  first_col_type = 0l;
  first_col_typmod = 0l;
  first_col_collation = 0l;
  use_hash_table = false;
  unknown_eq_false = false;
  parallel_safe = false;
  set_param = [];
  par_param = [];
  args = [];
  startup_cost = 0.;
  per_call_cost = 0.;
}

type alternative_sub_plan_mutable = {
  mutable xpr : node option;
  mutable subplans : node list;
}

let default_alternative_sub_plan_mutable () : alternative_sub_plan_mutable = {
  xpr = None;
  subplans = [];
}

type field_select_mutable = {
  mutable xpr : node option;
  mutable arg : node option;
  mutable fieldnum : int32;
  mutable resulttype : int32;
  mutable resulttypmod : int32;
  mutable resultcollid : int32;
}

let default_field_select_mutable () : field_select_mutable = {
  xpr = None;
  arg = None;
  fieldnum = 0l;
  resulttype = 0l;
  resulttypmod = 0l;
  resultcollid = 0l;
}

type field_store_mutable = {
  mutable xpr : node option;
  mutable arg : node option;
  mutable newvals : node list;
  mutable fieldnums : node list;
  mutable resulttype : int32;
}

let default_field_store_mutable () : field_store_mutable = {
  xpr = None;
  arg = None;
  newvals = [];
  fieldnums = [];
  resulttype = 0l;
}

type relabel_type_mutable = {
  mutable xpr : node option;
  mutable arg : node option;
  mutable resulttype : int32;
  mutable resulttypmod : int32;
  mutable resultcollid : int32;
  mutable relabelformat : coercion_form;
  mutable location : int32;
}

let default_relabel_type_mutable () : relabel_type_mutable = {
  xpr = None;
  arg = None;
  resulttype = 0l;
  resulttypmod = 0l;
  resultcollid = 0l;
  relabelformat = default_coercion_form ();
  location = 0l;
}

type coerce_via_io_mutable = {
  mutable xpr : node option;
  mutable arg : node option;
  mutable resulttype : int32;
  mutable resultcollid : int32;
  mutable coerceformat : coercion_form;
  mutable location : int32;
}

let default_coerce_via_io_mutable () : coerce_via_io_mutable = {
  xpr = None;
  arg = None;
  resulttype = 0l;
  resultcollid = 0l;
  coerceformat = default_coercion_form ();
  location = 0l;
}

type array_coerce_expr_mutable = {
  mutable xpr : node option;
  mutable arg : node option;
  mutable elemexpr : node option;
  mutable resulttype : int32;
  mutable resulttypmod : int32;
  mutable resultcollid : int32;
  mutable coerceformat : coercion_form;
  mutable location : int32;
}

let default_array_coerce_expr_mutable () : array_coerce_expr_mutable = {
  xpr = None;
  arg = None;
  elemexpr = None;
  resulttype = 0l;
  resulttypmod = 0l;
  resultcollid = 0l;
  coerceformat = default_coercion_form ();
  location = 0l;
}

type convert_rowtype_expr_mutable = {
  mutable xpr : node option;
  mutable arg : node option;
  mutable resulttype : int32;
  mutable convertformat : coercion_form;
  mutable location : int32;
}

let default_convert_rowtype_expr_mutable () : convert_rowtype_expr_mutable = {
  xpr = None;
  arg = None;
  resulttype = 0l;
  convertformat = default_coercion_form ();
  location = 0l;
}

type collate_expr_mutable = {
  mutable xpr : node option;
  mutable arg : node option;
  mutable coll_oid : int32;
  mutable location : int32;
}

let default_collate_expr_mutable () : collate_expr_mutable = {
  xpr = None;
  arg = None;
  coll_oid = 0l;
  location = 0l;
}

type case_expr_mutable = {
  mutable xpr : node option;
  mutable casetype : int32;
  mutable casecollid : int32;
  mutable arg : node option;
  mutable args : node list;
  mutable defresult : node option;
  mutable location : int32;
}

let default_case_expr_mutable () : case_expr_mutable = {
  xpr = None;
  casetype = 0l;
  casecollid = 0l;
  arg = None;
  args = [];
  defresult = None;
  location = 0l;
}

type case_when_mutable = {
  mutable xpr : node option;
  mutable expr : node option;
  mutable result : node option;
  mutable location : int32;
}

let default_case_when_mutable () : case_when_mutable = {
  xpr = None;
  expr = None;
  result = None;
  location = 0l;
}

type case_test_expr_mutable = {
  mutable xpr : node option;
  mutable type_id : int32;
  mutable type_mod : int32;
  mutable collation : int32;
}

let default_case_test_expr_mutable () : case_test_expr_mutable = {
  xpr = None;
  type_id = 0l;
  type_mod = 0l;
  collation = 0l;
}

type array_expr_mutable = {
  mutable xpr : node option;
  mutable array_typeid : int32;
  mutable array_collid : int32;
  mutable element_typeid : int32;
  mutable elements : node list;
  mutable multidims : bool;
  mutable location : int32;
}

let default_array_expr_mutable () : array_expr_mutable = {
  xpr = None;
  array_typeid = 0l;
  array_collid = 0l;
  element_typeid = 0l;
  elements = [];
  multidims = false;
  location = 0l;
}

type row_expr_mutable = {
  mutable xpr : node option;
  mutable args : node list;
  mutable row_typeid : int32;
  mutable row_format : coercion_form;
  mutable colnames : node list;
  mutable location : int32;
}

let default_row_expr_mutable () : row_expr_mutable = {
  xpr = None;
  args = [];
  row_typeid = 0l;
  row_format = default_coercion_form ();
  colnames = [];
  location = 0l;
}

type row_compare_expr_mutable = {
  mutable xpr : node option;
  mutable rctype : row_compare_type;
  mutable opnos : node list;
  mutable opfamilies : node list;
  mutable inputcollids : node list;
  mutable largs : node list;
  mutable rargs : node list;
}

let default_row_compare_expr_mutable () : row_compare_expr_mutable = {
  xpr = None;
  rctype = default_row_compare_type ();
  opnos = [];
  opfamilies = [];
  inputcollids = [];
  largs = [];
  rargs = [];
}

type coalesce_expr_mutable = {
  mutable xpr : node option;
  mutable coalescetype : int32;
  mutable coalescecollid : int32;
  mutable args : node list;
  mutable location : int32;
}

let default_coalesce_expr_mutable () : coalesce_expr_mutable = {
  xpr = None;
  coalescetype = 0l;
  coalescecollid = 0l;
  args = [];
  location = 0l;
}

type min_max_expr_mutable = {
  mutable xpr : node option;
  mutable minmaxtype : int32;
  mutable minmaxcollid : int32;
  mutable inputcollid : int32;
  mutable op : min_max_op;
  mutable args : node list;
  mutable location : int32;
}

let default_min_max_expr_mutable () : min_max_expr_mutable = {
  xpr = None;
  minmaxtype = 0l;
  minmaxcollid = 0l;
  inputcollid = 0l;
  op = default_min_max_op ();
  args = [];
  location = 0l;
}

type sqlvalue_function_mutable = {
  mutable xpr : node option;
  mutable op : sqlvalue_function_op;
  mutable type_ : int32;
  mutable typmod : int32;
  mutable location : int32;
}

let default_sqlvalue_function_mutable () : sqlvalue_function_mutable = {
  xpr = None;
  op = default_sqlvalue_function_op ();
  type_ = 0l;
  typmod = 0l;
  location = 0l;
}

type xml_expr_mutable = {
  mutable xpr : node option;
  mutable op : xml_expr_op;
  mutable name : string;
  mutable named_args : node list;
  mutable arg_names : node list;
  mutable args : node list;
  mutable xmloption : xml_option_type;
  mutable type_ : int32;
  mutable typmod : int32;
  mutable location : int32;
}

let default_xml_expr_mutable () : xml_expr_mutable = {
  xpr = None;
  op = default_xml_expr_op ();
  name = "";
  named_args = [];
  arg_names = [];
  args = [];
  xmloption = default_xml_option_type ();
  type_ = 0l;
  typmod = 0l;
  location = 0l;
}

type null_test_mutable = {
  mutable xpr : node option;
  mutable arg : node option;
  mutable nulltesttype : null_test_type;
  mutable argisrow : bool;
  mutable location : int32;
}

let default_null_test_mutable () : null_test_mutable = {
  xpr = None;
  arg = None;
  nulltesttype = default_null_test_type ();
  argisrow = false;
  location = 0l;
}

type boolean_test_mutable = {
  mutable xpr : node option;
  mutable arg : node option;
  mutable booltesttype : bool_test_type;
  mutable location : int32;
}

let default_boolean_test_mutable () : boolean_test_mutable = {
  xpr = None;
  arg = None;
  booltesttype = default_bool_test_type ();
  location = 0l;
}

type coerce_to_domain_mutable = {
  mutable xpr : node option;
  mutable arg : node option;
  mutable resulttype : int32;
  mutable resulttypmod : int32;
  mutable resultcollid : int32;
  mutable coercionformat : coercion_form;
  mutable location : int32;
}

let default_coerce_to_domain_mutable () : coerce_to_domain_mutable = {
  xpr = None;
  arg = None;
  resulttype = 0l;
  resulttypmod = 0l;
  resultcollid = 0l;
  coercionformat = default_coercion_form ();
  location = 0l;
}

type coerce_to_domain_value_mutable = {
  mutable xpr : node option;
  mutable type_id : int32;
  mutable type_mod : int32;
  mutable collation : int32;
  mutable location : int32;
}

let default_coerce_to_domain_value_mutable () : coerce_to_domain_value_mutable = {
  xpr = None;
  type_id = 0l;
  type_mod = 0l;
  collation = 0l;
  location = 0l;
}

type set_to_default_mutable = {
  mutable xpr : node option;
  mutable type_id : int32;
  mutable type_mod : int32;
  mutable collation : int32;
  mutable location : int32;
}

let default_set_to_default_mutable () : set_to_default_mutable = {
  xpr = None;
  type_id = 0l;
  type_mod = 0l;
  collation = 0l;
  location = 0l;
}

type current_of_expr_mutable = {
  mutable xpr : node option;
  mutable cvarno : int32;
  mutable cursor_name : string;
  mutable cursor_param : int32;
}

let default_current_of_expr_mutable () : current_of_expr_mutable = {
  xpr = None;
  cvarno = 0l;
  cursor_name = "";
  cursor_param = 0l;
}

type next_value_expr_mutable = {
  mutable xpr : node option;
  mutable seqid : int32;
  mutable type_id : int32;
}

let default_next_value_expr_mutable () : next_value_expr_mutable = {
  xpr = None;
  seqid = 0l;
  type_id = 0l;
}

type inference_elem_mutable = {
  mutable xpr : node option;
  mutable expr : node option;
  mutable infercollid : int32;
  mutable inferopclass : int32;
}

let default_inference_elem_mutable () : inference_elem_mutable = {
  xpr = None;
  expr = None;
  infercollid = 0l;
  inferopclass = 0l;
}

type target_entry_mutable = {
  mutable xpr : node option;
  mutable expr : node option;
  mutable resno : int32;
  mutable resname : string;
  mutable ressortgroupref : int32;
  mutable resorigtbl : int32;
  mutable resorigcol : int32;
  mutable resjunk : bool;
}

let default_target_entry_mutable () : target_entry_mutable = {
  xpr = None;
  expr = None;
  resno = 0l;
  resname = "";
  ressortgroupref = 0l;
  resorigtbl = 0l;
  resorigcol = 0l;
  resjunk = false;
}

type join_expr_mutable = {
  mutable jointype : join_type;
  mutable is_natural : bool;
  mutable larg : node option;
  mutable rarg : node option;
  mutable using_clause : node list;
  mutable quals : node option;
  mutable alias : alias option;
  mutable rtindex : int32;
}

let default_join_expr_mutable () : join_expr_mutable = {
  jointype = default_join_type ();
  is_natural = false;
  larg = None;
  rarg = None;
  using_clause = [];
  quals = None;
  alias = None;
  rtindex = 0l;
}

type from_expr_mutable = {
  mutable fromlist : node list;
  mutable quals : node option;
}

let default_from_expr_mutable () : from_expr_mutable = {
  fromlist = [];
  quals = None;
}

type on_conflict_expr_mutable = {
  mutable action : on_conflict_action;
  mutable arbiter_elems : node list;
  mutable arbiter_where : node option;
  mutable constraint_ : int32;
  mutable on_conflict_set : node list;
  mutable on_conflict_where : node option;
  mutable excl_rel_index : int32;
  mutable excl_rel_tlist : node list;
}

let default_on_conflict_expr_mutable () : on_conflict_expr_mutable = {
  action = default_on_conflict_action ();
  arbiter_elems = [];
  arbiter_where = None;
  constraint_ = 0l;
  on_conflict_set = [];
  on_conflict_where = None;
  excl_rel_index = 0l;
  excl_rel_tlist = [];
}

type into_clause_mutable = {
  mutable rel : range_var option;
  mutable col_names : node list;
  mutable access_method : string;
  mutable options : node list;
  mutable on_commit : on_commit_action;
  mutable table_space_name : string;
  mutable view_query : node option;
  mutable skip_data : bool;
}

let default_into_clause_mutable () : into_clause_mutable = {
  rel = None;
  col_names = [];
  access_method = "";
  options = [];
  on_commit = default_on_commit_action ();
  table_space_name = "";
  view_query = None;
  skip_data = false;
}

type query_mutable = {
  mutable command_type : cmd_type;
  mutable query_source : query_source;
  mutable can_set_tag : bool;
  mutable utility_stmt : node option;
  mutable result_relation : int32;
  mutable has_aggs : bool;
  mutable has_window_funcs : bool;
  mutable has_target_srfs : bool;
  mutable has_sub_links : bool;
  mutable has_distinct_on : bool;
  mutable has_recursive : bool;
  mutable has_modifying_cte : bool;
  mutable has_for_update : bool;
  mutable has_row_security : bool;
  mutable cte_list : node list;
  mutable rtable : node list;
  mutable jointree : from_expr option;
  mutable target_list : node list;
  mutable override : overriding_kind;
  mutable on_conflict : on_conflict_expr option;
  mutable returning_list : node list;
  mutable group_clause : node list;
  mutable grouping_sets : node list;
  mutable having_qual : node option;
  mutable window_clause : node list;
  mutable distinct_clause : node list;
  mutable sort_clause : node list;
  mutable limit_offset : node option;
  mutable limit_count : node option;
  mutable limit_option : limit_option;
  mutable row_marks : node list;
  mutable set_operations : node option;
  mutable constraint_deps : node list;
  mutable with_check_options : node list;
  mutable stmt_location : int32;
  mutable stmt_len : int32;
}

let default_query_mutable () : query_mutable = {
  command_type = default_cmd_type ();
  query_source = default_query_source ();
  can_set_tag = false;
  utility_stmt = None;
  result_relation = 0l;
  has_aggs = false;
  has_window_funcs = false;
  has_target_srfs = false;
  has_sub_links = false;
  has_distinct_on = false;
  has_recursive = false;
  has_modifying_cte = false;
  has_for_update = false;
  has_row_security = false;
  cte_list = [];
  rtable = [];
  jointree = None;
  target_list = [];
  override = default_overriding_kind ();
  on_conflict = None;
  returning_list = [];
  group_clause = [];
  grouping_sets = [];
  having_qual = None;
  window_clause = [];
  distinct_clause = [];
  sort_clause = [];
  limit_offset = None;
  limit_count = None;
  limit_option = default_limit_option ();
  row_marks = [];
  set_operations = None;
  constraint_deps = [];
  with_check_options = [];
  stmt_location = 0l;
  stmt_len = 0l;
}

type insert_stmt_mutable = {
  mutable relation : range_var option;
  mutable cols : node list;
  mutable select_stmt : node option;
  mutable on_conflict_clause : on_conflict_clause option;
  mutable returning_list : node list;
  mutable with_clause : with_clause option;
  mutable override : overriding_kind;
}

let default_insert_stmt_mutable () : insert_stmt_mutable = {
  relation = None;
  cols = [];
  select_stmt = None;
  on_conflict_clause = None;
  returning_list = [];
  with_clause = None;
  override = default_overriding_kind ();
}

type on_conflict_clause_mutable = {
  mutable action : on_conflict_action;
  mutable infer : infer_clause option;
  mutable target_list : node list;
  mutable where_clause : node option;
  mutable location : int32;
}

let default_on_conflict_clause_mutable () : on_conflict_clause_mutable = {
  action = default_on_conflict_action ();
  infer = None;
  target_list = [];
  where_clause = None;
  location = 0l;
}

type infer_clause_mutable = {
  mutable index_elems : node list;
  mutable where_clause : node option;
  mutable conname : string;
  mutable location : int32;
}

let default_infer_clause_mutable () : infer_clause_mutable = {
  index_elems = [];
  where_clause = None;
  conname = "";
  location = 0l;
}

type with_clause_mutable = {
  mutable ctes : node list;
  mutable recursive : bool;
  mutable location : int32;
}

let default_with_clause_mutable () : with_clause_mutable = {
  ctes = [];
  recursive = false;
  location = 0l;
}

type delete_stmt_mutable = {
  mutable relation : range_var option;
  mutable using_clause : node list;
  mutable where_clause : node option;
  mutable returning_list : node list;
  mutable with_clause : with_clause option;
}

let default_delete_stmt_mutable () : delete_stmt_mutable = {
  relation = None;
  using_clause = [];
  where_clause = None;
  returning_list = [];
  with_clause = None;
}

type update_stmt_mutable = {
  mutable relation : range_var option;
  mutable target_list : node list;
  mutable where_clause : node option;
  mutable from_clause : node list;
  mutable returning_list : node list;
  mutable with_clause : with_clause option;
}

let default_update_stmt_mutable () : update_stmt_mutable = {
  relation = None;
  target_list = [];
  where_clause = None;
  from_clause = [];
  returning_list = [];
  with_clause = None;
}

type select_stmt_mutable = {
  mutable distinct_clause : node list;
  mutable into_clause : into_clause option;
  mutable target_list : node list;
  mutable from_clause : node list;
  mutable where_clause : node option;
  mutable group_clause : node list;
  mutable having_clause : node option;
  mutable window_clause : node list;
  mutable values_lists : node list;
  mutable sort_clause : node list;
  mutable limit_offset : node option;
  mutable limit_count : node option;
  mutable limit_option : limit_option;
  mutable locking_clause : node list;
  mutable with_clause : with_clause option;
  mutable op : set_operation;
  mutable all : bool;
  mutable larg : select_stmt option;
  mutable rarg : select_stmt option;
}

let default_select_stmt_mutable () : select_stmt_mutable = {
  distinct_clause = [];
  into_clause = None;
  target_list = [];
  from_clause = [];
  where_clause = None;
  group_clause = [];
  having_clause = None;
  window_clause = [];
  values_lists = [];
  sort_clause = [];
  limit_offset = None;
  limit_count = None;
  limit_option = default_limit_option ();
  locking_clause = [];
  with_clause = None;
  op = default_set_operation ();
  all = false;
  larg = None;
  rarg = None;
}

type alter_table_stmt_mutable = {
  mutable relation : range_var option;
  mutable cmds : node list;
  mutable relkind : object_type;
  mutable missing_ok : bool;
}

let default_alter_table_stmt_mutable () : alter_table_stmt_mutable = {
  relation = None;
  cmds = [];
  relkind = default_object_type ();
  missing_ok = false;
}

type alter_table_cmd_mutable = {
  mutable subtype : alter_table_type;
  mutable name : string;
  mutable num : int32;
  mutable newowner : role_spec option;
  mutable def : node option;
  mutable behavior : drop_behavior;
  mutable missing_ok : bool;
  mutable recurse : bool;
}

let default_alter_table_cmd_mutable () : alter_table_cmd_mutable = {
  subtype = default_alter_table_type ();
  name = "";
  num = 0l;
  newowner = None;
  def = None;
  behavior = default_drop_behavior ();
  missing_ok = false;
  recurse = false;
}

type alter_domain_stmt_mutable = {
  mutable subtype : string;
  mutable type_name : node list;
  mutable name : string;
  mutable def : node option;
  mutable behavior : drop_behavior;
  mutable missing_ok : bool;
}

let default_alter_domain_stmt_mutable () : alter_domain_stmt_mutable = {
  subtype = "";
  type_name = [];
  name = "";
  def = None;
  behavior = default_drop_behavior ();
  missing_ok = false;
}

type set_operation_stmt_mutable = {
  mutable op : set_operation;
  mutable all : bool;
  mutable larg : node option;
  mutable rarg : node option;
  mutable col_types : node list;
  mutable col_typmods : node list;
  mutable col_collations : node list;
  mutable group_clauses : node list;
}

let default_set_operation_stmt_mutable () : set_operation_stmt_mutable = {
  op = default_set_operation ();
  all = false;
  larg = None;
  rarg = None;
  col_types = [];
  col_typmods = [];
  col_collations = [];
  group_clauses = [];
}

type grant_stmt_mutable = {
  mutable is_grant : bool;
  mutable targtype : grant_target_type;
  mutable objtype : object_type;
  mutable objects : node list;
  mutable privileges : node list;
  mutable grantees : node list;
  mutable grant_option : bool;
  mutable behavior : drop_behavior;
}

let default_grant_stmt_mutable () : grant_stmt_mutable = {
  is_grant = false;
  targtype = default_grant_target_type ();
  objtype = default_object_type ();
  objects = [];
  privileges = [];
  grantees = [];
  grant_option = false;
  behavior = default_drop_behavior ();
}

type grant_role_stmt_mutable = {
  mutable granted_roles : node list;
  mutable grantee_roles : node list;
  mutable is_grant : bool;
  mutable admin_opt : bool;
  mutable grantor : role_spec option;
  mutable behavior : drop_behavior;
}

let default_grant_role_stmt_mutable () : grant_role_stmt_mutable = {
  granted_roles = [];
  grantee_roles = [];
  is_grant = false;
  admin_opt = false;
  grantor = None;
  behavior = default_drop_behavior ();
}

type alter_default_privileges_stmt_mutable = {
  mutable options : node list;
  mutable action : grant_stmt option;
}

let default_alter_default_privileges_stmt_mutable () : alter_default_privileges_stmt_mutable = {
  options = [];
  action = None;
}

type cluster_stmt_mutable = {
  mutable relation : range_var option;
  mutable indexname : string;
  mutable options : int32;
}

let default_cluster_stmt_mutable () : cluster_stmt_mutable = {
  relation = None;
  indexname = "";
  options = 0l;
}

type copy_stmt_mutable = {
  mutable relation : range_var option;
  mutable query : node option;
  mutable attlist : node list;
  mutable is_from : bool;
  mutable is_program : bool;
  mutable filename : string;
  mutable options : node list;
  mutable where_clause : node option;
}

let default_copy_stmt_mutable () : copy_stmt_mutable = {
  relation = None;
  query = None;
  attlist = [];
  is_from = false;
  is_program = false;
  filename = "";
  options = [];
  where_clause = None;
}

type create_stmt_mutable = {
  mutable relation : range_var option;
  mutable table_elts : node list;
  mutable inh_relations : node list;
  mutable partbound : partition_bound_spec option;
  mutable partspec : partition_spec option;
  mutable of_typename : type_name option;
  mutable constraints : node list;
  mutable options : node list;
  mutable oncommit : on_commit_action;
  mutable tablespacename : string;
  mutable access_method : string;
  mutable if_not_exists : bool;
}

let default_create_stmt_mutable () : create_stmt_mutable = {
  relation = None;
  table_elts = [];
  inh_relations = [];
  partbound = None;
  partspec = None;
  of_typename = None;
  constraints = [];
  options = [];
  oncommit = default_on_commit_action ();
  tablespacename = "";
  access_method = "";
  if_not_exists = false;
}

type partition_bound_spec_mutable = {
  mutable strategy : string;
  mutable is_default : bool;
  mutable modulus : int32;
  mutable remainder : int32;
  mutable listdatums : node list;
  mutable lowerdatums : node list;
  mutable upperdatums : node list;
  mutable location : int32;
}

let default_partition_bound_spec_mutable () : partition_bound_spec_mutable = {
  strategy = "";
  is_default = false;
  modulus = 0l;
  remainder = 0l;
  listdatums = [];
  lowerdatums = [];
  upperdatums = [];
  location = 0l;
}

type partition_spec_mutable = {
  mutable strategy : string;
  mutable part_params : node list;
  mutable location : int32;
}

let default_partition_spec_mutable () : partition_spec_mutable = {
  strategy = "";
  part_params = [];
  location = 0l;
}

type type_name_mutable = {
  mutable names : node list;
  mutable type_oid : int32;
  mutable setof : bool;
  mutable pct_type : bool;
  mutable typmods : node list;
  mutable typemod : int32;
  mutable array_bounds : node list;
  mutable location : int32;
}

let default_type_name_mutable () : type_name_mutable = {
  names = [];
  type_oid = 0l;
  setof = false;
  pct_type = false;
  typmods = [];
  typemod = 0l;
  array_bounds = [];
  location = 0l;
}

type define_stmt_mutable = {
  mutable kind : object_type;
  mutable oldstyle : bool;
  mutable defnames : node list;
  mutable args : node list;
  mutable definition : node list;
  mutable if_not_exists : bool;
  mutable replace : bool;
}

let default_define_stmt_mutable () : define_stmt_mutable = {
  kind = default_object_type ();
  oldstyle = false;
  defnames = [];
  args = [];
  definition = [];
  if_not_exists = false;
  replace = false;
}

type drop_stmt_mutable = {
  mutable objects : node list;
  mutable remove_type : object_type;
  mutable behavior : drop_behavior;
  mutable missing_ok : bool;
  mutable concurrent : bool;
}

let default_drop_stmt_mutable () : drop_stmt_mutable = {
  objects = [];
  remove_type = default_object_type ();
  behavior = default_drop_behavior ();
  missing_ok = false;
  concurrent = false;
}

type truncate_stmt_mutable = {
  mutable relations : node list;
  mutable restart_seqs : bool;
  mutable behavior : drop_behavior;
}

let default_truncate_stmt_mutable () : truncate_stmt_mutable = {
  relations = [];
  restart_seqs = false;
  behavior = default_drop_behavior ();
}

type comment_stmt_mutable = {
  mutable objtype : object_type;
  mutable object_ : node option;
  mutable comment : string;
}

let default_comment_stmt_mutable () : comment_stmt_mutable = {
  objtype = default_object_type ();
  object_ = None;
  comment = "";
}

type index_stmt_mutable = {
  mutable idxname : string;
  mutable relation : range_var option;
  mutable access_method : string;
  mutable table_space : string;
  mutable index_params : node list;
  mutable index_including_params : node list;
  mutable options : node list;
  mutable where_clause : node option;
  mutable exclude_op_names : node list;
  mutable idxcomment : string;
  mutable index_oid : int32;
  mutable old_node : int32;
  mutable old_create_subid : int32;
  mutable old_first_relfilenode_subid : int32;
  mutable unique : bool;
  mutable primary : bool;
  mutable isconstraint : bool;
  mutable deferrable : bool;
  mutable initdeferred : bool;
  mutable transformed : bool;
  mutable concurrent : bool;
  mutable if_not_exists : bool;
  mutable reset_default_tblspc : bool;
}

let default_index_stmt_mutable () : index_stmt_mutable = {
  idxname = "";
  relation = None;
  access_method = "";
  table_space = "";
  index_params = [];
  index_including_params = [];
  options = [];
  where_clause = None;
  exclude_op_names = [];
  idxcomment = "";
  index_oid = 0l;
  old_node = 0l;
  old_create_subid = 0l;
  old_first_relfilenode_subid = 0l;
  unique = false;
  primary = false;
  isconstraint = false;
  deferrable = false;
  initdeferred = false;
  transformed = false;
  concurrent = false;
  if_not_exists = false;
  reset_default_tblspc = false;
}

type create_function_stmt_mutable = {
  mutable is_procedure : bool;
  mutable replace : bool;
  mutable funcname : node list;
  mutable parameters : node list;
  mutable return_type : type_name option;
  mutable options : node list;
}

let default_create_function_stmt_mutable () : create_function_stmt_mutable = {
  is_procedure = false;
  replace = false;
  funcname = [];
  parameters = [];
  return_type = None;
  options = [];
}

type alter_function_stmt_mutable = {
  mutable objtype : object_type;
  mutable func : object_with_args option;
  mutable actions : node list;
}

let default_alter_function_stmt_mutable () : alter_function_stmt_mutable = {
  objtype = default_object_type ();
  func = None;
  actions = [];
}

type object_with_args_mutable = {
  mutable objname : node list;
  mutable objargs : node list;
  mutable args_unspecified : bool;
}

let default_object_with_args_mutable () : object_with_args_mutable = {
  objname = [];
  objargs = [];
  args_unspecified = false;
}

type do_stmt_mutable = {
  mutable args : node list;
}

let default_do_stmt_mutable () : do_stmt_mutable = {
  args = [];
}

type rename_stmt_mutable = {
  mutable rename_type : object_type;
  mutable relation_type : object_type;
  mutable relation : range_var option;
  mutable object_ : node option;
  mutable subname : string;
  mutable newname : string;
  mutable behavior : drop_behavior;
  mutable missing_ok : bool;
}

let default_rename_stmt_mutable () : rename_stmt_mutable = {
  rename_type = default_object_type ();
  relation_type = default_object_type ();
  relation = None;
  object_ = None;
  subname = "";
  newname = "";
  behavior = default_drop_behavior ();
  missing_ok = false;
}

type rule_stmt_mutable = {
  mutable relation : range_var option;
  mutable rulename : string;
  mutable where_clause : node option;
  mutable event : cmd_type;
  mutable instead : bool;
  mutable actions : node list;
  mutable replace : bool;
}

let default_rule_stmt_mutable () : rule_stmt_mutable = {
  relation = None;
  rulename = "";
  where_clause = None;
  event = default_cmd_type ();
  instead = false;
  actions = [];
  replace = false;
}

type transaction_stmt_mutable = {
  mutable kind : transaction_stmt_kind;
  mutable options : node list;
  mutable savepoint_name : string;
  mutable gid : string;
  mutable chain : bool;
}

let default_transaction_stmt_mutable () : transaction_stmt_mutable = {
  kind = default_transaction_stmt_kind ();
  options = [];
  savepoint_name = "";
  gid = "";
  chain = false;
}

type view_stmt_mutable = {
  mutable view : range_var option;
  mutable aliases : node list;
  mutable query : node option;
  mutable replace : bool;
  mutable options : node list;
  mutable with_check_option : view_check_option;
}

let default_view_stmt_mutable () : view_stmt_mutable = {
  view = None;
  aliases = [];
  query = None;
  replace = false;
  options = [];
  with_check_option = default_view_check_option ();
}

type create_domain_stmt_mutable = {
  mutable domainname : node list;
  mutable type_name : type_name option;
  mutable coll_clause : collate_clause option;
  mutable constraints : node list;
}

let default_create_domain_stmt_mutable () : create_domain_stmt_mutable = {
  domainname = [];
  type_name = None;
  coll_clause = None;
  constraints = [];
}

type collate_clause_mutable = {
  mutable arg : node option;
  mutable collname : node list;
  mutable location : int32;
}

let default_collate_clause_mutable () : collate_clause_mutable = {
  arg = None;
  collname = [];
  location = 0l;
}

type createdb_stmt_mutable = {
  mutable dbname : string;
  mutable options : node list;
}

let default_createdb_stmt_mutable () : createdb_stmt_mutable = {
  dbname = "";
  options = [];
}

type dropdb_stmt_mutable = {
  mutable dbname : string;
  mutable missing_ok : bool;
  mutable options : node list;
}

let default_dropdb_stmt_mutable () : dropdb_stmt_mutable = {
  dbname = "";
  missing_ok = false;
  options = [];
}

type vacuum_stmt_mutable = {
  mutable options : node list;
  mutable rels : node list;
  mutable is_vacuumcmd : bool;
}

let default_vacuum_stmt_mutable () : vacuum_stmt_mutable = {
  options = [];
  rels = [];
  is_vacuumcmd = false;
}

type explain_stmt_mutable = {
  mutable query : node option;
  mutable options : node list;
}

let default_explain_stmt_mutable () : explain_stmt_mutable = {
  query = None;
  options = [];
}

type create_table_as_stmt_mutable = {
  mutable query : node option;
  mutable into : into_clause option;
  mutable relkind : object_type;
  mutable is_select_into : bool;
  mutable if_not_exists : bool;
}

let default_create_table_as_stmt_mutable () : create_table_as_stmt_mutable = {
  query = None;
  into = None;
  relkind = default_object_type ();
  is_select_into = false;
  if_not_exists = false;
}

type create_seq_stmt_mutable = {
  mutable sequence : range_var option;
  mutable options : node list;
  mutable owner_id : int32;
  mutable for_identity : bool;
  mutable if_not_exists : bool;
}

let default_create_seq_stmt_mutable () : create_seq_stmt_mutable = {
  sequence = None;
  options = [];
  owner_id = 0l;
  for_identity = false;
  if_not_exists = false;
}

type alter_seq_stmt_mutable = {
  mutable sequence : range_var option;
  mutable options : node list;
  mutable for_identity : bool;
  mutable missing_ok : bool;
}

let default_alter_seq_stmt_mutable () : alter_seq_stmt_mutable = {
  sequence = None;
  options = [];
  for_identity = false;
  missing_ok = false;
}

type variable_set_stmt_mutable = {
  mutable kind : variable_set_kind;
  mutable name : string;
  mutable args : node list;
  mutable is_local : bool;
}

let default_variable_set_stmt_mutable () : variable_set_stmt_mutable = {
  kind = default_variable_set_kind ();
  name = "";
  args = [];
  is_local = false;
}

type create_trig_stmt_mutable = {
  mutable trigname : string;
  mutable relation : range_var option;
  mutable funcname : node list;
  mutable args : node list;
  mutable row : bool;
  mutable timing : int32;
  mutable events : int32;
  mutable columns : node list;
  mutable when_clause : node option;
  mutable isconstraint : bool;
  mutable transition_rels : node list;
  mutable deferrable : bool;
  mutable initdeferred : bool;
  mutable constrrel : range_var option;
}

let default_create_trig_stmt_mutable () : create_trig_stmt_mutable = {
  trigname = "";
  relation = None;
  funcname = [];
  args = [];
  row = false;
  timing = 0l;
  events = 0l;
  columns = [];
  when_clause = None;
  isconstraint = false;
  transition_rels = [];
  deferrable = false;
  initdeferred = false;
  constrrel = None;
}

type create_plang_stmt_mutable = {
  mutable replace : bool;
  mutable plname : string;
  mutable plhandler : node list;
  mutable plinline : node list;
  mutable plvalidator : node list;
  mutable pltrusted : bool;
}

let default_create_plang_stmt_mutable () : create_plang_stmt_mutable = {
  replace = false;
  plname = "";
  plhandler = [];
  plinline = [];
  plvalidator = [];
  pltrusted = false;
}

type create_role_stmt_mutable = {
  mutable stmt_type : role_stmt_type;
  mutable role : string;
  mutable options : node list;
}

let default_create_role_stmt_mutable () : create_role_stmt_mutable = {
  stmt_type = default_role_stmt_type ();
  role = "";
  options = [];
}

type alter_role_stmt_mutable = {
  mutable role : role_spec option;
  mutable options : node list;
  mutable action : int32;
}

let default_alter_role_stmt_mutable () : alter_role_stmt_mutable = {
  role = None;
  options = [];
  action = 0l;
}

type drop_role_stmt_mutable = {
  mutable roles : node list;
  mutable missing_ok : bool;
}

let default_drop_role_stmt_mutable () : drop_role_stmt_mutable = {
  roles = [];
  missing_ok = false;
}

type lock_stmt_mutable = {
  mutable relations : node list;
  mutable mode : int32;
  mutable nowait : bool;
}

let default_lock_stmt_mutable () : lock_stmt_mutable = {
  relations = [];
  mode = 0l;
  nowait = false;
}

type constraints_set_stmt_mutable = {
  mutable constraints : node list;
  mutable deferred : bool;
}

let default_constraints_set_stmt_mutable () : constraints_set_stmt_mutable = {
  constraints = [];
  deferred = false;
}

type reindex_stmt_mutable = {
  mutable kind : reindex_object_type;
  mutable relation : range_var option;
  mutable name : string;
  mutable options : int32;
  mutable concurrent : bool;
}

let default_reindex_stmt_mutable () : reindex_stmt_mutable = {
  kind = default_reindex_object_type ();
  relation = None;
  name = "";
  options = 0l;
  concurrent = false;
}

type create_schema_stmt_mutable = {
  mutable schemaname : string;
  mutable authrole : role_spec option;
  mutable schema_elts : node list;
  mutable if_not_exists : bool;
}

let default_create_schema_stmt_mutable () : create_schema_stmt_mutable = {
  schemaname = "";
  authrole = None;
  schema_elts = [];
  if_not_exists = false;
}

type alter_database_stmt_mutable = {
  mutable dbname : string;
  mutable options : node list;
}

let default_alter_database_stmt_mutable () : alter_database_stmt_mutable = {
  dbname = "";
  options = [];
}

type alter_database_set_stmt_mutable = {
  mutable dbname : string;
  mutable setstmt : variable_set_stmt option;
}

let default_alter_database_set_stmt_mutable () : alter_database_set_stmt_mutable = {
  dbname = "";
  setstmt = None;
}

type alter_role_set_stmt_mutable = {
  mutable role : role_spec option;
  mutable database : string;
  mutable setstmt : variable_set_stmt option;
}

let default_alter_role_set_stmt_mutable () : alter_role_set_stmt_mutable = {
  role = None;
  database = "";
  setstmt = None;
}

type create_conversion_stmt_mutable = {
  mutable conversion_name : node list;
  mutable for_encoding_name : string;
  mutable to_encoding_name : string;
  mutable func_name : node list;
  mutable def : bool;
}

let default_create_conversion_stmt_mutable () : create_conversion_stmt_mutable = {
  conversion_name = [];
  for_encoding_name = "";
  to_encoding_name = "";
  func_name = [];
  def = false;
}

type create_cast_stmt_mutable = {
  mutable sourcetype : type_name option;
  mutable targettype : type_name option;
  mutable func : object_with_args option;
  mutable context : coercion_context;
  mutable inout : bool;
}

let default_create_cast_stmt_mutable () : create_cast_stmt_mutable = {
  sourcetype = None;
  targettype = None;
  func = None;
  context = default_coercion_context ();
  inout = false;
}

type create_op_class_stmt_mutable = {
  mutable opclassname : node list;
  mutable opfamilyname : node list;
  mutable amname : string;
  mutable datatype : type_name option;
  mutable items : node list;
  mutable is_default : bool;
}

let default_create_op_class_stmt_mutable () : create_op_class_stmt_mutable = {
  opclassname = [];
  opfamilyname = [];
  amname = "";
  datatype = None;
  items = [];
  is_default = false;
}

type create_op_family_stmt_mutable = {
  mutable opfamilyname : node list;
  mutable amname : string;
}

let default_create_op_family_stmt_mutable () : create_op_family_stmt_mutable = {
  opfamilyname = [];
  amname = "";
}

type alter_op_family_stmt_mutable = {
  mutable opfamilyname : node list;
  mutable amname : string;
  mutable is_drop : bool;
  mutable items : node list;
}

let default_alter_op_family_stmt_mutable () : alter_op_family_stmt_mutable = {
  opfamilyname = [];
  amname = "";
  is_drop = false;
  items = [];
}

type prepare_stmt_mutable = {
  mutable name : string;
  mutable argtypes : node list;
  mutable query : node option;
}

let default_prepare_stmt_mutable () : prepare_stmt_mutable = {
  name = "";
  argtypes = [];
  query = None;
}

type execute_stmt_mutable = {
  mutable name : string;
  mutable params : node list;
}

let default_execute_stmt_mutable () : execute_stmt_mutable = {
  name = "";
  params = [];
}

type declare_cursor_stmt_mutable = {
  mutable portalname : string;
  mutable options : int32;
  mutable query : node option;
}

let default_declare_cursor_stmt_mutable () : declare_cursor_stmt_mutable = {
  portalname = "";
  options = 0l;
  query = None;
}

type create_table_space_stmt_mutable = {
  mutable tablespacename : string;
  mutable owner : role_spec option;
  mutable location : string;
  mutable options : node list;
}

let default_create_table_space_stmt_mutable () : create_table_space_stmt_mutable = {
  tablespacename = "";
  owner = None;
  location = "";
  options = [];
}

type alter_object_depends_stmt_mutable = {
  mutable object_type : object_type;
  mutable relation : range_var option;
  mutable object_ : node option;
  mutable extname : node option;
  mutable remove : bool;
}

let default_alter_object_depends_stmt_mutable () : alter_object_depends_stmt_mutable = {
  object_type = default_object_type ();
  relation = None;
  object_ = None;
  extname = None;
  remove = false;
}

type alter_object_schema_stmt_mutable = {
  mutable object_type : object_type;
  mutable relation : range_var option;
  mutable object_ : node option;
  mutable newschema : string;
  mutable missing_ok : bool;
}

let default_alter_object_schema_stmt_mutable () : alter_object_schema_stmt_mutable = {
  object_type = default_object_type ();
  relation = None;
  object_ = None;
  newschema = "";
  missing_ok = false;
}

type alter_owner_stmt_mutable = {
  mutable object_type : object_type;
  mutable relation : range_var option;
  mutable object_ : node option;
  mutable newowner : role_spec option;
}

let default_alter_owner_stmt_mutable () : alter_owner_stmt_mutable = {
  object_type = default_object_type ();
  relation = None;
  object_ = None;
  newowner = None;
}

type alter_operator_stmt_mutable = {
  mutable opername : object_with_args option;
  mutable options : node list;
}

let default_alter_operator_stmt_mutable () : alter_operator_stmt_mutable = {
  opername = None;
  options = [];
}

type alter_type_stmt_mutable = {
  mutable type_name : node list;
  mutable options : node list;
}

let default_alter_type_stmt_mutable () : alter_type_stmt_mutable = {
  type_name = [];
  options = [];
}

type drop_owned_stmt_mutable = {
  mutable roles : node list;
  mutable behavior : drop_behavior;
}

let default_drop_owned_stmt_mutable () : drop_owned_stmt_mutable = {
  roles = [];
  behavior = default_drop_behavior ();
}

type reassign_owned_stmt_mutable = {
  mutable roles : node list;
  mutable newrole : role_spec option;
}

let default_reassign_owned_stmt_mutable () : reassign_owned_stmt_mutable = {
  roles = [];
  newrole = None;
}

type composite_type_stmt_mutable = {
  mutable typevar : range_var option;
  mutable coldeflist : node list;
}

let default_composite_type_stmt_mutable () : composite_type_stmt_mutable = {
  typevar = None;
  coldeflist = [];
}

type create_enum_stmt_mutable = {
  mutable type_name : node list;
  mutable vals : node list;
}

let default_create_enum_stmt_mutable () : create_enum_stmt_mutable = {
  type_name = [];
  vals = [];
}

type create_range_stmt_mutable = {
  mutable type_name : node list;
  mutable params : node list;
}

let default_create_range_stmt_mutable () : create_range_stmt_mutable = {
  type_name = [];
  params = [];
}

type alter_enum_stmt_mutable = {
  mutable type_name : node list;
  mutable old_val : string;
  mutable new_val : string;
  mutable new_val_neighbor : string;
  mutable new_val_is_after : bool;
  mutable skip_if_new_val_exists : bool;
}

let default_alter_enum_stmt_mutable () : alter_enum_stmt_mutable = {
  type_name = [];
  old_val = "";
  new_val = "";
  new_val_neighbor = "";
  new_val_is_after = false;
  skip_if_new_val_exists = false;
}

type alter_tsdictionary_stmt_mutable = {
  mutable dictname : node list;
  mutable options : node list;
}

let default_alter_tsdictionary_stmt_mutable () : alter_tsdictionary_stmt_mutable = {
  dictname = [];
  options = [];
}

type alter_tsconfiguration_stmt_mutable = {
  mutable kind : alter_tsconfig_type;
  mutable cfgname : node list;
  mutable tokentype : node list;
  mutable dicts : node list;
  mutable override : bool;
  mutable replace : bool;
  mutable missing_ok : bool;
}

let default_alter_tsconfiguration_stmt_mutable () : alter_tsconfiguration_stmt_mutable = {
  kind = default_alter_tsconfig_type ();
  cfgname = [];
  tokentype = [];
  dicts = [];
  override = false;
  replace = false;
  missing_ok = false;
}

type create_fdw_stmt_mutable = {
  mutable fdwname : string;
  mutable func_options : node list;
  mutable options : node list;
}

let default_create_fdw_stmt_mutable () : create_fdw_stmt_mutable = {
  fdwname = "";
  func_options = [];
  options = [];
}

type alter_fdw_stmt_mutable = {
  mutable fdwname : string;
  mutable func_options : node list;
  mutable options : node list;
}

let default_alter_fdw_stmt_mutable () : alter_fdw_stmt_mutable = {
  fdwname = "";
  func_options = [];
  options = [];
}

type create_foreign_server_stmt_mutable = {
  mutable servername : string;
  mutable servertype : string;
  mutable version : string;
  mutable fdwname : string;
  mutable if_not_exists : bool;
  mutable options : node list;
}

let default_create_foreign_server_stmt_mutable () : create_foreign_server_stmt_mutable = {
  servername = "";
  servertype = "";
  version = "";
  fdwname = "";
  if_not_exists = false;
  options = [];
}

type alter_foreign_server_stmt_mutable = {
  mutable servername : string;
  mutable version : string;
  mutable options : node list;
  mutable has_version : bool;
}

let default_alter_foreign_server_stmt_mutable () : alter_foreign_server_stmt_mutable = {
  servername = "";
  version = "";
  options = [];
  has_version = false;
}

type create_user_mapping_stmt_mutable = {
  mutable user : role_spec option;
  mutable servername : string;
  mutable if_not_exists : bool;
  mutable options : node list;
}

let default_create_user_mapping_stmt_mutable () : create_user_mapping_stmt_mutable = {
  user = None;
  servername = "";
  if_not_exists = false;
  options = [];
}

type alter_user_mapping_stmt_mutable = {
  mutable user : role_spec option;
  mutable servername : string;
  mutable options : node list;
}

let default_alter_user_mapping_stmt_mutable () : alter_user_mapping_stmt_mutable = {
  user = None;
  servername = "";
  options = [];
}

type alter_table_space_options_stmt_mutable = {
  mutable tablespacename : string;
  mutable options : node list;
  mutable is_reset : bool;
}

let default_alter_table_space_options_stmt_mutable () : alter_table_space_options_stmt_mutable = {
  tablespacename = "";
  options = [];
  is_reset = false;
}

type alter_table_move_all_stmt_mutable = {
  mutable orig_tablespacename : string;
  mutable objtype : object_type;
  mutable roles : node list;
  mutable new_tablespacename : string;
  mutable nowait : bool;
}

let default_alter_table_move_all_stmt_mutable () : alter_table_move_all_stmt_mutable = {
  orig_tablespacename = "";
  objtype = default_object_type ();
  roles = [];
  new_tablespacename = "";
  nowait = false;
}

type sec_label_stmt_mutable = {
  mutable objtype : object_type;
  mutable object_ : node option;
  mutable provider : string;
  mutable label : string;
}

let default_sec_label_stmt_mutable () : sec_label_stmt_mutable = {
  objtype = default_object_type ();
  object_ = None;
  provider = "";
  label = "";
}

type create_foreign_table_stmt_mutable = {
  mutable base_stmt : create_stmt option;
  mutable servername : string;
  mutable options : node list;
}

let default_create_foreign_table_stmt_mutable () : create_foreign_table_stmt_mutable = {
  base_stmt = None;
  servername = "";
  options = [];
}

type import_foreign_schema_stmt_mutable = {
  mutable server_name : string;
  mutable remote_schema : string;
  mutable local_schema : string;
  mutable list_type : import_foreign_schema_type;
  mutable table_list : node list;
  mutable options : node list;
}

let default_import_foreign_schema_stmt_mutable () : import_foreign_schema_stmt_mutable = {
  server_name = "";
  remote_schema = "";
  local_schema = "";
  list_type = default_import_foreign_schema_type ();
  table_list = [];
  options = [];
}

type create_extension_stmt_mutable = {
  mutable extname : string;
  mutable if_not_exists : bool;
  mutable options : node list;
}

let default_create_extension_stmt_mutable () : create_extension_stmt_mutable = {
  extname = "";
  if_not_exists = false;
  options = [];
}

type alter_extension_stmt_mutable = {
  mutable extname : string;
  mutable options : node list;
}

let default_alter_extension_stmt_mutable () : alter_extension_stmt_mutable = {
  extname = "";
  options = [];
}

type alter_extension_contents_stmt_mutable = {
  mutable extname : string;
  mutable action : int32;
  mutable objtype : object_type;
  mutable object_ : node option;
}

let default_alter_extension_contents_stmt_mutable () : alter_extension_contents_stmt_mutable = {
  extname = "";
  action = 0l;
  objtype = default_object_type ();
  object_ = None;
}

type create_event_trig_stmt_mutable = {
  mutable trigname : string;
  mutable eventname : string;
  mutable whenclause : node list;
  mutable funcname : node list;
}

let default_create_event_trig_stmt_mutable () : create_event_trig_stmt_mutable = {
  trigname = "";
  eventname = "";
  whenclause = [];
  funcname = [];
}

type refresh_mat_view_stmt_mutable = {
  mutable concurrent : bool;
  mutable skip_data : bool;
  mutable relation : range_var option;
}

let default_refresh_mat_view_stmt_mutable () : refresh_mat_view_stmt_mutable = {
  concurrent = false;
  skip_data = false;
  relation = None;
}

type alter_system_stmt_mutable = {
  mutable setstmt : variable_set_stmt option;
}

let default_alter_system_stmt_mutable () : alter_system_stmt_mutable = {
  setstmt = None;
}

type create_policy_stmt_mutable = {
  mutable policy_name : string;
  mutable table : range_var option;
  mutable cmd_name : string;
  mutable permissive : bool;
  mutable roles : node list;
  mutable qual : node option;
  mutable with_check : node option;
}

let default_create_policy_stmt_mutable () : create_policy_stmt_mutable = {
  policy_name = "";
  table = None;
  cmd_name = "";
  permissive = false;
  roles = [];
  qual = None;
  with_check = None;
}

type alter_policy_stmt_mutable = {
  mutable policy_name : string;
  mutable table : range_var option;
  mutable roles : node list;
  mutable qual : node option;
  mutable with_check : node option;
}

let default_alter_policy_stmt_mutable () : alter_policy_stmt_mutable = {
  policy_name = "";
  table = None;
  roles = [];
  qual = None;
  with_check = None;
}

type create_transform_stmt_mutable = {
  mutable replace : bool;
  mutable type_name : type_name option;
  mutable lang : string;
  mutable fromsql : object_with_args option;
  mutable tosql : object_with_args option;
}

let default_create_transform_stmt_mutable () : create_transform_stmt_mutable = {
  replace = false;
  type_name = None;
  lang = "";
  fromsql = None;
  tosql = None;
}

type create_am_stmt_mutable = {
  mutable amname : string;
  mutable handler_name : node list;
  mutable amtype : string;
}

let default_create_am_stmt_mutable () : create_am_stmt_mutable = {
  amname = "";
  handler_name = [];
  amtype = "";
}

type create_publication_stmt_mutable = {
  mutable pubname : string;
  mutable options : node list;
  mutable tables : node list;
  mutable for_all_tables : bool;
}

let default_create_publication_stmt_mutable () : create_publication_stmt_mutable = {
  pubname = "";
  options = [];
  tables = [];
  for_all_tables = false;
}

type alter_publication_stmt_mutable = {
  mutable pubname : string;
  mutable options : node list;
  mutable tables : node list;
  mutable for_all_tables : bool;
  mutable table_action : def_elem_action;
}

let default_alter_publication_stmt_mutable () : alter_publication_stmt_mutable = {
  pubname = "";
  options = [];
  tables = [];
  for_all_tables = false;
  table_action = default_def_elem_action ();
}

type create_subscription_stmt_mutable = {
  mutable subname : string;
  mutable conninfo : string;
  mutable publication : node list;
  mutable options : node list;
}

let default_create_subscription_stmt_mutable () : create_subscription_stmt_mutable = {
  subname = "";
  conninfo = "";
  publication = [];
  options = [];
}

type alter_subscription_stmt_mutable = {
  mutable kind : alter_subscription_type;
  mutable subname : string;
  mutable conninfo : string;
  mutable publication : node list;
  mutable options : node list;
}

let default_alter_subscription_stmt_mutable () : alter_subscription_stmt_mutable = {
  kind = default_alter_subscription_type ();
  subname = "";
  conninfo = "";
  publication = [];
  options = [];
}

type create_stats_stmt_mutable = {
  mutable defnames : node list;
  mutable stat_types : node list;
  mutable exprs : node list;
  mutable relations : node list;
  mutable stxcomment : string;
  mutable if_not_exists : bool;
}

let default_create_stats_stmt_mutable () : create_stats_stmt_mutable = {
  defnames = [];
  stat_types = [];
  exprs = [];
  relations = [];
  stxcomment = "";
  if_not_exists = false;
}

type alter_collation_stmt_mutable = {
  mutable collname : node list;
}

let default_alter_collation_stmt_mutable () : alter_collation_stmt_mutable = {
  collname = [];
}

type call_stmt_mutable = {
  mutable funccall : func_call option;
  mutable funcexpr : func_expr option;
}

let default_call_stmt_mutable () : call_stmt_mutable = {
  funccall = None;
  funcexpr = None;
}

type func_call_mutable = {
  mutable funcname : node list;
  mutable args : node list;
  mutable agg_order : node list;
  mutable agg_filter : node option;
  mutable agg_within_group : bool;
  mutable agg_star : bool;
  mutable agg_distinct : bool;
  mutable func_variadic : bool;
  mutable over : window_def option;
  mutable location : int32;
}

let default_func_call_mutable () : func_call_mutable = {
  funcname = [];
  args = [];
  agg_order = [];
  agg_filter = None;
  agg_within_group = false;
  agg_star = false;
  agg_distinct = false;
  func_variadic = false;
  over = None;
  location = 0l;
}

type window_def_mutable = {
  mutable name : string;
  mutable refname : string;
  mutable partition_clause : node list;
  mutable order_clause : node list;
  mutable frame_options : int32;
  mutable start_offset : node option;
  mutable end_offset : node option;
  mutable location : int32;
}

let default_window_def_mutable () : window_def_mutable = {
  name = "";
  refname = "";
  partition_clause = [];
  order_clause = [];
  frame_options = 0l;
  start_offset = None;
  end_offset = None;
  location = 0l;
}

type alter_stats_stmt_mutable = {
  mutable defnames : node list;
  mutable stxstattarget : int32;
  mutable missing_ok : bool;
}

let default_alter_stats_stmt_mutable () : alter_stats_stmt_mutable = {
  defnames = [];
  stxstattarget = 0l;
  missing_ok = false;
}

type a_expr_mutable = {
  mutable kind : a_expr_kind;
  mutable name : node list;
  mutable lexpr : node option;
  mutable rexpr : node option;
  mutable location : int32;
}

let default_a_expr_mutable () : a_expr_mutable = {
  kind = default_a_expr_kind ();
  name = [];
  lexpr = None;
  rexpr = None;
  location = 0l;
}

type column_ref_mutable = {
  mutable fields : node list;
  mutable location : int32;
}

let default_column_ref_mutable () : column_ref_mutable = {
  fields = [];
  location = 0l;
}

type a_const_mutable = {
  mutable val_ : node option;
  mutable location : int32;
}

let default_a_const_mutable () : a_const_mutable = {
  val_ = None;
  location = 0l;
}

type a_indices_mutable = {
  mutable is_slice : bool;
  mutable lidx : node option;
  mutable uidx : node option;
}

let default_a_indices_mutable () : a_indices_mutable = {
  is_slice = false;
  lidx = None;
  uidx = None;
}

type a_indirection_mutable = {
  mutable arg : node option;
  mutable indirection : node list;
}

let default_a_indirection_mutable () : a_indirection_mutable = {
  arg = None;
  indirection = [];
}

type a_array_expr_mutable = {
  mutable elements : node list;
  mutable location : int32;
}

let default_a_array_expr_mutable () : a_array_expr_mutable = {
  elements = [];
  location = 0l;
}

type res_target_mutable = {
  mutable name : string;
  mutable indirection : node list;
  mutable val_ : node option;
  mutable location : int32;
}

let default_res_target_mutable () : res_target_mutable = {
  name = "";
  indirection = [];
  val_ = None;
  location = 0l;
}

type multi_assign_ref_mutable = {
  mutable source : node option;
  mutable colno : int32;
  mutable ncolumns : int32;
}

let default_multi_assign_ref_mutable () : multi_assign_ref_mutable = {
  source = None;
  colno = 0l;
  ncolumns = 0l;
}

type type_cast_mutable = {
  mutable arg : node option;
  mutable type_name : type_name option;
  mutable location : int32;
}

let default_type_cast_mutable () : type_cast_mutable = {
  arg = None;
  type_name = None;
  location = 0l;
}

type sort_by_mutable = {
  mutable node : node option;
  mutable sortby_dir : sort_by_dir;
  mutable sortby_nulls : sort_by_nulls;
  mutable use_op : node list;
  mutable location : int32;
}

let default_sort_by_mutable () : sort_by_mutable = {
  node = None;
  sortby_dir = default_sort_by_dir ();
  sortby_nulls = default_sort_by_nulls ();
  use_op = [];
  location = 0l;
}

type range_subselect_mutable = {
  mutable lateral : bool;
  mutable subquery : node option;
  mutable alias : alias option;
}

let default_range_subselect_mutable () : range_subselect_mutable = {
  lateral = false;
  subquery = None;
  alias = None;
}

type range_function_mutable = {
  mutable lateral : bool;
  mutable ordinality : bool;
  mutable is_rowsfrom : bool;
  mutable functions : node list;
  mutable alias : alias option;
  mutable coldeflist : node list;
}

let default_range_function_mutable () : range_function_mutable = {
  lateral = false;
  ordinality = false;
  is_rowsfrom = false;
  functions = [];
  alias = None;
  coldeflist = [];
}

type range_table_sample_mutable = {
  mutable relation : node option;
  mutable method_ : node list;
  mutable args : node list;
  mutable repeatable : node option;
  mutable location : int32;
}

let default_range_table_sample_mutable () : range_table_sample_mutable = {
  relation = None;
  method_ = [];
  args = [];
  repeatable = None;
  location = 0l;
}

type range_table_func_mutable = {
  mutable lateral : bool;
  mutable docexpr : node option;
  mutable rowexpr : node option;
  mutable namespaces : node list;
  mutable columns : node list;
  mutable alias : alias option;
  mutable location : int32;
}

let default_range_table_func_mutable () : range_table_func_mutable = {
  lateral = false;
  docexpr = None;
  rowexpr = None;
  namespaces = [];
  columns = [];
  alias = None;
  location = 0l;
}

type range_table_func_col_mutable = {
  mutable colname : string;
  mutable type_name : type_name option;
  mutable for_ordinality : bool;
  mutable is_not_null : bool;
  mutable colexpr : node option;
  mutable coldefexpr : node option;
  mutable location : int32;
}

let default_range_table_func_col_mutable () : range_table_func_col_mutable = {
  colname = "";
  type_name = None;
  for_ordinality = false;
  is_not_null = false;
  colexpr = None;
  coldefexpr = None;
  location = 0l;
}

type column_def_mutable = {
  mutable colname : string;
  mutable type_name : type_name option;
  mutable inhcount : int32;
  mutable is_local : bool;
  mutable is_not_null : bool;
  mutable is_from_type : bool;
  mutable storage : string;
  mutable raw_default : node option;
  mutable cooked_default : node option;
  mutable identity : string;
  mutable identity_sequence : range_var option;
  mutable generated : string;
  mutable coll_clause : collate_clause option;
  mutable coll_oid : int32;
  mutable constraints : node list;
  mutable fdwoptions : node list;
  mutable location : int32;
}

let default_column_def_mutable () : column_def_mutable = {
  colname = "";
  type_name = None;
  inhcount = 0l;
  is_local = false;
  is_not_null = false;
  is_from_type = false;
  storage = "";
  raw_default = None;
  cooked_default = None;
  identity = "";
  identity_sequence = None;
  generated = "";
  coll_clause = None;
  coll_oid = 0l;
  constraints = [];
  fdwoptions = [];
  location = 0l;
}

type index_elem_mutable = {
  mutable name : string;
  mutable expr : node option;
  mutable indexcolname : string;
  mutable collation : node list;
  mutable opclass : node list;
  mutable opclassopts : node list;
  mutable ordering : sort_by_dir;
  mutable nulls_ordering : sort_by_nulls;
}

let default_index_elem_mutable () : index_elem_mutable = {
  name = "";
  expr = None;
  indexcolname = "";
  collation = [];
  opclass = [];
  opclassopts = [];
  ordering = default_sort_by_dir ();
  nulls_ordering = default_sort_by_nulls ();
}

type constraint__mutable = {
  mutable contype : constr_type;
  mutable conname : string;
  mutable deferrable : bool;
  mutable initdeferred : bool;
  mutable location : int32;
  mutable is_no_inherit : bool;
  mutable raw_expr : node option;
  mutable cooked_expr : string;
  mutable generated_when : string;
  mutable keys : node list;
  mutable including : node list;
  mutable exclusions : node list;
  mutable options : node list;
  mutable indexname : string;
  mutable indexspace : string;
  mutable reset_default_tblspc : bool;
  mutable access_method : string;
  mutable where_clause : node option;
  mutable pktable : range_var option;
  mutable fk_attrs : node list;
  mutable pk_attrs : node list;
  mutable fk_matchtype : string;
  mutable fk_upd_action : string;
  mutable fk_del_action : string;
  mutable old_conpfeqop : node list;
  mutable old_pktable_oid : int32;
  mutable skip_validation : bool;
  mutable initially_valid : bool;
}

let default_constraint__mutable () : constraint__mutable = {
  contype = default_constr_type ();
  conname = "";
  deferrable = false;
  initdeferred = false;
  location = 0l;
  is_no_inherit = false;
  raw_expr = None;
  cooked_expr = "";
  generated_when = "";
  keys = [];
  including = [];
  exclusions = [];
  options = [];
  indexname = "";
  indexspace = "";
  reset_default_tblspc = false;
  access_method = "";
  where_clause = None;
  pktable = None;
  fk_attrs = [];
  pk_attrs = [];
  fk_matchtype = "";
  fk_upd_action = "";
  fk_del_action = "";
  old_conpfeqop = [];
  old_pktable_oid = 0l;
  skip_validation = false;
  initially_valid = false;
}

type def_elem_mutable = {
  mutable defnamespace : string;
  mutable defname : string;
  mutable arg : node option;
  mutable defaction : def_elem_action;
  mutable location : int32;
}

let default_def_elem_mutable () : def_elem_mutable = {
  defnamespace = "";
  defname = "";
  arg = None;
  defaction = default_def_elem_action ();
  location = 0l;
}

type range_tbl_entry_mutable = {
  mutable rtekind : rtekind;
  mutable relid : int32;
  mutable relkind : string;
  mutable rellockmode : int32;
  mutable tablesample : table_sample_clause option;
  mutable subquery : query option;
  mutable security_barrier : bool;
  mutable jointype : join_type;
  mutable joinmergedcols : int32;
  mutable joinaliasvars : node list;
  mutable joinleftcols : node list;
  mutable joinrightcols : node list;
  mutable functions : node list;
  mutable funcordinality : bool;
  mutable tablefunc : table_func option;
  mutable values_lists : node list;
  mutable ctename : string;
  mutable ctelevelsup : int32;
  mutable self_reference : bool;
  mutable coltypes : node list;
  mutable coltypmods : node list;
  mutable colcollations : node list;
  mutable enrname : string;
  mutable enrtuples : float;
  mutable alias : alias option;
  mutable eref : alias option;
  mutable lateral : bool;
  mutable inh : bool;
  mutable in_from_cl : bool;
  mutable required_perms : int32;
  mutable check_as_user : int32;
  mutable selected_cols : int64 list;
  mutable inserted_cols : int64 list;
  mutable updated_cols : int64 list;
  mutable extra_updated_cols : int64 list;
  mutable security_quals : node list;
}

let default_range_tbl_entry_mutable () : range_tbl_entry_mutable = {
  rtekind = default_rtekind ();
  relid = 0l;
  relkind = "";
  rellockmode = 0l;
  tablesample = None;
  subquery = None;
  security_barrier = false;
  jointype = default_join_type ();
  joinmergedcols = 0l;
  joinaliasvars = [];
  joinleftcols = [];
  joinrightcols = [];
  functions = [];
  funcordinality = false;
  tablefunc = None;
  values_lists = [];
  ctename = "";
  ctelevelsup = 0l;
  self_reference = false;
  coltypes = [];
  coltypmods = [];
  colcollations = [];
  enrname = "";
  enrtuples = 0.;
  alias = None;
  eref = None;
  lateral = false;
  inh = false;
  in_from_cl = false;
  required_perms = 0l;
  check_as_user = 0l;
  selected_cols = [];
  inserted_cols = [];
  updated_cols = [];
  extra_updated_cols = [];
  security_quals = [];
}

type table_sample_clause_mutable = {
  mutable tsmhandler : int32;
  mutable args : node list;
  mutable repeatable : node option;
}

let default_table_sample_clause_mutable () : table_sample_clause_mutable = {
  tsmhandler = 0l;
  args = [];
  repeatable = None;
}

type range_tbl_function_mutable = {
  mutable funcexpr : node option;
  mutable funccolcount : int32;
  mutable funccolnames : node list;
  mutable funccoltypes : node list;
  mutable funccoltypmods : node list;
  mutable funccolcollations : node list;
  mutable funcparams : int64 list;
}

let default_range_tbl_function_mutable () : range_tbl_function_mutable = {
  funcexpr = None;
  funccolcount = 0l;
  funccolnames = [];
  funccoltypes = [];
  funccoltypmods = [];
  funccolcollations = [];
  funcparams = [];
}

type with_check_option_mutable = {
  mutable kind : wcokind;
  mutable relname : string;
  mutable polname : string;
  mutable qual : node option;
  mutable cascaded : bool;
}

let default_with_check_option_mutable () : with_check_option_mutable = {
  kind = default_wcokind ();
  relname = "";
  polname = "";
  qual = None;
  cascaded = false;
}

type grouping_set_mutable = {
  mutable kind : grouping_set_kind;
  mutable content : node list;
  mutable location : int32;
}

let default_grouping_set_mutable () : grouping_set_mutable = {
  kind = default_grouping_set_kind ();
  content = [];
  location = 0l;
}

type window_clause_mutable = {
  mutable name : string;
  mutable refname : string;
  mutable partition_clause : node list;
  mutable order_clause : node list;
  mutable frame_options : int32;
  mutable start_offset : node option;
  mutable end_offset : node option;
  mutable start_in_range_func : int32;
  mutable end_in_range_func : int32;
  mutable in_range_coll : int32;
  mutable in_range_asc : bool;
  mutable in_range_nulls_first : bool;
  mutable winref : int32;
  mutable copied_order : bool;
}

let default_window_clause_mutable () : window_clause_mutable = {
  name = "";
  refname = "";
  partition_clause = [];
  order_clause = [];
  frame_options = 0l;
  start_offset = None;
  end_offset = None;
  start_in_range_func = 0l;
  end_in_range_func = 0l;
  in_range_coll = 0l;
  in_range_asc = false;
  in_range_nulls_first = false;
  winref = 0l;
  copied_order = false;
}

type access_priv_mutable = {
  mutable priv_name : string;
  mutable cols : node list;
}

let default_access_priv_mutable () : access_priv_mutable = {
  priv_name = "";
  cols = [];
}

type create_op_class_item_mutable = {
  mutable itemtype : int32;
  mutable name : object_with_args option;
  mutable number : int32;
  mutable order_family : node list;
  mutable class_args : node list;
  mutable storedtype : type_name option;
}

let default_create_op_class_item_mutable () : create_op_class_item_mutable = {
  itemtype = 0l;
  name = None;
  number = 0l;
  order_family = [];
  class_args = [];
  storedtype = None;
}

type table_like_clause_mutable = {
  mutable relation : range_var option;
  mutable options : int32;
  mutable relation_oid : int32;
}

let default_table_like_clause_mutable () : table_like_clause_mutable = {
  relation = None;
  options = 0l;
  relation_oid = 0l;
}

type function_parameter_mutable = {
  mutable name : string;
  mutable arg_type : type_name option;
  mutable mode : function_parameter_mode;
  mutable defexpr : node option;
}

let default_function_parameter_mutable () : function_parameter_mutable = {
  name = "";
  arg_type = None;
  mode = default_function_parameter_mode ();
  defexpr = None;
}

type locking_clause_mutable = {
  mutable locked_rels : node list;
  mutable strength : lock_clause_strength;
  mutable wait_policy : lock_wait_policy;
}

let default_locking_clause_mutable () : locking_clause_mutable = {
  locked_rels = [];
  strength = default_lock_clause_strength ();
  wait_policy = default_lock_wait_policy ();
}

type xml_serialize_mutable = {
  mutable xmloption : xml_option_type;
  mutable expr : node option;
  mutable type_name : type_name option;
  mutable location : int32;
}

let default_xml_serialize_mutable () : xml_serialize_mutable = {
  xmloption = default_xml_option_type ();
  expr = None;
  type_name = None;
  location = 0l;
}

type common_table_expr_mutable = {
  mutable ctename : string;
  mutable aliascolnames : node list;
  mutable ctematerialized : ctematerialize;
  mutable ctequery : node option;
  mutable location : int32;
  mutable cterecursive : bool;
  mutable cterefcount : int32;
  mutable ctecolnames : node list;
  mutable ctecoltypes : node list;
  mutable ctecoltypmods : node list;
  mutable ctecolcollations : node list;
}

let default_common_table_expr_mutable () : common_table_expr_mutable = {
  ctename = "";
  aliascolnames = [];
  ctematerialized = default_ctematerialize ();
  ctequery = None;
  location = 0l;
  cterecursive = false;
  cterefcount = 0l;
  ctecolnames = [];
  ctecoltypes = [];
  ctecoltypmods = [];
  ctecolcollations = [];
}

type partition_elem_mutable = {
  mutable name : string;
  mutable expr : node option;
  mutable collation : node list;
  mutable opclass : node list;
  mutable location : int32;
}

let default_partition_elem_mutable () : partition_elem_mutable = {
  name = "";
  expr = None;
  collation = [];
  opclass = [];
  location = 0l;
}

type partition_range_datum_mutable = {
  mutable kind : partition_range_datum_kind;
  mutable value : node option;
  mutable location : int32;
}

let default_partition_range_datum_mutable () : partition_range_datum_mutable = {
  kind = default_partition_range_datum_kind ();
  value = None;
  location = 0l;
}

type partition_cmd_mutable = {
  mutable name : range_var option;
  mutable bound : partition_bound_spec option;
}

let default_partition_cmd_mutable () : partition_cmd_mutable = {
  name = None;
  bound = None;
}

type vacuum_relation_mutable = {
  mutable relation : range_var option;
  mutable oid : int32;
  mutable va_cols : node list;
}

let default_vacuum_relation_mutable () : vacuum_relation_mutable = {
  relation = None;
  oid = 0l;
  va_cols = [];
}

type pglist_mutable = {
  mutable items : node list;
}

let default_pglist_mutable () : pglist_mutable = {
  items = [];
}

type int_list_mutable = {
  mutable items : node list;
}

let default_int_list_mutable () : int_list_mutable = {
  items = [];
}

type oid_list_mutable = {
  mutable items : node list;
}

let default_oid_list_mutable () : oid_list_mutable = {
  items = [];
}

type parse_result_mutable = {
  mutable version : int32;
  mutable stmts : raw_stmt list;
}

let default_parse_result_mutable () : parse_result_mutable = {
  version = 0l;
  stmts = [];
}

type scan_token_mutable = {
  mutable start : int32;
  mutable end_ : int32;
  mutable token : token;
  mutable keyword_kind : keyword_kind;
}

let default_scan_token_mutable () : scan_token_mutable = {
  start = 0l;
  end_ = 0l;
  token = default_token ();
  keyword_kind = default_keyword_kind ();
}

type scan_result_mutable = {
  mutable version : int32;
  mutable tokens : scan_token list;
}

let default_scan_result_mutable () : scan_result_mutable = {
  version = 0l;
  tokens = [];
}

[@@@ocaml.warning "-27-30-39"]

(** {2 Formatters} *)

let rec pp_expr fmt (v:expr) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_unit fmt ()
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

let rec pp_param_kind fmt (v:param_kind) =
  match v with
  | Param_kind_undefined -> Format.fprintf fmt "Param_kind_undefined"
  | Param_extern -> Format.fprintf fmt "Param_extern"
  | Param_exec -> Format.fprintf fmt "Param_exec"
  | Param_sublink -> Format.fprintf fmt "Param_sublink"
  | Param_multiexpr -> Format.fprintf fmt "Param_multiexpr"

let rec pp_agg_split fmt (v:agg_split) =
  match v with
  | Agg_split_undefined -> Format.fprintf fmt "Agg_split_undefined"
  | Aggsplit_simple -> Format.fprintf fmt "Aggsplit_simple"
  | Aggsplit_initial_serial -> Format.fprintf fmt "Aggsplit_initial_serial"
  | Aggsplit_final_deserial -> Format.fprintf fmt "Aggsplit_final_deserial"

let rec pp_coercion_form fmt (v:coercion_form) =
  match v with
  | Coercion_form_undefined -> Format.fprintf fmt "Coercion_form_undefined"
  | Coerce_explicit_call -> Format.fprintf fmt "Coerce_explicit_call"
  | Coerce_explicit_cast -> Format.fprintf fmt "Coerce_explicit_cast"
  | Coerce_implicit_cast -> Format.fprintf fmt "Coerce_implicit_cast"

let rec pp_bool_expr_type fmt (v:bool_expr_type) =
  match v with
  | Bool_expr_type_undefined -> Format.fprintf fmt "Bool_expr_type_undefined"
  | And_expr -> Format.fprintf fmt "And_expr"
  | Or_expr -> Format.fprintf fmt "Or_expr"
  | Not_expr -> Format.fprintf fmt "Not_expr"

let rec pp_sub_link_type fmt (v:sub_link_type) =
  match v with
  | Sub_link_type_undefined -> Format.fprintf fmt "Sub_link_type_undefined"
  | Exists_sublink -> Format.fprintf fmt "Exists_sublink"
  | All_sublink -> Format.fprintf fmt "All_sublink"
  | Any_sublink -> Format.fprintf fmt "Any_sublink"
  | Rowcompare_sublink -> Format.fprintf fmt "Rowcompare_sublink"
  | Expr_sublink -> Format.fprintf fmt "Expr_sublink"
  | Multiexpr_sublink -> Format.fprintf fmt "Multiexpr_sublink"
  | Array_sublink -> Format.fprintf fmt "Array_sublink"
  | Cte_sublink -> Format.fprintf fmt "Cte_sublink"

let rec pp_row_compare_type fmt (v:row_compare_type) =
  match v with
  | Row_compare_type_undefined -> Format.fprintf fmt "Row_compare_type_undefined"
  | Rowcompare_lt -> Format.fprintf fmt "Rowcompare_lt"
  | Rowcompare_le -> Format.fprintf fmt "Rowcompare_le"
  | Rowcompare_eq -> Format.fprintf fmt "Rowcompare_eq"
  | Rowcompare_ge -> Format.fprintf fmt "Rowcompare_ge"
  | Rowcompare_gt -> Format.fprintf fmt "Rowcompare_gt"
  | Rowcompare_ne -> Format.fprintf fmt "Rowcompare_ne"

let rec pp_min_max_op fmt (v:min_max_op) =
  match v with
  | Min_max_op_undefined -> Format.fprintf fmt "Min_max_op_undefined"
  | Is_greatest -> Format.fprintf fmt "Is_greatest"
  | Is_least -> Format.fprintf fmt "Is_least"

let rec pp_sqlvalue_function_op fmt (v:sqlvalue_function_op) =
  match v with
  | Sqlvalue_function_op_undefined -> Format.fprintf fmt "Sqlvalue_function_op_undefined"
  | Svfop_current_date -> Format.fprintf fmt "Svfop_current_date"
  | Svfop_current_time -> Format.fprintf fmt "Svfop_current_time"
  | Svfop_current_time_n -> Format.fprintf fmt "Svfop_current_time_n"
  | Svfop_current_timestamp -> Format.fprintf fmt "Svfop_current_timestamp"
  | Svfop_current_timestamp_n -> Format.fprintf fmt "Svfop_current_timestamp_n"
  | Svfop_localtime -> Format.fprintf fmt "Svfop_localtime"
  | Svfop_localtime_n -> Format.fprintf fmt "Svfop_localtime_n"
  | Svfop_localtimestamp -> Format.fprintf fmt "Svfop_localtimestamp"
  | Svfop_localtimestamp_n -> Format.fprintf fmt "Svfop_localtimestamp_n"
  | Svfop_current_role -> Format.fprintf fmt "Svfop_current_role"
  | Svfop_current_user -> Format.fprintf fmt "Svfop_current_user"
  | Svfop_user -> Format.fprintf fmt "Svfop_user"
  | Svfop_session_user -> Format.fprintf fmt "Svfop_session_user"
  | Svfop_current_catalog -> Format.fprintf fmt "Svfop_current_catalog"
  | Svfop_current_schema -> Format.fprintf fmt "Svfop_current_schema"

let rec pp_xml_expr_op fmt (v:xml_expr_op) =
  match v with
  | Xml_expr_op_undefined -> Format.fprintf fmt "Xml_expr_op_undefined"
  | Is_xmlconcat -> Format.fprintf fmt "Is_xmlconcat"
  | Is_xmlelement -> Format.fprintf fmt "Is_xmlelement"
  | Is_xmlforest -> Format.fprintf fmt "Is_xmlforest"
  | Is_xmlparse -> Format.fprintf fmt "Is_xmlparse"
  | Is_xmlpi -> Format.fprintf fmt "Is_xmlpi"
  | Is_xmlroot -> Format.fprintf fmt "Is_xmlroot"
  | Is_xmlserialize -> Format.fprintf fmt "Is_xmlserialize"
  | Is_document -> Format.fprintf fmt "Is_document"

let rec pp_xml_option_type fmt (v:xml_option_type) =
  match v with
  | Xml_option_type_undefined -> Format.fprintf fmt "Xml_option_type_undefined"
  | Xmloption_document -> Format.fprintf fmt "Xmloption_document"
  | Xmloption_content -> Format.fprintf fmt "Xmloption_content"

let rec pp_null_test_type fmt (v:null_test_type) =
  match v with
  | Null_test_type_undefined -> Format.fprintf fmt "Null_test_type_undefined"
  | Is_null -> Format.fprintf fmt "Is_null"
  | Is_not_null -> Format.fprintf fmt "Is_not_null"

let rec pp_bool_test_type fmt (v:bool_test_type) =
  match v with
  | Bool_test_type_undefined -> Format.fprintf fmt "Bool_test_type_undefined"
  | Is_true -> Format.fprintf fmt "Is_true"
  | Is_not_true -> Format.fprintf fmt "Is_not_true"
  | Is_false -> Format.fprintf fmt "Is_false"
  | Is_not_false -> Format.fprintf fmt "Is_not_false"
  | Is_unknown -> Format.fprintf fmt "Is_unknown"
  | Is_not_unknown -> Format.fprintf fmt "Is_not_unknown"

let rec pp_range_tbl_ref fmt (v:range_tbl_ref) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "rtindex" Pbrt.Pp.pp_int32 fmt v.rtindex;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

let rec pp_join_type fmt (v:join_type) =
  match v with
  | Join_type_undefined -> Format.fprintf fmt "Join_type_undefined"
  | Join_inner -> Format.fprintf fmt "Join_inner"
  | Join_left -> Format.fprintf fmt "Join_left"
  | Join_full -> Format.fprintf fmt "Join_full"
  | Join_right -> Format.fprintf fmt "Join_right"
  | Join_semi -> Format.fprintf fmt "Join_semi"
  | Join_anti -> Format.fprintf fmt "Join_anti"
  | Join_unique_outer -> Format.fprintf fmt "Join_unique_outer"
  | Join_unique_inner -> Format.fprintf fmt "Join_unique_inner"

let rec pp_on_conflict_action fmt (v:on_conflict_action) =
  match v with
  | On_conflict_action_undefined -> Format.fprintf fmt "On_conflict_action_undefined"
  | Onconflict_none -> Format.fprintf fmt "Onconflict_none"
  | Onconflict_nothing -> Format.fprintf fmt "Onconflict_nothing"
  | Onconflict_update -> Format.fprintf fmt "Onconflict_update"

let rec pp_on_commit_action fmt (v:on_commit_action) =
  match v with
  | On_commit_action_undefined -> Format.fprintf fmt "On_commit_action_undefined"
  | Oncommit_noop -> Format.fprintf fmt "Oncommit_noop"
  | Oncommit_preserve_rows -> Format.fprintf fmt "Oncommit_preserve_rows"
  | Oncommit_delete_rows -> Format.fprintf fmt "Oncommit_delete_rows"
  | Oncommit_drop -> Format.fprintf fmt "Oncommit_drop"

let rec pp_cmd_type fmt (v:cmd_type) =
  match v with
  | Cmd_type_undefined -> Format.fprintf fmt "Cmd_type_undefined"
  | Cmd_unknown -> Format.fprintf fmt "Cmd_unknown"
  | Cmd_select -> Format.fprintf fmt "Cmd_select"
  | Cmd_update -> Format.fprintf fmt "Cmd_update"
  | Cmd_insert -> Format.fprintf fmt "Cmd_insert"
  | Cmd_delete -> Format.fprintf fmt "Cmd_delete"
  | Cmd_utility -> Format.fprintf fmt "Cmd_utility"
  | Cmd_nothing -> Format.fprintf fmt "Cmd_nothing"

let rec pp_query_source fmt (v:query_source) =
  match v with
  | Query_source_undefined -> Format.fprintf fmt "Query_source_undefined"
  | Qsrc_original -> Format.fprintf fmt "Qsrc_original"
  | Qsrc_parser -> Format.fprintf fmt "Qsrc_parser"
  | Qsrc_instead_rule -> Format.fprintf fmt "Qsrc_instead_rule"
  | Qsrc_qual_instead_rule -> Format.fprintf fmt "Qsrc_qual_instead_rule"
  | Qsrc_non_instead_rule -> Format.fprintf fmt "Qsrc_non_instead_rule"

let rec pp_overriding_kind fmt (v:overriding_kind) =
  match v with
  | Overriding_kind_undefined -> Format.fprintf fmt "Overriding_kind_undefined"
  | Overriding_not_set -> Format.fprintf fmt "Overriding_not_set"
  | Overriding_user_value -> Format.fprintf fmt "Overriding_user_value"
  | Overriding_system_value -> Format.fprintf fmt "Overriding_system_value"

let rec pp_limit_option fmt (v:limit_option) =
  match v with
  | Limit_option_undefined -> Format.fprintf fmt "Limit_option_undefined"
  | Limit_option_default -> Format.fprintf fmt "Limit_option_default"
  | Limit_option_count -> Format.fprintf fmt "Limit_option_count"
  | Limit_option_with_ties -> Format.fprintf fmt "Limit_option_with_ties"

let rec pp_set_operation fmt (v:set_operation) =
  match v with
  | Set_operation_undefined -> Format.fprintf fmt "Set_operation_undefined"
  | Setop_none -> Format.fprintf fmt "Setop_none"
  | Setop_union -> Format.fprintf fmt "Setop_union"
  | Setop_intersect -> Format.fprintf fmt "Setop_intersect"
  | Setop_except -> Format.fprintf fmt "Setop_except"

let rec pp_object_type fmt (v:object_type) =
  match v with
  | Object_type_undefined -> Format.fprintf fmt "Object_type_undefined"
  | Object_access_method -> Format.fprintf fmt "Object_access_method"
  | Object_aggregate -> Format.fprintf fmt "Object_aggregate"
  | Object_amop -> Format.fprintf fmt "Object_amop"
  | Object_amproc -> Format.fprintf fmt "Object_amproc"
  | Object_attribute -> Format.fprintf fmt "Object_attribute"
  | Object_cast -> Format.fprintf fmt "Object_cast"
  | Object_column -> Format.fprintf fmt "Object_column"
  | Object_collation -> Format.fprintf fmt "Object_collation"
  | Object_conversion -> Format.fprintf fmt "Object_conversion"
  | Object_database -> Format.fprintf fmt "Object_database"
  | Object_default -> Format.fprintf fmt "Object_default"
  | Object_defacl -> Format.fprintf fmt "Object_defacl"
  | Object_domain -> Format.fprintf fmt "Object_domain"
  | Object_domconstraint -> Format.fprintf fmt "Object_domconstraint"
  | Object_event_trigger -> Format.fprintf fmt "Object_event_trigger"
  | Object_extension -> Format.fprintf fmt "Object_extension"
  | Object_fdw -> Format.fprintf fmt "Object_fdw"
  | Object_foreign_server -> Format.fprintf fmt "Object_foreign_server"
  | Object_foreign_table -> Format.fprintf fmt "Object_foreign_table"
  | Object_function -> Format.fprintf fmt "Object_function"
  | Object_index -> Format.fprintf fmt "Object_index"
  | Object_language -> Format.fprintf fmt "Object_language"
  | Object_largeobject -> Format.fprintf fmt "Object_largeobject"
  | Object_matview -> Format.fprintf fmt "Object_matview"
  | Object_opclass -> Format.fprintf fmt "Object_opclass"
  | Object_operator -> Format.fprintf fmt "Object_operator"
  | Object_opfamily -> Format.fprintf fmt "Object_opfamily"
  | Object_policy -> Format.fprintf fmt "Object_policy"
  | Object_procedure -> Format.fprintf fmt "Object_procedure"
  | Object_publication -> Format.fprintf fmt "Object_publication"
  | Object_publication_rel -> Format.fprintf fmt "Object_publication_rel"
  | Object_role -> Format.fprintf fmt "Object_role"
  | Object_routine -> Format.fprintf fmt "Object_routine"
  | Object_rule -> Format.fprintf fmt "Object_rule"
  | Object_schema -> Format.fprintf fmt "Object_schema"
  | Object_sequence -> Format.fprintf fmt "Object_sequence"
  | Object_subscription -> Format.fprintf fmt "Object_subscription"
  | Object_statistic_ext -> Format.fprintf fmt "Object_statistic_ext"
  | Object_tabconstraint -> Format.fprintf fmt "Object_tabconstraint"
  | Object_table -> Format.fprintf fmt "Object_table"
  | Object_tablespace -> Format.fprintf fmt "Object_tablespace"
  | Object_transform -> Format.fprintf fmt "Object_transform"
  | Object_trigger -> Format.fprintf fmt "Object_trigger"
  | Object_tsconfiguration -> Format.fprintf fmt "Object_tsconfiguration"
  | Object_tsdictionary -> Format.fprintf fmt "Object_tsdictionary"
  | Object_tsparser -> Format.fprintf fmt "Object_tsparser"
  | Object_tstemplate -> Format.fprintf fmt "Object_tstemplate"
  | Object_type -> Format.fprintf fmt "Object_type"
  | Object_user_mapping -> Format.fprintf fmt "Object_user_mapping"
  | Object_view -> Format.fprintf fmt "Object_view"

let rec pp_alter_table_type fmt (v:alter_table_type) =
  match v with
  | Alter_table_type_undefined -> Format.fprintf fmt "Alter_table_type_undefined"
  | At_add_column -> Format.fprintf fmt "At_add_column"
  | At_add_column_recurse -> Format.fprintf fmt "At_add_column_recurse"
  | At_add_column_to_view -> Format.fprintf fmt "At_add_column_to_view"
  | At_column_default -> Format.fprintf fmt "At_column_default"
  | At_cooked_column_default -> Format.fprintf fmt "At_cooked_column_default"
  | At_drop_not_null -> Format.fprintf fmt "At_drop_not_null"
  | At_set_not_null -> Format.fprintf fmt "At_set_not_null"
  | At_drop_expression -> Format.fprintf fmt "At_drop_expression"
  | At_check_not_null -> Format.fprintf fmt "At_check_not_null"
  | At_set_statistics -> Format.fprintf fmt "At_set_statistics"
  | At_set_options -> Format.fprintf fmt "At_set_options"
  | At_reset_options -> Format.fprintf fmt "At_reset_options"
  | At_set_storage -> Format.fprintf fmt "At_set_storage"
  | At_drop_column -> Format.fprintf fmt "At_drop_column"
  | At_drop_column_recurse -> Format.fprintf fmt "At_drop_column_recurse"
  | At_add_index -> Format.fprintf fmt "At_add_index"
  | At_re_add_index -> Format.fprintf fmt "At_re_add_index"
  | At_add_constraint -> Format.fprintf fmt "At_add_constraint"
  | At_add_constraint_recurse -> Format.fprintf fmt "At_add_constraint_recurse"
  | At_re_add_constraint -> Format.fprintf fmt "At_re_add_constraint"
  | At_re_add_domain_constraint -> Format.fprintf fmt "At_re_add_domain_constraint"
  | At_alter_constraint -> Format.fprintf fmt "At_alter_constraint"
  | At_validate_constraint -> Format.fprintf fmt "At_validate_constraint"
  | At_validate_constraint_recurse -> Format.fprintf fmt "At_validate_constraint_recurse"
  | At_add_index_constraint -> Format.fprintf fmt "At_add_index_constraint"
  | At_drop_constraint -> Format.fprintf fmt "At_drop_constraint"
  | At_drop_constraint_recurse -> Format.fprintf fmt "At_drop_constraint_recurse"
  | At_re_add_comment -> Format.fprintf fmt "At_re_add_comment"
  | At_alter_column_type -> Format.fprintf fmt "At_alter_column_type"
  | At_alter_column_generic_options -> Format.fprintf fmt "At_alter_column_generic_options"
  | At_change_owner -> Format.fprintf fmt "At_change_owner"
  | At_cluster_on -> Format.fprintf fmt "At_cluster_on"
  | At_drop_cluster -> Format.fprintf fmt "At_drop_cluster"
  | At_set_logged -> Format.fprintf fmt "At_set_logged"
  | At_set_un_logged -> Format.fprintf fmt "At_set_un_logged"
  | At_drop_oids -> Format.fprintf fmt "At_drop_oids"
  | At_set_table_space -> Format.fprintf fmt "At_set_table_space"
  | At_set_rel_options -> Format.fprintf fmt "At_set_rel_options"
  | At_reset_rel_options -> Format.fprintf fmt "At_reset_rel_options"
  | At_replace_rel_options -> Format.fprintf fmt "At_replace_rel_options"
  | At_enable_trig -> Format.fprintf fmt "At_enable_trig"
  | At_enable_always_trig -> Format.fprintf fmt "At_enable_always_trig"
  | At_enable_replica_trig -> Format.fprintf fmt "At_enable_replica_trig"
  | At_disable_trig -> Format.fprintf fmt "At_disable_trig"
  | At_enable_trig_all -> Format.fprintf fmt "At_enable_trig_all"
  | At_disable_trig_all -> Format.fprintf fmt "At_disable_trig_all"
  | At_enable_trig_user -> Format.fprintf fmt "At_enable_trig_user"
  | At_disable_trig_user -> Format.fprintf fmt "At_disable_trig_user"
  | At_enable_rule -> Format.fprintf fmt "At_enable_rule"
  | At_enable_always_rule -> Format.fprintf fmt "At_enable_always_rule"
  | At_enable_replica_rule -> Format.fprintf fmt "At_enable_replica_rule"
  | At_disable_rule -> Format.fprintf fmt "At_disable_rule"
  | At_add_inherit -> Format.fprintf fmt "At_add_inherit"
  | At_drop_inherit -> Format.fprintf fmt "At_drop_inherit"
  | At_add_of -> Format.fprintf fmt "At_add_of"
  | At_drop_of -> Format.fprintf fmt "At_drop_of"
  | At_replica_identity -> Format.fprintf fmt "At_replica_identity"
  | At_enable_row_security -> Format.fprintf fmt "At_enable_row_security"
  | At_disable_row_security -> Format.fprintf fmt "At_disable_row_security"
  | At_force_row_security -> Format.fprintf fmt "At_force_row_security"
  | At_no_force_row_security -> Format.fprintf fmt "At_no_force_row_security"
  | At_generic_options -> Format.fprintf fmt "At_generic_options"
  | At_attach_partition -> Format.fprintf fmt "At_attach_partition"
  | At_detach_partition -> Format.fprintf fmt "At_detach_partition"
  | At_add_identity -> Format.fprintf fmt "At_add_identity"
  | At_set_identity -> Format.fprintf fmt "At_set_identity"
  | At_drop_identity -> Format.fprintf fmt "At_drop_identity"

let rec pp_role_spec_type fmt (v:role_spec_type) =
  match v with
  | Role_spec_type_undefined -> Format.fprintf fmt "Role_spec_type_undefined"
  | Rolespec_cstring -> Format.fprintf fmt "Rolespec_cstring"
  | Rolespec_current_user -> Format.fprintf fmt "Rolespec_current_user"
  | Rolespec_session_user -> Format.fprintf fmt "Rolespec_session_user"
  | Rolespec_public -> Format.fprintf fmt "Rolespec_public"

let rec pp_role_spec fmt (v:role_spec) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "roletype" pp_role_spec_type fmt v.roletype;
    Pbrt.Pp.pp_record_field ~first:false "rolename" Pbrt.Pp.pp_string fmt v.rolename;
    Pbrt.Pp.pp_record_field ~first:false "location" Pbrt.Pp.pp_int32 fmt v.location;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

let rec pp_drop_behavior fmt (v:drop_behavior) =
  match v with
  | Drop_behavior_undefined -> Format.fprintf fmt "Drop_behavior_undefined"
  | Drop_restrict -> Format.fprintf fmt "Drop_restrict"
  | Drop_cascade -> Format.fprintf fmt "Drop_cascade"

let rec pp_grant_target_type fmt (v:grant_target_type) =
  match v with
  | Grant_target_type_undefined -> Format.fprintf fmt "Grant_target_type_undefined"
  | Acl_target_object -> Format.fprintf fmt "Acl_target_object"
  | Acl_target_all_in_schema -> Format.fprintf fmt "Acl_target_all_in_schema"
  | Acl_target_defaults -> Format.fprintf fmt "Acl_target_defaults"

let rec pp_close_portal_stmt fmt (v:close_portal_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "portalname" Pbrt.Pp.pp_string fmt v.portalname;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

let rec pp_fetch_direction fmt (v:fetch_direction) =
  match v with
  | Fetch_direction_undefined -> Format.fprintf fmt "Fetch_direction_undefined"
  | Fetch_forward -> Format.fprintf fmt "Fetch_forward"
  | Fetch_backward -> Format.fprintf fmt "Fetch_backward"
  | Fetch_absolute -> Format.fprintf fmt "Fetch_absolute"
  | Fetch_relative -> Format.fprintf fmt "Fetch_relative"

let rec pp_fetch_stmt fmt (v:fetch_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "direction" pp_fetch_direction fmt v.direction;
    Pbrt.Pp.pp_record_field ~first:false "how_many" Pbrt.Pp.pp_int64 fmt v.how_many;
    Pbrt.Pp.pp_record_field ~first:false "portalname" Pbrt.Pp.pp_string fmt v.portalname;
    Pbrt.Pp.pp_record_field ~first:false "ismove" Pbrt.Pp.pp_bool fmt v.ismove;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

let rec pp_notify_stmt fmt (v:notify_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "conditionname" Pbrt.Pp.pp_string fmt v.conditionname;
    Pbrt.Pp.pp_record_field ~first:false "payload" Pbrt.Pp.pp_string fmt v.payload;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

let rec pp_listen_stmt fmt (v:listen_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "conditionname" Pbrt.Pp.pp_string fmt v.conditionname;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

let rec pp_unlisten_stmt fmt (v:unlisten_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "conditionname" Pbrt.Pp.pp_string fmt v.conditionname;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

let rec pp_transaction_stmt_kind fmt (v:transaction_stmt_kind) =
  match v with
  | Transaction_stmt_kind_undefined -> Format.fprintf fmt "Transaction_stmt_kind_undefined"
  | Trans_stmt_begin -> Format.fprintf fmt "Trans_stmt_begin"
  | Trans_stmt_start -> Format.fprintf fmt "Trans_stmt_start"
  | Trans_stmt_commit -> Format.fprintf fmt "Trans_stmt_commit"
  | Trans_stmt_rollback -> Format.fprintf fmt "Trans_stmt_rollback"
  | Trans_stmt_savepoint -> Format.fprintf fmt "Trans_stmt_savepoint"
  | Trans_stmt_release -> Format.fprintf fmt "Trans_stmt_release"
  | Trans_stmt_rollback_to -> Format.fprintf fmt "Trans_stmt_rollback_to"
  | Trans_stmt_prepare -> Format.fprintf fmt "Trans_stmt_prepare"
  | Trans_stmt_commit_prepared -> Format.fprintf fmt "Trans_stmt_commit_prepared"
  | Trans_stmt_rollback_prepared -> Format.fprintf fmt "Trans_stmt_rollback_prepared"

let rec pp_view_check_option fmt (v:view_check_option) =
  match v with
  | View_check_option_undefined -> Format.fprintf fmt "View_check_option_undefined"
  | No_check_option -> Format.fprintf fmt "No_check_option"
  | Local_check_option -> Format.fprintf fmt "Local_check_option"
  | Cascaded_check_option -> Format.fprintf fmt "Cascaded_check_option"

let rec pp_load_stmt fmt (v:load_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "filename" Pbrt.Pp.pp_string fmt v.filename;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

let rec pp_variable_set_kind fmt (v:variable_set_kind) =
  match v with
  | Variable_set_kind_undefined -> Format.fprintf fmt "Variable_set_kind_undefined"
  | Var_set_value -> Format.fprintf fmt "Var_set_value"
  | Var_set_default -> Format.fprintf fmt "Var_set_default"
  | Var_set_current -> Format.fprintf fmt "Var_set_current"
  | Var_set_multi -> Format.fprintf fmt "Var_set_multi"
  | Var_reset -> Format.fprintf fmt "Var_reset"
  | Var_reset_all -> Format.fprintf fmt "Var_reset_all"

let rec pp_variable_show_stmt fmt (v:variable_show_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "name" Pbrt.Pp.pp_string fmt v.name;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

let rec pp_discard_mode fmt (v:discard_mode) =
  match v with
  | Discard_mode_undefined -> Format.fprintf fmt "Discard_mode_undefined"
  | Discard_all -> Format.fprintf fmt "Discard_all"
  | Discard_plans -> Format.fprintf fmt "Discard_plans"
  | Discard_sequences -> Format.fprintf fmt "Discard_sequences"
  | Discard_temp -> Format.fprintf fmt "Discard_temp"

let rec pp_discard_stmt fmt (v:discard_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "target" pp_discard_mode fmt v.target;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

let rec pp_role_stmt_type fmt (v:role_stmt_type) =
  match v with
  | Role_stmt_type_undefined -> Format.fprintf fmt "Role_stmt_type_undefined"
  | Rolestmt_role -> Format.fprintf fmt "Rolestmt_role"
  | Rolestmt_user -> Format.fprintf fmt "Rolestmt_user"
  | Rolestmt_group -> Format.fprintf fmt "Rolestmt_group"

let rec pp_reindex_object_type fmt (v:reindex_object_type) =
  match v with
  | Reindex_object_type_undefined -> Format.fprintf fmt "Reindex_object_type_undefined"
  | Reindex_object_index -> Format.fprintf fmt "Reindex_object_index"
  | Reindex_object_table -> Format.fprintf fmt "Reindex_object_table"
  | Reindex_object_schema -> Format.fprintf fmt "Reindex_object_schema"
  | Reindex_object_system -> Format.fprintf fmt "Reindex_object_system"
  | Reindex_object_database -> Format.fprintf fmt "Reindex_object_database"

let rec pp_check_point_stmt fmt (v:check_point_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_unit fmt ()
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

let rec pp_coercion_context fmt (v:coercion_context) =
  match v with
  | Coercion_context_undefined -> Format.fprintf fmt "Coercion_context_undefined"
  | Coercion_implicit -> Format.fprintf fmt "Coercion_implicit"
  | Coercion_assignment -> Format.fprintf fmt "Coercion_assignment"
  | Coercion_explicit -> Format.fprintf fmt "Coercion_explicit"

let rec pp_deallocate_stmt fmt (v:deallocate_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "name" Pbrt.Pp.pp_string fmt v.name;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

let rec pp_drop_table_space_stmt fmt (v:drop_table_space_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "tablespacename" Pbrt.Pp.pp_string fmt v.tablespacename;
    Pbrt.Pp.pp_record_field ~first:false "missing_ok" Pbrt.Pp.pp_bool fmt v.missing_ok;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

let rec pp_alter_tsconfig_type fmt (v:alter_tsconfig_type) =
  match v with
  | Alter_tsconfig_type_undefined -> Format.fprintf fmt "Alter_tsconfig_type_undefined"
  | Alter_tsconfig_add_mapping -> Format.fprintf fmt "Alter_tsconfig_add_mapping"
  | Alter_tsconfig_alter_mapping_for_token -> Format.fprintf fmt "Alter_tsconfig_alter_mapping_for_token"
  | Alter_tsconfig_replace_dict -> Format.fprintf fmt "Alter_tsconfig_replace_dict"
  | Alter_tsconfig_replace_dict_for_token -> Format.fprintf fmt "Alter_tsconfig_replace_dict_for_token"
  | Alter_tsconfig_drop_mapping -> Format.fprintf fmt "Alter_tsconfig_drop_mapping"

let rec pp_drop_user_mapping_stmt fmt (v:drop_user_mapping_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "user" (Pbrt.Pp.pp_option pp_role_spec) fmt v.user;
    Pbrt.Pp.pp_record_field ~first:false "servername" Pbrt.Pp.pp_string fmt v.servername;
    Pbrt.Pp.pp_record_field ~first:false "missing_ok" Pbrt.Pp.pp_bool fmt v.missing_ok;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

let rec pp_import_foreign_schema_type fmt (v:import_foreign_schema_type) =
  match v with
  | Import_foreign_schema_type_undefined -> Format.fprintf fmt "Import_foreign_schema_type_undefined"
  | Fdw_import_schema_all -> Format.fprintf fmt "Fdw_import_schema_all"
  | Fdw_import_schema_limit_to -> Format.fprintf fmt "Fdw_import_schema_limit_to"
  | Fdw_import_schema_except -> Format.fprintf fmt "Fdw_import_schema_except"

let rec pp_alter_event_trig_stmt fmt (v:alter_event_trig_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "trigname" Pbrt.Pp.pp_string fmt v.trigname;
    Pbrt.Pp.pp_record_field ~first:false "tgenabled" Pbrt.Pp.pp_string fmt v.tgenabled;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

let rec pp_replica_identity_stmt fmt (v:replica_identity_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "identity_type" Pbrt.Pp.pp_string fmt v.identity_type;
    Pbrt.Pp.pp_record_field ~first:false "name" Pbrt.Pp.pp_string fmt v.name;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

let rec pp_def_elem_action fmt (v:def_elem_action) =
  match v with
  | Def_elem_action_undefined -> Format.fprintf fmt "Def_elem_action_undefined"
  | Defelem_unspec -> Format.fprintf fmt "Defelem_unspec"
  | Defelem_set -> Format.fprintf fmt "Defelem_set"
  | Defelem_add -> Format.fprintf fmt "Defelem_add"
  | Defelem_drop -> Format.fprintf fmt "Defelem_drop"

let rec pp_alter_subscription_type fmt (v:alter_subscription_type) =
  match v with
  | Alter_subscription_type_undefined -> Format.fprintf fmt "Alter_subscription_type_undefined"
  | Alter_subscription_options -> Format.fprintf fmt "Alter_subscription_options"
  | Alter_subscription_connection -> Format.fprintf fmt "Alter_subscription_connection"
  | Alter_subscription_publication -> Format.fprintf fmt "Alter_subscription_publication"
  | Alter_subscription_refresh -> Format.fprintf fmt "Alter_subscription_refresh"
  | Alter_subscription_enabled -> Format.fprintf fmt "Alter_subscription_enabled"

let rec pp_drop_subscription_stmt fmt (v:drop_subscription_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "subname" Pbrt.Pp.pp_string fmt v.subname;
    Pbrt.Pp.pp_record_field ~first:false "missing_ok" Pbrt.Pp.pp_bool fmt v.missing_ok;
    Pbrt.Pp.pp_record_field ~first:false "behavior" pp_drop_behavior fmt v.behavior;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

let rec pp_a_expr_kind fmt (v:a_expr_kind) =
  match v with
  | A_expr_kind_undefined -> Format.fprintf fmt "A_expr_kind_undefined"
  | Aexpr_op -> Format.fprintf fmt "Aexpr_op"
  | Aexpr_op_any -> Format.fprintf fmt "Aexpr_op_any"
  | Aexpr_op_all -> Format.fprintf fmt "Aexpr_op_all"
  | Aexpr_distinct -> Format.fprintf fmt "Aexpr_distinct"
  | Aexpr_not_distinct -> Format.fprintf fmt "Aexpr_not_distinct"
  | Aexpr_nullif -> Format.fprintf fmt "Aexpr_nullif"
  | Aexpr_of -> Format.fprintf fmt "Aexpr_of"
  | Aexpr_in -> Format.fprintf fmt "Aexpr_in"
  | Aexpr_like -> Format.fprintf fmt "Aexpr_like"
  | Aexpr_ilike -> Format.fprintf fmt "Aexpr_ilike"
  | Aexpr_similar -> Format.fprintf fmt "Aexpr_similar"
  | Aexpr_between -> Format.fprintf fmt "Aexpr_between"
  | Aexpr_not_between -> Format.fprintf fmt "Aexpr_not_between"
  | Aexpr_between_sym -> Format.fprintf fmt "Aexpr_between_sym"
  | Aexpr_not_between_sym -> Format.fprintf fmt "Aexpr_not_between_sym"
  | Aexpr_paren -> Format.fprintf fmt "Aexpr_paren"

let rec pp_param_ref fmt (v:param_ref) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "number" Pbrt.Pp.pp_int32 fmt v.number;
    Pbrt.Pp.pp_record_field ~first:false "location" Pbrt.Pp.pp_int32 fmt v.location;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

let rec pp_a_star fmt (v:a_star) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_unit fmt ()
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

let rec pp_sort_by_dir fmt (v:sort_by_dir) =
  match v with
  | Sort_by_dir_undefined -> Format.fprintf fmt "Sort_by_dir_undefined"
  | Sortby_default -> Format.fprintf fmt "Sortby_default"
  | Sortby_asc -> Format.fprintf fmt "Sortby_asc"
  | Sortby_desc -> Format.fprintf fmt "Sortby_desc"
  | Sortby_using -> Format.fprintf fmt "Sortby_using"

let rec pp_sort_by_nulls fmt (v:sort_by_nulls) =
  match v with
  | Sort_by_nulls_undefined -> Format.fprintf fmt "Sort_by_nulls_undefined"
  | Sortby_nulls_default -> Format.fprintf fmt "Sortby_nulls_default"
  | Sortby_nulls_first -> Format.fprintf fmt "Sortby_nulls_first"
  | Sortby_nulls_last -> Format.fprintf fmt "Sortby_nulls_last"

let rec pp_constr_type fmt (v:constr_type) =
  match v with
  | Constr_type_undefined -> Format.fprintf fmt "Constr_type_undefined"
  | Constr_null -> Format.fprintf fmt "Constr_null"
  | Constr_notnull -> Format.fprintf fmt "Constr_notnull"
  | Constr_default -> Format.fprintf fmt "Constr_default"
  | Constr_identity -> Format.fprintf fmt "Constr_identity"
  | Constr_generated -> Format.fprintf fmt "Constr_generated"
  | Constr_check -> Format.fprintf fmt "Constr_check"
  | Constr_primary -> Format.fprintf fmt "Constr_primary"
  | Constr_unique -> Format.fprintf fmt "Constr_unique"
  | Constr_exclusion -> Format.fprintf fmt "Constr_exclusion"
  | Constr_foreign -> Format.fprintf fmt "Constr_foreign"
  | Constr_attr_deferrable -> Format.fprintf fmt "Constr_attr_deferrable"
  | Constr_attr_not_deferrable -> Format.fprintf fmt "Constr_attr_not_deferrable"
  | Constr_attr_deferred -> Format.fprintf fmt "Constr_attr_deferred"
  | Constr_attr_immediate -> Format.fprintf fmt "Constr_attr_immediate"

let rec pp_rtekind fmt (v:rtekind) =
  match v with
  | Rtekind_undefined -> Format.fprintf fmt "Rtekind_undefined"
  | Rte_relation -> Format.fprintf fmt "Rte_relation"
  | Rte_subquery -> Format.fprintf fmt "Rte_subquery"
  | Rte_join -> Format.fprintf fmt "Rte_join"
  | Rte_function -> Format.fprintf fmt "Rte_function"
  | Rte_tablefunc -> Format.fprintf fmt "Rte_tablefunc"
  | Rte_values -> Format.fprintf fmt "Rte_values"
  | Rte_cte -> Format.fprintf fmt "Rte_cte"
  | Rte_namedtuplestore -> Format.fprintf fmt "Rte_namedtuplestore"
  | Rte_result -> Format.fprintf fmt "Rte_result"

let rec pp_wcokind fmt (v:wcokind) =
  match v with
  | Wcokind_undefined -> Format.fprintf fmt "Wcokind_undefined"
  | Wco_view_check -> Format.fprintf fmt "Wco_view_check"
  | Wco_rls_insert_check -> Format.fprintf fmt "Wco_rls_insert_check"
  | Wco_rls_update_check -> Format.fprintf fmt "Wco_rls_update_check"
  | Wco_rls_conflict_check -> Format.fprintf fmt "Wco_rls_conflict_check"

let rec pp_sort_group_clause fmt (v:sort_group_clause) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "tle_sort_group_ref" Pbrt.Pp.pp_int32 fmt v.tle_sort_group_ref;
    Pbrt.Pp.pp_record_field ~first:false "eqop" Pbrt.Pp.pp_int32 fmt v.eqop;
    Pbrt.Pp.pp_record_field ~first:false "sortop" Pbrt.Pp.pp_int32 fmt v.sortop;
    Pbrt.Pp.pp_record_field ~first:false "nulls_first" Pbrt.Pp.pp_bool fmt v.nulls_first;
    Pbrt.Pp.pp_record_field ~first:false "hashable" Pbrt.Pp.pp_bool fmt v.hashable;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

let rec pp_grouping_set_kind fmt (v:grouping_set_kind) =
  match v with
  | Grouping_set_kind_undefined -> Format.fprintf fmt "Grouping_set_kind_undefined"
  | Grouping_set_empty -> Format.fprintf fmt "Grouping_set_empty"
  | Grouping_set_simple -> Format.fprintf fmt "Grouping_set_simple"
  | Grouping_set_rollup -> Format.fprintf fmt "Grouping_set_rollup"
  | Grouping_set_cube -> Format.fprintf fmt "Grouping_set_cube"
  | Grouping_set_sets -> Format.fprintf fmt "Grouping_set_sets"

let rec pp_function_parameter_mode fmt (v:function_parameter_mode) =
  match v with
  | Function_parameter_mode_undefined -> Format.fprintf fmt "Function_parameter_mode_undefined"
  | Func_param_in -> Format.fprintf fmt "Func_param_in"
  | Func_param_out -> Format.fprintf fmt "Func_param_out"
  | Func_param_inout -> Format.fprintf fmt "Func_param_inout"
  | Func_param_variadic -> Format.fprintf fmt "Func_param_variadic"
  | Func_param_table -> Format.fprintf fmt "Func_param_table"

let rec pp_lock_clause_strength fmt (v:lock_clause_strength) =
  match v with
  | Lock_clause_strength_undefined -> Format.fprintf fmt "Lock_clause_strength_undefined"
  | Lcs_none -> Format.fprintf fmt "Lcs_none"
  | Lcs_forkeyshare -> Format.fprintf fmt "Lcs_forkeyshare"
  | Lcs_forshare -> Format.fprintf fmt "Lcs_forshare"
  | Lcs_fornokeyupdate -> Format.fprintf fmt "Lcs_fornokeyupdate"
  | Lcs_forupdate -> Format.fprintf fmt "Lcs_forupdate"

let rec pp_lock_wait_policy fmt (v:lock_wait_policy) =
  match v with
  | Lock_wait_policy_undefined -> Format.fprintf fmt "Lock_wait_policy_undefined"
  | Lock_wait_block -> Format.fprintf fmt "Lock_wait_block"
  | Lock_wait_skip -> Format.fprintf fmt "Lock_wait_skip"
  | Lock_wait_error -> Format.fprintf fmt "Lock_wait_error"

let rec pp_row_mark_clause fmt (v:row_mark_clause) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "rti" Pbrt.Pp.pp_int32 fmt v.rti;
    Pbrt.Pp.pp_record_field ~first:false "strength" pp_lock_clause_strength fmt v.strength;
    Pbrt.Pp.pp_record_field ~first:false "wait_policy" pp_lock_wait_policy fmt v.wait_policy;
    Pbrt.Pp.pp_record_field ~first:false "pushed_down" Pbrt.Pp.pp_bool fmt v.pushed_down;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

let rec pp_ctematerialize fmt (v:ctematerialize) =
  match v with
  | Ctematerialize_undefined -> Format.fprintf fmt "Ctematerialize_undefined"
  | Ctematerialize_default -> Format.fprintf fmt "Ctematerialize_default"
  | Ctematerialize_always -> Format.fprintf fmt "Ctematerialize_always"
  | Ctematerialize_never -> Format.fprintf fmt "Ctematerialize_never"

let rec pp_trigger_transition fmt (v:trigger_transition) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "name" Pbrt.Pp.pp_string fmt v.name;
    Pbrt.Pp.pp_record_field ~first:false "is_new" Pbrt.Pp.pp_bool fmt v.is_new;
    Pbrt.Pp.pp_record_field ~first:false "is_table" Pbrt.Pp.pp_bool fmt v.is_table;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

let rec pp_partition_range_datum_kind fmt (v:partition_range_datum_kind) =
  match v with
  | Partition_range_datum_kind_undefined -> Format.fprintf fmt "Partition_range_datum_kind_undefined"
  | Partition_range_datum_minvalue -> Format.fprintf fmt "Partition_range_datum_minvalue"
  | Partition_range_datum_value -> Format.fprintf fmt "Partition_range_datum_value"
  | Partition_range_datum_maxvalue -> Format.fprintf fmt "Partition_range_datum_maxvalue"

let rec pp_inline_code_block fmt (v:inline_code_block) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "source_text" Pbrt.Pp.pp_string fmt v.source_text;
    Pbrt.Pp.pp_record_field ~first:false "lang_oid" Pbrt.Pp.pp_int32 fmt v.lang_oid;
    Pbrt.Pp.pp_record_field ~first:false "lang_is_trusted" Pbrt.Pp.pp_bool fmt v.lang_is_trusted;
    Pbrt.Pp.pp_record_field ~first:false "atomic" Pbrt.Pp.pp_bool fmt v.atomic;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

let rec pp_call_context fmt (v:call_context) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "atomic" Pbrt.Pp.pp_bool fmt v.atomic;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

let rec pp_integer fmt (v:integer) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "ival" Pbrt.Pp.pp_int32 fmt v.ival;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

let rec pp_pgfloat fmt (v:pgfloat) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "str" Pbrt.Pp.pp_string fmt v.str;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

let rec pp_pgstring fmt (v:pgstring) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "str" Pbrt.Pp.pp_string fmt v.str;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

let rec pp_bit_string fmt (v:bit_string) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "str" Pbrt.Pp.pp_string fmt v.str;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

let rec pp_null fmt (v:null) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_unit fmt ()
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

let rec pp_raw_stmt fmt (v:raw_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "stmt" (Pbrt.Pp.pp_option pp_node) fmt v.stmt;
    Pbrt.Pp.pp_record_field ~first:false "stmt_location" Pbrt.Pp.pp_int32 fmt v.stmt_location;
    Pbrt.Pp.pp_record_field ~first:false "stmt_len" Pbrt.Pp.pp_int32 fmt v.stmt_len;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_node fmt (v:node) =
  match v with
  | Alias x -> Format.fprintf fmt "@[<hv2>Alias(@,%a)@]" pp_alias x
  | Range_var x -> Format.fprintf fmt "@[<hv2>Range_var(@,%a)@]" pp_range_var x
  | Table_func x -> Format.fprintf fmt "@[<hv2>Table_func(@,%a)@]" pp_table_func x
  | Expr  -> Format.fprintf fmt "Expr"
  | Var x -> Format.fprintf fmt "@[<hv2>Var(@,%a)@]" pp_var x
  | Param x -> Format.fprintf fmt "@[<hv2>Param(@,%a)@]" pp_param x
  | Aggref x -> Format.fprintf fmt "@[<hv2>Aggref(@,%a)@]" pp_aggref x
  | Grouping_func x -> Format.fprintf fmt "@[<hv2>Grouping_func(@,%a)@]" pp_grouping_func x
  | Window_func x -> Format.fprintf fmt "@[<hv2>Window_func(@,%a)@]" pp_window_func x
  | Subscripting_ref x -> Format.fprintf fmt "@[<hv2>Subscripting_ref(@,%a)@]" pp_subscripting_ref x
  | Func_expr x -> Format.fprintf fmt "@[<hv2>Func_expr(@,%a)@]" pp_func_expr x
  | Named_arg_expr x -> Format.fprintf fmt "@[<hv2>Named_arg_expr(@,%a)@]" pp_named_arg_expr x
  | Op_expr x -> Format.fprintf fmt "@[<hv2>Op_expr(@,%a)@]" pp_op_expr x
  | Distinct_expr x -> Format.fprintf fmt "@[<hv2>Distinct_expr(@,%a)@]" pp_distinct_expr x
  | Null_if_expr x -> Format.fprintf fmt "@[<hv2>Null_if_expr(@,%a)@]" pp_null_if_expr x
  | Scalar_array_op_expr x -> Format.fprintf fmt "@[<hv2>Scalar_array_op_expr(@,%a)@]" pp_scalar_array_op_expr x
  | Bool_expr x -> Format.fprintf fmt "@[<hv2>Bool_expr(@,%a)@]" pp_bool_expr x
  | Sub_link x -> Format.fprintf fmt "@[<hv2>Sub_link(@,%a)@]" pp_sub_link x
  | Sub_plan x -> Format.fprintf fmt "@[<hv2>Sub_plan(@,%a)@]" pp_sub_plan x
  | Alternative_sub_plan x -> Format.fprintf fmt "@[<hv2>Alternative_sub_plan(@,%a)@]" pp_alternative_sub_plan x
  | Field_select x -> Format.fprintf fmt "@[<hv2>Field_select(@,%a)@]" pp_field_select x
  | Field_store x -> Format.fprintf fmt "@[<hv2>Field_store(@,%a)@]" pp_field_store x
  | Relabel_type x -> Format.fprintf fmt "@[<hv2>Relabel_type(@,%a)@]" pp_relabel_type x
  | Coerce_via_io x -> Format.fprintf fmt "@[<hv2>Coerce_via_io(@,%a)@]" pp_coerce_via_io x
  | Array_coerce_expr x -> Format.fprintf fmt "@[<hv2>Array_coerce_expr(@,%a)@]" pp_array_coerce_expr x
  | Convert_rowtype_expr x -> Format.fprintf fmt "@[<hv2>Convert_rowtype_expr(@,%a)@]" pp_convert_rowtype_expr x
  | Collate_expr x -> Format.fprintf fmt "@[<hv2>Collate_expr(@,%a)@]" pp_collate_expr x
  | Case_expr x -> Format.fprintf fmt "@[<hv2>Case_expr(@,%a)@]" pp_case_expr x
  | Case_when x -> Format.fprintf fmt "@[<hv2>Case_when(@,%a)@]" pp_case_when x
  | Case_test_expr x -> Format.fprintf fmt "@[<hv2>Case_test_expr(@,%a)@]" pp_case_test_expr x
  | Array_expr x -> Format.fprintf fmt "@[<hv2>Array_expr(@,%a)@]" pp_array_expr x
  | Row_expr x -> Format.fprintf fmt "@[<hv2>Row_expr(@,%a)@]" pp_row_expr x
  | Row_compare_expr x -> Format.fprintf fmt "@[<hv2>Row_compare_expr(@,%a)@]" pp_row_compare_expr x
  | Coalesce_expr x -> Format.fprintf fmt "@[<hv2>Coalesce_expr(@,%a)@]" pp_coalesce_expr x
  | Min_max_expr x -> Format.fprintf fmt "@[<hv2>Min_max_expr(@,%a)@]" pp_min_max_expr x
  | Sqlvalue_function x -> Format.fprintf fmt "@[<hv2>Sqlvalue_function(@,%a)@]" pp_sqlvalue_function x
  | Xml_expr x -> Format.fprintf fmt "@[<hv2>Xml_expr(@,%a)@]" pp_xml_expr x
  | Null_test x -> Format.fprintf fmt "@[<hv2>Null_test(@,%a)@]" pp_null_test x
  | Boolean_test x -> Format.fprintf fmt "@[<hv2>Boolean_test(@,%a)@]" pp_boolean_test x
  | Coerce_to_domain x -> Format.fprintf fmt "@[<hv2>Coerce_to_domain(@,%a)@]" pp_coerce_to_domain x
  | Coerce_to_domain_value x -> Format.fprintf fmt "@[<hv2>Coerce_to_domain_value(@,%a)@]" pp_coerce_to_domain_value x
  | Set_to_default x -> Format.fprintf fmt "@[<hv2>Set_to_default(@,%a)@]" pp_set_to_default x
  | Current_of_expr x -> Format.fprintf fmt "@[<hv2>Current_of_expr(@,%a)@]" pp_current_of_expr x
  | Next_value_expr x -> Format.fprintf fmt "@[<hv2>Next_value_expr(@,%a)@]" pp_next_value_expr x
  | Inference_elem x -> Format.fprintf fmt "@[<hv2>Inference_elem(@,%a)@]" pp_inference_elem x
  | Target_entry x -> Format.fprintf fmt "@[<hv2>Target_entry(@,%a)@]" pp_target_entry x
  | Range_tbl_ref x -> Format.fprintf fmt "@[<hv2>Range_tbl_ref(@,%a)@]" pp_range_tbl_ref x
  | Join_expr x -> Format.fprintf fmt "@[<hv2>Join_expr(@,%a)@]" pp_join_expr x
  | From_expr x -> Format.fprintf fmt "@[<hv2>From_expr(@,%a)@]" pp_from_expr x
  | On_conflict_expr x -> Format.fprintf fmt "@[<hv2>On_conflict_expr(@,%a)@]" pp_on_conflict_expr x
  | Into_clause x -> Format.fprintf fmt "@[<hv2>Into_clause(@,%a)@]" pp_into_clause x
  | Raw_stmt x -> Format.fprintf fmt "@[<hv2>Raw_stmt(@,%a)@]" pp_raw_stmt x
  | Query x -> Format.fprintf fmt "@[<hv2>Query(@,%a)@]" pp_query x
  | Insert_stmt x -> Format.fprintf fmt "@[<hv2>Insert_stmt(@,%a)@]" pp_insert_stmt x
  | Delete_stmt x -> Format.fprintf fmt "@[<hv2>Delete_stmt(@,%a)@]" pp_delete_stmt x
  | Update_stmt x -> Format.fprintf fmt "@[<hv2>Update_stmt(@,%a)@]" pp_update_stmt x
  | Select_stmt x -> Format.fprintf fmt "@[<hv2>Select_stmt(@,%a)@]" pp_select_stmt x
  | Alter_table_stmt x -> Format.fprintf fmt "@[<hv2>Alter_table_stmt(@,%a)@]" pp_alter_table_stmt x
  | Alter_table_cmd x -> Format.fprintf fmt "@[<hv2>Alter_table_cmd(@,%a)@]" pp_alter_table_cmd x
  | Alter_domain_stmt x -> Format.fprintf fmt "@[<hv2>Alter_domain_stmt(@,%a)@]" pp_alter_domain_stmt x
  | Set_operation_stmt x -> Format.fprintf fmt "@[<hv2>Set_operation_stmt(@,%a)@]" pp_set_operation_stmt x
  | Grant_stmt x -> Format.fprintf fmt "@[<hv2>Grant_stmt(@,%a)@]" pp_grant_stmt x
  | Grant_role_stmt x -> Format.fprintf fmt "@[<hv2>Grant_role_stmt(@,%a)@]" pp_grant_role_stmt x
  | Alter_default_privileges_stmt x -> Format.fprintf fmt "@[<hv2>Alter_default_privileges_stmt(@,%a)@]" pp_alter_default_privileges_stmt x
  | Close_portal_stmt x -> Format.fprintf fmt "@[<hv2>Close_portal_stmt(@,%a)@]" pp_close_portal_stmt x
  | Cluster_stmt x -> Format.fprintf fmt "@[<hv2>Cluster_stmt(@,%a)@]" pp_cluster_stmt x
  | Copy_stmt x -> Format.fprintf fmt "@[<hv2>Copy_stmt(@,%a)@]" pp_copy_stmt x
  | Create_stmt x -> Format.fprintf fmt "@[<hv2>Create_stmt(@,%a)@]" pp_create_stmt x
  | Define_stmt x -> Format.fprintf fmt "@[<hv2>Define_stmt(@,%a)@]" pp_define_stmt x
  | Drop_stmt x -> Format.fprintf fmt "@[<hv2>Drop_stmt(@,%a)@]" pp_drop_stmt x
  | Truncate_stmt x -> Format.fprintf fmt "@[<hv2>Truncate_stmt(@,%a)@]" pp_truncate_stmt x
  | Comment_stmt x -> Format.fprintf fmt "@[<hv2>Comment_stmt(@,%a)@]" pp_comment_stmt x
  | Fetch_stmt x -> Format.fprintf fmt "@[<hv2>Fetch_stmt(@,%a)@]" pp_fetch_stmt x
  | Index_stmt x -> Format.fprintf fmt "@[<hv2>Index_stmt(@,%a)@]" pp_index_stmt x
  | Create_function_stmt x -> Format.fprintf fmt "@[<hv2>Create_function_stmt(@,%a)@]" pp_create_function_stmt x
  | Alter_function_stmt x -> Format.fprintf fmt "@[<hv2>Alter_function_stmt(@,%a)@]" pp_alter_function_stmt x
  | Do_stmt x -> Format.fprintf fmt "@[<hv2>Do_stmt(@,%a)@]" pp_do_stmt x
  | Rename_stmt x -> Format.fprintf fmt "@[<hv2>Rename_stmt(@,%a)@]" pp_rename_stmt x
  | Rule_stmt x -> Format.fprintf fmt "@[<hv2>Rule_stmt(@,%a)@]" pp_rule_stmt x
  | Notify_stmt x -> Format.fprintf fmt "@[<hv2>Notify_stmt(@,%a)@]" pp_notify_stmt x
  | Listen_stmt x -> Format.fprintf fmt "@[<hv2>Listen_stmt(@,%a)@]" pp_listen_stmt x
  | Unlisten_stmt x -> Format.fprintf fmt "@[<hv2>Unlisten_stmt(@,%a)@]" pp_unlisten_stmt x
  | Transaction_stmt x -> Format.fprintf fmt "@[<hv2>Transaction_stmt(@,%a)@]" pp_transaction_stmt x
  | View_stmt x -> Format.fprintf fmt "@[<hv2>View_stmt(@,%a)@]" pp_view_stmt x
  | Load_stmt x -> Format.fprintf fmt "@[<hv2>Load_stmt(@,%a)@]" pp_load_stmt x
  | Create_domain_stmt x -> Format.fprintf fmt "@[<hv2>Create_domain_stmt(@,%a)@]" pp_create_domain_stmt x
  | Createdb_stmt x -> Format.fprintf fmt "@[<hv2>Createdb_stmt(@,%a)@]" pp_createdb_stmt x
  | Dropdb_stmt x -> Format.fprintf fmt "@[<hv2>Dropdb_stmt(@,%a)@]" pp_dropdb_stmt x
  | Vacuum_stmt x -> Format.fprintf fmt "@[<hv2>Vacuum_stmt(@,%a)@]" pp_vacuum_stmt x
  | Explain_stmt x -> Format.fprintf fmt "@[<hv2>Explain_stmt(@,%a)@]" pp_explain_stmt x
  | Create_table_as_stmt x -> Format.fprintf fmt "@[<hv2>Create_table_as_stmt(@,%a)@]" pp_create_table_as_stmt x
  | Create_seq_stmt x -> Format.fprintf fmt "@[<hv2>Create_seq_stmt(@,%a)@]" pp_create_seq_stmt x
  | Alter_seq_stmt x -> Format.fprintf fmt "@[<hv2>Alter_seq_stmt(@,%a)@]" pp_alter_seq_stmt x
  | Variable_set_stmt x -> Format.fprintf fmt "@[<hv2>Variable_set_stmt(@,%a)@]" pp_variable_set_stmt x
  | Variable_show_stmt x -> Format.fprintf fmt "@[<hv2>Variable_show_stmt(@,%a)@]" pp_variable_show_stmt x
  | Discard_stmt x -> Format.fprintf fmt "@[<hv2>Discard_stmt(@,%a)@]" pp_discard_stmt x
  | Create_trig_stmt x -> Format.fprintf fmt "@[<hv2>Create_trig_stmt(@,%a)@]" pp_create_trig_stmt x
  | Create_plang_stmt x -> Format.fprintf fmt "@[<hv2>Create_plang_stmt(@,%a)@]" pp_create_plang_stmt x
  | Create_role_stmt x -> Format.fprintf fmt "@[<hv2>Create_role_stmt(@,%a)@]" pp_create_role_stmt x
  | Alter_role_stmt x -> Format.fprintf fmt "@[<hv2>Alter_role_stmt(@,%a)@]" pp_alter_role_stmt x
  | Drop_role_stmt x -> Format.fprintf fmt "@[<hv2>Drop_role_stmt(@,%a)@]" pp_drop_role_stmt x
  | Lock_stmt x -> Format.fprintf fmt "@[<hv2>Lock_stmt(@,%a)@]" pp_lock_stmt x
  | Constraints_set_stmt x -> Format.fprintf fmt "@[<hv2>Constraints_set_stmt(@,%a)@]" pp_constraints_set_stmt x
  | Reindex_stmt x -> Format.fprintf fmt "@[<hv2>Reindex_stmt(@,%a)@]" pp_reindex_stmt x
  | Check_point_stmt  -> Format.fprintf fmt "Check_point_stmt"
  | Create_schema_stmt x -> Format.fprintf fmt "@[<hv2>Create_schema_stmt(@,%a)@]" pp_create_schema_stmt x
  | Alter_database_stmt x -> Format.fprintf fmt "@[<hv2>Alter_database_stmt(@,%a)@]" pp_alter_database_stmt x
  | Alter_database_set_stmt x -> Format.fprintf fmt "@[<hv2>Alter_database_set_stmt(@,%a)@]" pp_alter_database_set_stmt x
  | Alter_role_set_stmt x -> Format.fprintf fmt "@[<hv2>Alter_role_set_stmt(@,%a)@]" pp_alter_role_set_stmt x
  | Create_conversion_stmt x -> Format.fprintf fmt "@[<hv2>Create_conversion_stmt(@,%a)@]" pp_create_conversion_stmt x
  | Create_cast_stmt x -> Format.fprintf fmt "@[<hv2>Create_cast_stmt(@,%a)@]" pp_create_cast_stmt x
  | Create_op_class_stmt x -> Format.fprintf fmt "@[<hv2>Create_op_class_stmt(@,%a)@]" pp_create_op_class_stmt x
  | Create_op_family_stmt x -> Format.fprintf fmt "@[<hv2>Create_op_family_stmt(@,%a)@]" pp_create_op_family_stmt x
  | Alter_op_family_stmt x -> Format.fprintf fmt "@[<hv2>Alter_op_family_stmt(@,%a)@]" pp_alter_op_family_stmt x
  | Prepare_stmt x -> Format.fprintf fmt "@[<hv2>Prepare_stmt(@,%a)@]" pp_prepare_stmt x
  | Execute_stmt x -> Format.fprintf fmt "@[<hv2>Execute_stmt(@,%a)@]" pp_execute_stmt x
  | Deallocate_stmt x -> Format.fprintf fmt "@[<hv2>Deallocate_stmt(@,%a)@]" pp_deallocate_stmt x
  | Declare_cursor_stmt x -> Format.fprintf fmt "@[<hv2>Declare_cursor_stmt(@,%a)@]" pp_declare_cursor_stmt x
  | Create_table_space_stmt x -> Format.fprintf fmt "@[<hv2>Create_table_space_stmt(@,%a)@]" pp_create_table_space_stmt x
  | Drop_table_space_stmt x -> Format.fprintf fmt "@[<hv2>Drop_table_space_stmt(@,%a)@]" pp_drop_table_space_stmt x
  | Alter_object_depends_stmt x -> Format.fprintf fmt "@[<hv2>Alter_object_depends_stmt(@,%a)@]" pp_alter_object_depends_stmt x
  | Alter_object_schema_stmt x -> Format.fprintf fmt "@[<hv2>Alter_object_schema_stmt(@,%a)@]" pp_alter_object_schema_stmt x
  | Alter_owner_stmt x -> Format.fprintf fmt "@[<hv2>Alter_owner_stmt(@,%a)@]" pp_alter_owner_stmt x
  | Alter_operator_stmt x -> Format.fprintf fmt "@[<hv2>Alter_operator_stmt(@,%a)@]" pp_alter_operator_stmt x
  | Alter_type_stmt x -> Format.fprintf fmt "@[<hv2>Alter_type_stmt(@,%a)@]" pp_alter_type_stmt x
  | Drop_owned_stmt x -> Format.fprintf fmt "@[<hv2>Drop_owned_stmt(@,%a)@]" pp_drop_owned_stmt x
  | Reassign_owned_stmt x -> Format.fprintf fmt "@[<hv2>Reassign_owned_stmt(@,%a)@]" pp_reassign_owned_stmt x
  | Composite_type_stmt x -> Format.fprintf fmt "@[<hv2>Composite_type_stmt(@,%a)@]" pp_composite_type_stmt x
  | Create_enum_stmt x -> Format.fprintf fmt "@[<hv2>Create_enum_stmt(@,%a)@]" pp_create_enum_stmt x
  | Create_range_stmt x -> Format.fprintf fmt "@[<hv2>Create_range_stmt(@,%a)@]" pp_create_range_stmt x
  | Alter_enum_stmt x -> Format.fprintf fmt "@[<hv2>Alter_enum_stmt(@,%a)@]" pp_alter_enum_stmt x
  | Alter_tsdictionary_stmt x -> Format.fprintf fmt "@[<hv2>Alter_tsdictionary_stmt(@,%a)@]" pp_alter_tsdictionary_stmt x
  | Alter_tsconfiguration_stmt x -> Format.fprintf fmt "@[<hv2>Alter_tsconfiguration_stmt(@,%a)@]" pp_alter_tsconfiguration_stmt x
  | Create_fdw_stmt x -> Format.fprintf fmt "@[<hv2>Create_fdw_stmt(@,%a)@]" pp_create_fdw_stmt x
  | Alter_fdw_stmt x -> Format.fprintf fmt "@[<hv2>Alter_fdw_stmt(@,%a)@]" pp_alter_fdw_stmt x
  | Create_foreign_server_stmt x -> Format.fprintf fmt "@[<hv2>Create_foreign_server_stmt(@,%a)@]" pp_create_foreign_server_stmt x
  | Alter_foreign_server_stmt x -> Format.fprintf fmt "@[<hv2>Alter_foreign_server_stmt(@,%a)@]" pp_alter_foreign_server_stmt x
  | Create_user_mapping_stmt x -> Format.fprintf fmt "@[<hv2>Create_user_mapping_stmt(@,%a)@]" pp_create_user_mapping_stmt x
  | Alter_user_mapping_stmt x -> Format.fprintf fmt "@[<hv2>Alter_user_mapping_stmt(@,%a)@]" pp_alter_user_mapping_stmt x
  | Drop_user_mapping_stmt x -> Format.fprintf fmt "@[<hv2>Drop_user_mapping_stmt(@,%a)@]" pp_drop_user_mapping_stmt x
  | Alter_table_space_options_stmt x -> Format.fprintf fmt "@[<hv2>Alter_table_space_options_stmt(@,%a)@]" pp_alter_table_space_options_stmt x
  | Alter_table_move_all_stmt x -> Format.fprintf fmt "@[<hv2>Alter_table_move_all_stmt(@,%a)@]" pp_alter_table_move_all_stmt x
  | Sec_label_stmt x -> Format.fprintf fmt "@[<hv2>Sec_label_stmt(@,%a)@]" pp_sec_label_stmt x
  | Create_foreign_table_stmt x -> Format.fprintf fmt "@[<hv2>Create_foreign_table_stmt(@,%a)@]" pp_create_foreign_table_stmt x
  | Import_foreign_schema_stmt x -> Format.fprintf fmt "@[<hv2>Import_foreign_schema_stmt(@,%a)@]" pp_import_foreign_schema_stmt x
  | Create_extension_stmt x -> Format.fprintf fmt "@[<hv2>Create_extension_stmt(@,%a)@]" pp_create_extension_stmt x
  | Alter_extension_stmt x -> Format.fprintf fmt "@[<hv2>Alter_extension_stmt(@,%a)@]" pp_alter_extension_stmt x
  | Alter_extension_contents_stmt x -> Format.fprintf fmt "@[<hv2>Alter_extension_contents_stmt(@,%a)@]" pp_alter_extension_contents_stmt x
  | Create_event_trig_stmt x -> Format.fprintf fmt "@[<hv2>Create_event_trig_stmt(@,%a)@]" pp_create_event_trig_stmt x
  | Alter_event_trig_stmt x -> Format.fprintf fmt "@[<hv2>Alter_event_trig_stmt(@,%a)@]" pp_alter_event_trig_stmt x
  | Refresh_mat_view_stmt x -> Format.fprintf fmt "@[<hv2>Refresh_mat_view_stmt(@,%a)@]" pp_refresh_mat_view_stmt x
  | Replica_identity_stmt x -> Format.fprintf fmt "@[<hv2>Replica_identity_stmt(@,%a)@]" pp_replica_identity_stmt x
  | Alter_system_stmt x -> Format.fprintf fmt "@[<hv2>Alter_system_stmt(@,%a)@]" pp_alter_system_stmt x
  | Create_policy_stmt x -> Format.fprintf fmt "@[<hv2>Create_policy_stmt(@,%a)@]" pp_create_policy_stmt x
  | Alter_policy_stmt x -> Format.fprintf fmt "@[<hv2>Alter_policy_stmt(@,%a)@]" pp_alter_policy_stmt x
  | Create_transform_stmt x -> Format.fprintf fmt "@[<hv2>Create_transform_stmt(@,%a)@]" pp_create_transform_stmt x
  | Create_am_stmt x -> Format.fprintf fmt "@[<hv2>Create_am_stmt(@,%a)@]" pp_create_am_stmt x
  | Create_publication_stmt x -> Format.fprintf fmt "@[<hv2>Create_publication_stmt(@,%a)@]" pp_create_publication_stmt x
  | Alter_publication_stmt x -> Format.fprintf fmt "@[<hv2>Alter_publication_stmt(@,%a)@]" pp_alter_publication_stmt x
  | Create_subscription_stmt x -> Format.fprintf fmt "@[<hv2>Create_subscription_stmt(@,%a)@]" pp_create_subscription_stmt x
  | Alter_subscription_stmt x -> Format.fprintf fmt "@[<hv2>Alter_subscription_stmt(@,%a)@]" pp_alter_subscription_stmt x
  | Drop_subscription_stmt x -> Format.fprintf fmt "@[<hv2>Drop_subscription_stmt(@,%a)@]" pp_drop_subscription_stmt x
  | Create_stats_stmt x -> Format.fprintf fmt "@[<hv2>Create_stats_stmt(@,%a)@]" pp_create_stats_stmt x
  | Alter_collation_stmt x -> Format.fprintf fmt "@[<hv2>Alter_collation_stmt(@,%a)@]" pp_alter_collation_stmt x
  | Call_stmt x -> Format.fprintf fmt "@[<hv2>Call_stmt(@,%a)@]" pp_call_stmt x
  | Alter_stats_stmt x -> Format.fprintf fmt "@[<hv2>Alter_stats_stmt(@,%a)@]" pp_alter_stats_stmt x
  | A_expr x -> Format.fprintf fmt "@[<hv2>A_expr(@,%a)@]" pp_a_expr x
  | Column_ref x -> Format.fprintf fmt "@[<hv2>Column_ref(@,%a)@]" pp_column_ref x
  | Param_ref x -> Format.fprintf fmt "@[<hv2>Param_ref(@,%a)@]" pp_param_ref x
  | A_const x -> Format.fprintf fmt "@[<hv2>A_const(@,%a)@]" pp_a_const x
  | Func_call x -> Format.fprintf fmt "@[<hv2>Func_call(@,%a)@]" pp_func_call x
  | A_star  -> Format.fprintf fmt "A_star"
  | A_indices x -> Format.fprintf fmt "@[<hv2>A_indices(@,%a)@]" pp_a_indices x
  | A_indirection x -> Format.fprintf fmt "@[<hv2>A_indirection(@,%a)@]" pp_a_indirection x
  | A_array_expr x -> Format.fprintf fmt "@[<hv2>A_array_expr(@,%a)@]" pp_a_array_expr x
  | Res_target x -> Format.fprintf fmt "@[<hv2>Res_target(@,%a)@]" pp_res_target x
  | Multi_assign_ref x -> Format.fprintf fmt "@[<hv2>Multi_assign_ref(@,%a)@]" pp_multi_assign_ref x
  | Type_cast x -> Format.fprintf fmt "@[<hv2>Type_cast(@,%a)@]" pp_type_cast x
  | Collate_clause x -> Format.fprintf fmt "@[<hv2>Collate_clause(@,%a)@]" pp_collate_clause x
  | Sort_by x -> Format.fprintf fmt "@[<hv2>Sort_by(@,%a)@]" pp_sort_by x
  | Window_def x -> Format.fprintf fmt "@[<hv2>Window_def(@,%a)@]" pp_window_def x
  | Range_subselect x -> Format.fprintf fmt "@[<hv2>Range_subselect(@,%a)@]" pp_range_subselect x
  | Range_function x -> Format.fprintf fmt "@[<hv2>Range_function(@,%a)@]" pp_range_function x
  | Range_table_sample x -> Format.fprintf fmt "@[<hv2>Range_table_sample(@,%a)@]" pp_range_table_sample x
  | Range_table_func x -> Format.fprintf fmt "@[<hv2>Range_table_func(@,%a)@]" pp_range_table_func x
  | Range_table_func_col x -> Format.fprintf fmt "@[<hv2>Range_table_func_col(@,%a)@]" pp_range_table_func_col x
  | Type_name x -> Format.fprintf fmt "@[<hv2>Type_name(@,%a)@]" pp_type_name x
  | Column_def x -> Format.fprintf fmt "@[<hv2>Column_def(@,%a)@]" pp_column_def x
  | Index_elem x -> Format.fprintf fmt "@[<hv2>Index_elem(@,%a)@]" pp_index_elem x
  | Constraint x -> Format.fprintf fmt "@[<hv2>Constraint(@,%a)@]" pp_constraint_ x
  | Def_elem x -> Format.fprintf fmt "@[<hv2>Def_elem(@,%a)@]" pp_def_elem x
  | Range_tbl_entry x -> Format.fprintf fmt "@[<hv2>Range_tbl_entry(@,%a)@]" pp_range_tbl_entry x
  | Range_tbl_function x -> Format.fprintf fmt "@[<hv2>Range_tbl_function(@,%a)@]" pp_range_tbl_function x
  | Table_sample_clause x -> Format.fprintf fmt "@[<hv2>Table_sample_clause(@,%a)@]" pp_table_sample_clause x
  | With_check_option x -> Format.fprintf fmt "@[<hv2>With_check_option(@,%a)@]" pp_with_check_option x
  | Sort_group_clause x -> Format.fprintf fmt "@[<hv2>Sort_group_clause(@,%a)@]" pp_sort_group_clause x
  | Grouping_set x -> Format.fprintf fmt "@[<hv2>Grouping_set(@,%a)@]" pp_grouping_set x
  | Window_clause x -> Format.fprintf fmt "@[<hv2>Window_clause(@,%a)@]" pp_window_clause x
  | Object_with_args x -> Format.fprintf fmt "@[<hv2>Object_with_args(@,%a)@]" pp_object_with_args x
  | Access_priv x -> Format.fprintf fmt "@[<hv2>Access_priv(@,%a)@]" pp_access_priv x
  | Create_op_class_item x -> Format.fprintf fmt "@[<hv2>Create_op_class_item(@,%a)@]" pp_create_op_class_item x
  | Table_like_clause x -> Format.fprintf fmt "@[<hv2>Table_like_clause(@,%a)@]" pp_table_like_clause x
  | Function_parameter x -> Format.fprintf fmt "@[<hv2>Function_parameter(@,%a)@]" pp_function_parameter x
  | Locking_clause x -> Format.fprintf fmt "@[<hv2>Locking_clause(@,%a)@]" pp_locking_clause x
  | Row_mark_clause x -> Format.fprintf fmt "@[<hv2>Row_mark_clause(@,%a)@]" pp_row_mark_clause x
  | Xml_serialize x -> Format.fprintf fmt "@[<hv2>Xml_serialize(@,%a)@]" pp_xml_serialize x
  | With_clause x -> Format.fprintf fmt "@[<hv2>With_clause(@,%a)@]" pp_with_clause x
  | Infer_clause x -> Format.fprintf fmt "@[<hv2>Infer_clause(@,%a)@]" pp_infer_clause x
  | On_conflict_clause x -> Format.fprintf fmt "@[<hv2>On_conflict_clause(@,%a)@]" pp_on_conflict_clause x
  | Common_table_expr x -> Format.fprintf fmt "@[<hv2>Common_table_expr(@,%a)@]" pp_common_table_expr x
  | Role_spec x -> Format.fprintf fmt "@[<hv2>Role_spec(@,%a)@]" pp_role_spec x
  | Trigger_transition x -> Format.fprintf fmt "@[<hv2>Trigger_transition(@,%a)@]" pp_trigger_transition x
  | Partition_elem x -> Format.fprintf fmt "@[<hv2>Partition_elem(@,%a)@]" pp_partition_elem x
  | Partition_spec x -> Format.fprintf fmt "@[<hv2>Partition_spec(@,%a)@]" pp_partition_spec x
  | Partition_bound_spec x -> Format.fprintf fmt "@[<hv2>Partition_bound_spec(@,%a)@]" pp_partition_bound_spec x
  | Partition_range_datum x -> Format.fprintf fmt "@[<hv2>Partition_range_datum(@,%a)@]" pp_partition_range_datum x
  | Partition_cmd x -> Format.fprintf fmt "@[<hv2>Partition_cmd(@,%a)@]" pp_partition_cmd x
  | Vacuum_relation x -> Format.fprintf fmt "@[<hv2>Vacuum_relation(@,%a)@]" pp_vacuum_relation x
  | Inline_code_block x -> Format.fprintf fmt "@[<hv2>Inline_code_block(@,%a)@]" pp_inline_code_block x
  | Call_context x -> Format.fprintf fmt "@[<hv2>Call_context(@,%a)@]" pp_call_context x
  | Integer x -> Format.fprintf fmt "@[<hv2>Integer(@,%a)@]" pp_integer x
  | Float x -> Format.fprintf fmt "@[<hv2>Float(@,%a)@]" pp_pgfloat x
  | String x -> Format.fprintf fmt "@[<hv2>String(@,%a)@]" pp_pgstring x
  | Bit_string x -> Format.fprintf fmt "@[<hv2>Bit_string(@,%a)@]" pp_bit_string x
  | Null  -> Format.fprintf fmt "Null"
  | List x -> Format.fprintf fmt "@[<hv2>List(@,%a)@]" pp_pglist x
  | Int_list x -> Format.fprintf fmt "@[<hv2>Int_list(@,%a)@]" pp_int_list x
  | Oid_list x -> Format.fprintf fmt "@[<hv2>Oid_list(@,%a)@]" pp_oid_list x

and pp_alias fmt (v:alias) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "aliasname" Pbrt.Pp.pp_string fmt v.aliasname;
    Pbrt.Pp.pp_record_field ~first:false "colnames" (Pbrt.Pp.pp_list pp_node) fmt v.colnames;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_range_var fmt (v:range_var) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "catalogname" Pbrt.Pp.pp_string fmt v.catalogname;
    Pbrt.Pp.pp_record_field ~first:false "schemaname" Pbrt.Pp.pp_string fmt v.schemaname;
    Pbrt.Pp.pp_record_field ~first:false "relname" Pbrt.Pp.pp_string fmt v.relname;
    Pbrt.Pp.pp_record_field ~first:false "inh" Pbrt.Pp.pp_bool fmt v.inh;
    Pbrt.Pp.pp_record_field ~first:false "relpersistence" Pbrt.Pp.pp_string fmt v.relpersistence;
    Pbrt.Pp.pp_record_field ~first:false "alias" (Pbrt.Pp.pp_option pp_alias) fmt v.alias;
    Pbrt.Pp.pp_record_field ~first:false "location" Pbrt.Pp.pp_int32 fmt v.location;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_table_func fmt (v:table_func) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "ns_uris" (Pbrt.Pp.pp_list pp_node) fmt v.ns_uris;
    Pbrt.Pp.pp_record_field ~first:false "ns_names" (Pbrt.Pp.pp_list pp_node) fmt v.ns_names;
    Pbrt.Pp.pp_record_field ~first:false "docexpr" (Pbrt.Pp.pp_option pp_node) fmt v.docexpr;
    Pbrt.Pp.pp_record_field ~first:false "rowexpr" (Pbrt.Pp.pp_option pp_node) fmt v.rowexpr;
    Pbrt.Pp.pp_record_field ~first:false "colnames" (Pbrt.Pp.pp_list pp_node) fmt v.colnames;
    Pbrt.Pp.pp_record_field ~first:false "coltypes" (Pbrt.Pp.pp_list pp_node) fmt v.coltypes;
    Pbrt.Pp.pp_record_field ~first:false "coltypmods" (Pbrt.Pp.pp_list pp_node) fmt v.coltypmods;
    Pbrt.Pp.pp_record_field ~first:false "colcollations" (Pbrt.Pp.pp_list pp_node) fmt v.colcollations;
    Pbrt.Pp.pp_record_field ~first:false "colexprs" (Pbrt.Pp.pp_list pp_node) fmt v.colexprs;
    Pbrt.Pp.pp_record_field ~first:false "coldefexprs" (Pbrt.Pp.pp_list pp_node) fmt v.coldefexprs;
    Pbrt.Pp.pp_record_field ~first:false "notnulls" (Pbrt.Pp.pp_list Pbrt.Pp.pp_int64) fmt v.notnulls;
    Pbrt.Pp.pp_record_field ~first:false "ordinalitycol" Pbrt.Pp.pp_int32 fmt v.ordinalitycol;
    Pbrt.Pp.pp_record_field ~first:false "location" Pbrt.Pp.pp_int32 fmt v.location;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_var fmt (v:var) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "xpr" (Pbrt.Pp.pp_option pp_node) fmt v.xpr;
    Pbrt.Pp.pp_record_field ~first:false "varno" Pbrt.Pp.pp_int32 fmt v.varno;
    Pbrt.Pp.pp_record_field ~first:false "varattno" Pbrt.Pp.pp_int32 fmt v.varattno;
    Pbrt.Pp.pp_record_field ~first:false "vartype" Pbrt.Pp.pp_int32 fmt v.vartype;
    Pbrt.Pp.pp_record_field ~first:false "vartypmod" Pbrt.Pp.pp_int32 fmt v.vartypmod;
    Pbrt.Pp.pp_record_field ~first:false "varcollid" Pbrt.Pp.pp_int32 fmt v.varcollid;
    Pbrt.Pp.pp_record_field ~first:false "varlevelsup" Pbrt.Pp.pp_int32 fmt v.varlevelsup;
    Pbrt.Pp.pp_record_field ~first:false "varnosyn" Pbrt.Pp.pp_int32 fmt v.varnosyn;
    Pbrt.Pp.pp_record_field ~first:false "varattnosyn" Pbrt.Pp.pp_int32 fmt v.varattnosyn;
    Pbrt.Pp.pp_record_field ~first:false "location" Pbrt.Pp.pp_int32 fmt v.location;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_param fmt (v:param) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "xpr" (Pbrt.Pp.pp_option pp_node) fmt v.xpr;
    Pbrt.Pp.pp_record_field ~first:false "paramkind" pp_param_kind fmt v.paramkind;
    Pbrt.Pp.pp_record_field ~first:false "paramid" Pbrt.Pp.pp_int32 fmt v.paramid;
    Pbrt.Pp.pp_record_field ~first:false "paramtype" Pbrt.Pp.pp_int32 fmt v.paramtype;
    Pbrt.Pp.pp_record_field ~first:false "paramtypmod" Pbrt.Pp.pp_int32 fmt v.paramtypmod;
    Pbrt.Pp.pp_record_field ~first:false "paramcollid" Pbrt.Pp.pp_int32 fmt v.paramcollid;
    Pbrt.Pp.pp_record_field ~first:false "location" Pbrt.Pp.pp_int32 fmt v.location;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_aggref fmt (v:aggref) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "xpr" (Pbrt.Pp.pp_option pp_node) fmt v.xpr;
    Pbrt.Pp.pp_record_field ~first:false "aggfnoid" Pbrt.Pp.pp_int32 fmt v.aggfnoid;
    Pbrt.Pp.pp_record_field ~first:false "aggtype" Pbrt.Pp.pp_int32 fmt v.aggtype;
    Pbrt.Pp.pp_record_field ~first:false "aggcollid" Pbrt.Pp.pp_int32 fmt v.aggcollid;
    Pbrt.Pp.pp_record_field ~first:false "inputcollid" Pbrt.Pp.pp_int32 fmt v.inputcollid;
    Pbrt.Pp.pp_record_field ~first:false "aggtranstype" Pbrt.Pp.pp_int32 fmt v.aggtranstype;
    Pbrt.Pp.pp_record_field ~first:false "aggargtypes" (Pbrt.Pp.pp_list pp_node) fmt v.aggargtypes;
    Pbrt.Pp.pp_record_field ~first:false "aggdirectargs" (Pbrt.Pp.pp_list pp_node) fmt v.aggdirectargs;
    Pbrt.Pp.pp_record_field ~first:false "args" (Pbrt.Pp.pp_list pp_node) fmt v.args;
    Pbrt.Pp.pp_record_field ~first:false "aggorder" (Pbrt.Pp.pp_list pp_node) fmt v.aggorder;
    Pbrt.Pp.pp_record_field ~first:false "aggdistinct" (Pbrt.Pp.pp_list pp_node) fmt v.aggdistinct;
    Pbrt.Pp.pp_record_field ~first:false "aggfilter" (Pbrt.Pp.pp_option pp_node) fmt v.aggfilter;
    Pbrt.Pp.pp_record_field ~first:false "aggstar" Pbrt.Pp.pp_bool fmt v.aggstar;
    Pbrt.Pp.pp_record_field ~first:false "aggvariadic" Pbrt.Pp.pp_bool fmt v.aggvariadic;
    Pbrt.Pp.pp_record_field ~first:false "aggkind" Pbrt.Pp.pp_string fmt v.aggkind;
    Pbrt.Pp.pp_record_field ~first:false "agglevelsup" Pbrt.Pp.pp_int32 fmt v.agglevelsup;
    Pbrt.Pp.pp_record_field ~first:false "aggsplit" pp_agg_split fmt v.aggsplit;
    Pbrt.Pp.pp_record_field ~first:false "location" Pbrt.Pp.pp_int32 fmt v.location;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_grouping_func fmt (v:grouping_func) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "xpr" (Pbrt.Pp.pp_option pp_node) fmt v.xpr;
    Pbrt.Pp.pp_record_field ~first:false "args" (Pbrt.Pp.pp_list pp_node) fmt v.args;
    Pbrt.Pp.pp_record_field ~first:false "refs" (Pbrt.Pp.pp_list pp_node) fmt v.refs;
    Pbrt.Pp.pp_record_field ~first:false "cols" (Pbrt.Pp.pp_list pp_node) fmt v.cols;
    Pbrt.Pp.pp_record_field ~first:false "agglevelsup" Pbrt.Pp.pp_int32 fmt v.agglevelsup;
    Pbrt.Pp.pp_record_field ~first:false "location" Pbrt.Pp.pp_int32 fmt v.location;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_window_func fmt (v:window_func) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "xpr" (Pbrt.Pp.pp_option pp_node) fmt v.xpr;
    Pbrt.Pp.pp_record_field ~first:false "winfnoid" Pbrt.Pp.pp_int32 fmt v.winfnoid;
    Pbrt.Pp.pp_record_field ~first:false "wintype" Pbrt.Pp.pp_int32 fmt v.wintype;
    Pbrt.Pp.pp_record_field ~first:false "wincollid" Pbrt.Pp.pp_int32 fmt v.wincollid;
    Pbrt.Pp.pp_record_field ~first:false "inputcollid" Pbrt.Pp.pp_int32 fmt v.inputcollid;
    Pbrt.Pp.pp_record_field ~first:false "args" (Pbrt.Pp.pp_list pp_node) fmt v.args;
    Pbrt.Pp.pp_record_field ~first:false "aggfilter" (Pbrt.Pp.pp_option pp_node) fmt v.aggfilter;
    Pbrt.Pp.pp_record_field ~first:false "winref" Pbrt.Pp.pp_int32 fmt v.winref;
    Pbrt.Pp.pp_record_field ~first:false "winstar" Pbrt.Pp.pp_bool fmt v.winstar;
    Pbrt.Pp.pp_record_field ~first:false "winagg" Pbrt.Pp.pp_bool fmt v.winagg;
    Pbrt.Pp.pp_record_field ~first:false "location" Pbrt.Pp.pp_int32 fmt v.location;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_subscripting_ref fmt (v:subscripting_ref) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "xpr" (Pbrt.Pp.pp_option pp_node) fmt v.xpr;
    Pbrt.Pp.pp_record_field ~first:false "refcontainertype" Pbrt.Pp.pp_int32 fmt v.refcontainertype;
    Pbrt.Pp.pp_record_field ~first:false "refelemtype" Pbrt.Pp.pp_int32 fmt v.refelemtype;
    Pbrt.Pp.pp_record_field ~first:false "reftypmod" Pbrt.Pp.pp_int32 fmt v.reftypmod;
    Pbrt.Pp.pp_record_field ~first:false "refcollid" Pbrt.Pp.pp_int32 fmt v.refcollid;
    Pbrt.Pp.pp_record_field ~first:false "refupperindexpr" (Pbrt.Pp.pp_list pp_node) fmt v.refupperindexpr;
    Pbrt.Pp.pp_record_field ~first:false "reflowerindexpr" (Pbrt.Pp.pp_list pp_node) fmt v.reflowerindexpr;
    Pbrt.Pp.pp_record_field ~first:false "refexpr" (Pbrt.Pp.pp_option pp_node) fmt v.refexpr;
    Pbrt.Pp.pp_record_field ~first:false "refassgnexpr" (Pbrt.Pp.pp_option pp_node) fmt v.refassgnexpr;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_func_expr fmt (v:func_expr) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "xpr" (Pbrt.Pp.pp_option pp_node) fmt v.xpr;
    Pbrt.Pp.pp_record_field ~first:false "funcid" Pbrt.Pp.pp_int32 fmt v.funcid;
    Pbrt.Pp.pp_record_field ~first:false "funcresulttype" Pbrt.Pp.pp_int32 fmt v.funcresulttype;
    Pbrt.Pp.pp_record_field ~first:false "funcretset" Pbrt.Pp.pp_bool fmt v.funcretset;
    Pbrt.Pp.pp_record_field ~first:false "funcvariadic" Pbrt.Pp.pp_bool fmt v.funcvariadic;
    Pbrt.Pp.pp_record_field ~first:false "funcformat" pp_coercion_form fmt v.funcformat;
    Pbrt.Pp.pp_record_field ~first:false "funccollid" Pbrt.Pp.pp_int32 fmt v.funccollid;
    Pbrt.Pp.pp_record_field ~first:false "inputcollid" Pbrt.Pp.pp_int32 fmt v.inputcollid;
    Pbrt.Pp.pp_record_field ~first:false "args" (Pbrt.Pp.pp_list pp_node) fmt v.args;
    Pbrt.Pp.pp_record_field ~first:false "location" Pbrt.Pp.pp_int32 fmt v.location;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_named_arg_expr fmt (v:named_arg_expr) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "xpr" (Pbrt.Pp.pp_option pp_node) fmt v.xpr;
    Pbrt.Pp.pp_record_field ~first:false "arg" (Pbrt.Pp.pp_option pp_node) fmt v.arg;
    Pbrt.Pp.pp_record_field ~first:false "name" Pbrt.Pp.pp_string fmt v.name;
    Pbrt.Pp.pp_record_field ~first:false "argnumber" Pbrt.Pp.pp_int32 fmt v.argnumber;
    Pbrt.Pp.pp_record_field ~first:false "location" Pbrt.Pp.pp_int32 fmt v.location;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_op_expr fmt (v:op_expr) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "xpr" (Pbrt.Pp.pp_option pp_node) fmt v.xpr;
    Pbrt.Pp.pp_record_field ~first:false "opno" Pbrt.Pp.pp_int32 fmt v.opno;
    Pbrt.Pp.pp_record_field ~first:false "opfuncid" Pbrt.Pp.pp_int32 fmt v.opfuncid;
    Pbrt.Pp.pp_record_field ~first:false "opresulttype" Pbrt.Pp.pp_int32 fmt v.opresulttype;
    Pbrt.Pp.pp_record_field ~first:false "opretset" Pbrt.Pp.pp_bool fmt v.opretset;
    Pbrt.Pp.pp_record_field ~first:false "opcollid" Pbrt.Pp.pp_int32 fmt v.opcollid;
    Pbrt.Pp.pp_record_field ~first:false "inputcollid" Pbrt.Pp.pp_int32 fmt v.inputcollid;
    Pbrt.Pp.pp_record_field ~first:false "args" (Pbrt.Pp.pp_list pp_node) fmt v.args;
    Pbrt.Pp.pp_record_field ~first:false "location" Pbrt.Pp.pp_int32 fmt v.location;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_distinct_expr fmt (v:distinct_expr) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "xpr" (Pbrt.Pp.pp_option pp_node) fmt v.xpr;
    Pbrt.Pp.pp_record_field ~first:false "opno" Pbrt.Pp.pp_int32 fmt v.opno;
    Pbrt.Pp.pp_record_field ~first:false "opfuncid" Pbrt.Pp.pp_int32 fmt v.opfuncid;
    Pbrt.Pp.pp_record_field ~first:false "opresulttype" Pbrt.Pp.pp_int32 fmt v.opresulttype;
    Pbrt.Pp.pp_record_field ~first:false "opretset" Pbrt.Pp.pp_bool fmt v.opretset;
    Pbrt.Pp.pp_record_field ~first:false "opcollid" Pbrt.Pp.pp_int32 fmt v.opcollid;
    Pbrt.Pp.pp_record_field ~first:false "inputcollid" Pbrt.Pp.pp_int32 fmt v.inputcollid;
    Pbrt.Pp.pp_record_field ~first:false "args" (Pbrt.Pp.pp_list pp_node) fmt v.args;
    Pbrt.Pp.pp_record_field ~first:false "location" Pbrt.Pp.pp_int32 fmt v.location;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_null_if_expr fmt (v:null_if_expr) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "xpr" (Pbrt.Pp.pp_option pp_node) fmt v.xpr;
    Pbrt.Pp.pp_record_field ~first:false "opno" Pbrt.Pp.pp_int32 fmt v.opno;
    Pbrt.Pp.pp_record_field ~first:false "opfuncid" Pbrt.Pp.pp_int32 fmt v.opfuncid;
    Pbrt.Pp.pp_record_field ~first:false "opresulttype" Pbrt.Pp.pp_int32 fmt v.opresulttype;
    Pbrt.Pp.pp_record_field ~first:false "opretset" Pbrt.Pp.pp_bool fmt v.opretset;
    Pbrt.Pp.pp_record_field ~first:false "opcollid" Pbrt.Pp.pp_int32 fmt v.opcollid;
    Pbrt.Pp.pp_record_field ~first:false "inputcollid" Pbrt.Pp.pp_int32 fmt v.inputcollid;
    Pbrt.Pp.pp_record_field ~first:false "args" (Pbrt.Pp.pp_list pp_node) fmt v.args;
    Pbrt.Pp.pp_record_field ~first:false "location" Pbrt.Pp.pp_int32 fmt v.location;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_scalar_array_op_expr fmt (v:scalar_array_op_expr) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "xpr" (Pbrt.Pp.pp_option pp_node) fmt v.xpr;
    Pbrt.Pp.pp_record_field ~first:false "opno" Pbrt.Pp.pp_int32 fmt v.opno;
    Pbrt.Pp.pp_record_field ~first:false "opfuncid" Pbrt.Pp.pp_int32 fmt v.opfuncid;
    Pbrt.Pp.pp_record_field ~first:false "use_or" Pbrt.Pp.pp_bool fmt v.use_or;
    Pbrt.Pp.pp_record_field ~first:false "inputcollid" Pbrt.Pp.pp_int32 fmt v.inputcollid;
    Pbrt.Pp.pp_record_field ~first:false "args" (Pbrt.Pp.pp_list pp_node) fmt v.args;
    Pbrt.Pp.pp_record_field ~first:false "location" Pbrt.Pp.pp_int32 fmt v.location;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_bool_expr fmt (v:bool_expr) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "xpr" (Pbrt.Pp.pp_option pp_node) fmt v.xpr;
    Pbrt.Pp.pp_record_field ~first:false "boolop" pp_bool_expr_type fmt v.boolop;
    Pbrt.Pp.pp_record_field ~first:false "args" (Pbrt.Pp.pp_list pp_node) fmt v.args;
    Pbrt.Pp.pp_record_field ~first:false "location" Pbrt.Pp.pp_int32 fmt v.location;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_sub_link fmt (v:sub_link) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "xpr" (Pbrt.Pp.pp_option pp_node) fmt v.xpr;
    Pbrt.Pp.pp_record_field ~first:false "sub_link_type" pp_sub_link_type fmt v.sub_link_type;
    Pbrt.Pp.pp_record_field ~first:false "sub_link_id" Pbrt.Pp.pp_int32 fmt v.sub_link_id;
    Pbrt.Pp.pp_record_field ~first:false "testexpr" (Pbrt.Pp.pp_option pp_node) fmt v.testexpr;
    Pbrt.Pp.pp_record_field ~first:false "oper_name" (Pbrt.Pp.pp_list pp_node) fmt v.oper_name;
    Pbrt.Pp.pp_record_field ~first:false "subselect" (Pbrt.Pp.pp_option pp_node) fmt v.subselect;
    Pbrt.Pp.pp_record_field ~first:false "location" Pbrt.Pp.pp_int32 fmt v.location;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_sub_plan fmt (v:sub_plan) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "xpr" (Pbrt.Pp.pp_option pp_node) fmt v.xpr;
    Pbrt.Pp.pp_record_field ~first:false "sub_link_type" pp_sub_link_type fmt v.sub_link_type;
    Pbrt.Pp.pp_record_field ~first:false "testexpr" (Pbrt.Pp.pp_option pp_node) fmt v.testexpr;
    Pbrt.Pp.pp_record_field ~first:false "param_ids" (Pbrt.Pp.pp_list pp_node) fmt v.param_ids;
    Pbrt.Pp.pp_record_field ~first:false "plan_id" Pbrt.Pp.pp_int32 fmt v.plan_id;
    Pbrt.Pp.pp_record_field ~first:false "plan_name" Pbrt.Pp.pp_string fmt v.plan_name;
    Pbrt.Pp.pp_record_field ~first:false "first_col_type" Pbrt.Pp.pp_int32 fmt v.first_col_type;
    Pbrt.Pp.pp_record_field ~first:false "first_col_typmod" Pbrt.Pp.pp_int32 fmt v.first_col_typmod;
    Pbrt.Pp.pp_record_field ~first:false "first_col_collation" Pbrt.Pp.pp_int32 fmt v.first_col_collation;
    Pbrt.Pp.pp_record_field ~first:false "use_hash_table" Pbrt.Pp.pp_bool fmt v.use_hash_table;
    Pbrt.Pp.pp_record_field ~first:false "unknown_eq_false" Pbrt.Pp.pp_bool fmt v.unknown_eq_false;
    Pbrt.Pp.pp_record_field ~first:false "parallel_safe" Pbrt.Pp.pp_bool fmt v.parallel_safe;
    Pbrt.Pp.pp_record_field ~first:false "set_param" (Pbrt.Pp.pp_list pp_node) fmt v.set_param;
    Pbrt.Pp.pp_record_field ~first:false "par_param" (Pbrt.Pp.pp_list pp_node) fmt v.par_param;
    Pbrt.Pp.pp_record_field ~first:false "args" (Pbrt.Pp.pp_list pp_node) fmt v.args;
    Pbrt.Pp.pp_record_field ~first:false "startup_cost" Pbrt.Pp.pp_float fmt v.startup_cost;
    Pbrt.Pp.pp_record_field ~first:false "per_call_cost" Pbrt.Pp.pp_float fmt v.per_call_cost;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_alternative_sub_plan fmt (v:alternative_sub_plan) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "xpr" (Pbrt.Pp.pp_option pp_node) fmt v.xpr;
    Pbrt.Pp.pp_record_field ~first:false "subplans" (Pbrt.Pp.pp_list pp_node) fmt v.subplans;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_field_select fmt (v:field_select) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "xpr" (Pbrt.Pp.pp_option pp_node) fmt v.xpr;
    Pbrt.Pp.pp_record_field ~first:false "arg" (Pbrt.Pp.pp_option pp_node) fmt v.arg;
    Pbrt.Pp.pp_record_field ~first:false "fieldnum" Pbrt.Pp.pp_int32 fmt v.fieldnum;
    Pbrt.Pp.pp_record_field ~first:false "resulttype" Pbrt.Pp.pp_int32 fmt v.resulttype;
    Pbrt.Pp.pp_record_field ~first:false "resulttypmod" Pbrt.Pp.pp_int32 fmt v.resulttypmod;
    Pbrt.Pp.pp_record_field ~first:false "resultcollid" Pbrt.Pp.pp_int32 fmt v.resultcollid;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_field_store fmt (v:field_store) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "xpr" (Pbrt.Pp.pp_option pp_node) fmt v.xpr;
    Pbrt.Pp.pp_record_field ~first:false "arg" (Pbrt.Pp.pp_option pp_node) fmt v.arg;
    Pbrt.Pp.pp_record_field ~first:false "newvals" (Pbrt.Pp.pp_list pp_node) fmt v.newvals;
    Pbrt.Pp.pp_record_field ~first:false "fieldnums" (Pbrt.Pp.pp_list pp_node) fmt v.fieldnums;
    Pbrt.Pp.pp_record_field ~first:false "resulttype" Pbrt.Pp.pp_int32 fmt v.resulttype;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_relabel_type fmt (v:relabel_type) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "xpr" (Pbrt.Pp.pp_option pp_node) fmt v.xpr;
    Pbrt.Pp.pp_record_field ~first:false "arg" (Pbrt.Pp.pp_option pp_node) fmt v.arg;
    Pbrt.Pp.pp_record_field ~first:false "resulttype" Pbrt.Pp.pp_int32 fmt v.resulttype;
    Pbrt.Pp.pp_record_field ~first:false "resulttypmod" Pbrt.Pp.pp_int32 fmt v.resulttypmod;
    Pbrt.Pp.pp_record_field ~first:false "resultcollid" Pbrt.Pp.pp_int32 fmt v.resultcollid;
    Pbrt.Pp.pp_record_field ~first:false "relabelformat" pp_coercion_form fmt v.relabelformat;
    Pbrt.Pp.pp_record_field ~first:false "location" Pbrt.Pp.pp_int32 fmt v.location;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_coerce_via_io fmt (v:coerce_via_io) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "xpr" (Pbrt.Pp.pp_option pp_node) fmt v.xpr;
    Pbrt.Pp.pp_record_field ~first:false "arg" (Pbrt.Pp.pp_option pp_node) fmt v.arg;
    Pbrt.Pp.pp_record_field ~first:false "resulttype" Pbrt.Pp.pp_int32 fmt v.resulttype;
    Pbrt.Pp.pp_record_field ~first:false "resultcollid" Pbrt.Pp.pp_int32 fmt v.resultcollid;
    Pbrt.Pp.pp_record_field ~first:false "coerceformat" pp_coercion_form fmt v.coerceformat;
    Pbrt.Pp.pp_record_field ~first:false "location" Pbrt.Pp.pp_int32 fmt v.location;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_array_coerce_expr fmt (v:array_coerce_expr) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "xpr" (Pbrt.Pp.pp_option pp_node) fmt v.xpr;
    Pbrt.Pp.pp_record_field ~first:false "arg" (Pbrt.Pp.pp_option pp_node) fmt v.arg;
    Pbrt.Pp.pp_record_field ~first:false "elemexpr" (Pbrt.Pp.pp_option pp_node) fmt v.elemexpr;
    Pbrt.Pp.pp_record_field ~first:false "resulttype" Pbrt.Pp.pp_int32 fmt v.resulttype;
    Pbrt.Pp.pp_record_field ~first:false "resulttypmod" Pbrt.Pp.pp_int32 fmt v.resulttypmod;
    Pbrt.Pp.pp_record_field ~first:false "resultcollid" Pbrt.Pp.pp_int32 fmt v.resultcollid;
    Pbrt.Pp.pp_record_field ~first:false "coerceformat" pp_coercion_form fmt v.coerceformat;
    Pbrt.Pp.pp_record_field ~first:false "location" Pbrt.Pp.pp_int32 fmt v.location;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_convert_rowtype_expr fmt (v:convert_rowtype_expr) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "xpr" (Pbrt.Pp.pp_option pp_node) fmt v.xpr;
    Pbrt.Pp.pp_record_field ~first:false "arg" (Pbrt.Pp.pp_option pp_node) fmt v.arg;
    Pbrt.Pp.pp_record_field ~first:false "resulttype" Pbrt.Pp.pp_int32 fmt v.resulttype;
    Pbrt.Pp.pp_record_field ~first:false "convertformat" pp_coercion_form fmt v.convertformat;
    Pbrt.Pp.pp_record_field ~first:false "location" Pbrt.Pp.pp_int32 fmt v.location;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_collate_expr fmt (v:collate_expr) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "xpr" (Pbrt.Pp.pp_option pp_node) fmt v.xpr;
    Pbrt.Pp.pp_record_field ~first:false "arg" (Pbrt.Pp.pp_option pp_node) fmt v.arg;
    Pbrt.Pp.pp_record_field ~first:false "coll_oid" Pbrt.Pp.pp_int32 fmt v.coll_oid;
    Pbrt.Pp.pp_record_field ~first:false "location" Pbrt.Pp.pp_int32 fmt v.location;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_case_expr fmt (v:case_expr) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "xpr" (Pbrt.Pp.pp_option pp_node) fmt v.xpr;
    Pbrt.Pp.pp_record_field ~first:false "casetype" Pbrt.Pp.pp_int32 fmt v.casetype;
    Pbrt.Pp.pp_record_field ~first:false "casecollid" Pbrt.Pp.pp_int32 fmt v.casecollid;
    Pbrt.Pp.pp_record_field ~first:false "arg" (Pbrt.Pp.pp_option pp_node) fmt v.arg;
    Pbrt.Pp.pp_record_field ~first:false "args" (Pbrt.Pp.pp_list pp_node) fmt v.args;
    Pbrt.Pp.pp_record_field ~first:false "defresult" (Pbrt.Pp.pp_option pp_node) fmt v.defresult;
    Pbrt.Pp.pp_record_field ~first:false "location" Pbrt.Pp.pp_int32 fmt v.location;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_case_when fmt (v:case_when) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "xpr" (Pbrt.Pp.pp_option pp_node) fmt v.xpr;
    Pbrt.Pp.pp_record_field ~first:false "expr" (Pbrt.Pp.pp_option pp_node) fmt v.expr;
    Pbrt.Pp.pp_record_field ~first:false "result" (Pbrt.Pp.pp_option pp_node) fmt v.result;
    Pbrt.Pp.pp_record_field ~first:false "location" Pbrt.Pp.pp_int32 fmt v.location;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_case_test_expr fmt (v:case_test_expr) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "xpr" (Pbrt.Pp.pp_option pp_node) fmt v.xpr;
    Pbrt.Pp.pp_record_field ~first:false "type_id" Pbrt.Pp.pp_int32 fmt v.type_id;
    Pbrt.Pp.pp_record_field ~first:false "type_mod" Pbrt.Pp.pp_int32 fmt v.type_mod;
    Pbrt.Pp.pp_record_field ~first:false "collation" Pbrt.Pp.pp_int32 fmt v.collation;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_array_expr fmt (v:array_expr) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "xpr" (Pbrt.Pp.pp_option pp_node) fmt v.xpr;
    Pbrt.Pp.pp_record_field ~first:false "array_typeid" Pbrt.Pp.pp_int32 fmt v.array_typeid;
    Pbrt.Pp.pp_record_field ~first:false "array_collid" Pbrt.Pp.pp_int32 fmt v.array_collid;
    Pbrt.Pp.pp_record_field ~first:false "element_typeid" Pbrt.Pp.pp_int32 fmt v.element_typeid;
    Pbrt.Pp.pp_record_field ~first:false "elements" (Pbrt.Pp.pp_list pp_node) fmt v.elements;
    Pbrt.Pp.pp_record_field ~first:false "multidims" Pbrt.Pp.pp_bool fmt v.multidims;
    Pbrt.Pp.pp_record_field ~first:false "location" Pbrt.Pp.pp_int32 fmt v.location;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_row_expr fmt (v:row_expr) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "xpr" (Pbrt.Pp.pp_option pp_node) fmt v.xpr;
    Pbrt.Pp.pp_record_field ~first:false "args" (Pbrt.Pp.pp_list pp_node) fmt v.args;
    Pbrt.Pp.pp_record_field ~first:false "row_typeid" Pbrt.Pp.pp_int32 fmt v.row_typeid;
    Pbrt.Pp.pp_record_field ~first:false "row_format" pp_coercion_form fmt v.row_format;
    Pbrt.Pp.pp_record_field ~first:false "colnames" (Pbrt.Pp.pp_list pp_node) fmt v.colnames;
    Pbrt.Pp.pp_record_field ~first:false "location" Pbrt.Pp.pp_int32 fmt v.location;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_row_compare_expr fmt (v:row_compare_expr) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "xpr" (Pbrt.Pp.pp_option pp_node) fmt v.xpr;
    Pbrt.Pp.pp_record_field ~first:false "rctype" pp_row_compare_type fmt v.rctype;
    Pbrt.Pp.pp_record_field ~first:false "opnos" (Pbrt.Pp.pp_list pp_node) fmt v.opnos;
    Pbrt.Pp.pp_record_field ~first:false "opfamilies" (Pbrt.Pp.pp_list pp_node) fmt v.opfamilies;
    Pbrt.Pp.pp_record_field ~first:false "inputcollids" (Pbrt.Pp.pp_list pp_node) fmt v.inputcollids;
    Pbrt.Pp.pp_record_field ~first:false "largs" (Pbrt.Pp.pp_list pp_node) fmt v.largs;
    Pbrt.Pp.pp_record_field ~first:false "rargs" (Pbrt.Pp.pp_list pp_node) fmt v.rargs;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_coalesce_expr fmt (v:coalesce_expr) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "xpr" (Pbrt.Pp.pp_option pp_node) fmt v.xpr;
    Pbrt.Pp.pp_record_field ~first:false "coalescetype" Pbrt.Pp.pp_int32 fmt v.coalescetype;
    Pbrt.Pp.pp_record_field ~first:false "coalescecollid" Pbrt.Pp.pp_int32 fmt v.coalescecollid;
    Pbrt.Pp.pp_record_field ~first:false "args" (Pbrt.Pp.pp_list pp_node) fmt v.args;
    Pbrt.Pp.pp_record_field ~first:false "location" Pbrt.Pp.pp_int32 fmt v.location;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_min_max_expr fmt (v:min_max_expr) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "xpr" (Pbrt.Pp.pp_option pp_node) fmt v.xpr;
    Pbrt.Pp.pp_record_field ~first:false "minmaxtype" Pbrt.Pp.pp_int32 fmt v.minmaxtype;
    Pbrt.Pp.pp_record_field ~first:false "minmaxcollid" Pbrt.Pp.pp_int32 fmt v.minmaxcollid;
    Pbrt.Pp.pp_record_field ~first:false "inputcollid" Pbrt.Pp.pp_int32 fmt v.inputcollid;
    Pbrt.Pp.pp_record_field ~first:false "op" pp_min_max_op fmt v.op;
    Pbrt.Pp.pp_record_field ~first:false "args" (Pbrt.Pp.pp_list pp_node) fmt v.args;
    Pbrt.Pp.pp_record_field ~first:false "location" Pbrt.Pp.pp_int32 fmt v.location;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_sqlvalue_function fmt (v:sqlvalue_function) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "xpr" (Pbrt.Pp.pp_option pp_node) fmt v.xpr;
    Pbrt.Pp.pp_record_field ~first:false "op" pp_sqlvalue_function_op fmt v.op;
    Pbrt.Pp.pp_record_field ~first:false "type_" Pbrt.Pp.pp_int32 fmt v.type_;
    Pbrt.Pp.pp_record_field ~first:false "typmod" Pbrt.Pp.pp_int32 fmt v.typmod;
    Pbrt.Pp.pp_record_field ~first:false "location" Pbrt.Pp.pp_int32 fmt v.location;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_xml_expr fmt (v:xml_expr) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "xpr" (Pbrt.Pp.pp_option pp_node) fmt v.xpr;
    Pbrt.Pp.pp_record_field ~first:false "op" pp_xml_expr_op fmt v.op;
    Pbrt.Pp.pp_record_field ~first:false "name" Pbrt.Pp.pp_string fmt v.name;
    Pbrt.Pp.pp_record_field ~first:false "named_args" (Pbrt.Pp.pp_list pp_node) fmt v.named_args;
    Pbrt.Pp.pp_record_field ~first:false "arg_names" (Pbrt.Pp.pp_list pp_node) fmt v.arg_names;
    Pbrt.Pp.pp_record_field ~first:false "args" (Pbrt.Pp.pp_list pp_node) fmt v.args;
    Pbrt.Pp.pp_record_field ~first:false "xmloption" pp_xml_option_type fmt v.xmloption;
    Pbrt.Pp.pp_record_field ~first:false "type_" Pbrt.Pp.pp_int32 fmt v.type_;
    Pbrt.Pp.pp_record_field ~first:false "typmod" Pbrt.Pp.pp_int32 fmt v.typmod;
    Pbrt.Pp.pp_record_field ~first:false "location" Pbrt.Pp.pp_int32 fmt v.location;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_null_test fmt (v:null_test) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "xpr" (Pbrt.Pp.pp_option pp_node) fmt v.xpr;
    Pbrt.Pp.pp_record_field ~first:false "arg" (Pbrt.Pp.pp_option pp_node) fmt v.arg;
    Pbrt.Pp.pp_record_field ~first:false "nulltesttype" pp_null_test_type fmt v.nulltesttype;
    Pbrt.Pp.pp_record_field ~first:false "argisrow" Pbrt.Pp.pp_bool fmt v.argisrow;
    Pbrt.Pp.pp_record_field ~first:false "location" Pbrt.Pp.pp_int32 fmt v.location;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_boolean_test fmt (v:boolean_test) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "xpr" (Pbrt.Pp.pp_option pp_node) fmt v.xpr;
    Pbrt.Pp.pp_record_field ~first:false "arg" (Pbrt.Pp.pp_option pp_node) fmt v.arg;
    Pbrt.Pp.pp_record_field ~first:false "booltesttype" pp_bool_test_type fmt v.booltesttype;
    Pbrt.Pp.pp_record_field ~first:false "location" Pbrt.Pp.pp_int32 fmt v.location;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_coerce_to_domain fmt (v:coerce_to_domain) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "xpr" (Pbrt.Pp.pp_option pp_node) fmt v.xpr;
    Pbrt.Pp.pp_record_field ~first:false "arg" (Pbrt.Pp.pp_option pp_node) fmt v.arg;
    Pbrt.Pp.pp_record_field ~first:false "resulttype" Pbrt.Pp.pp_int32 fmt v.resulttype;
    Pbrt.Pp.pp_record_field ~first:false "resulttypmod" Pbrt.Pp.pp_int32 fmt v.resulttypmod;
    Pbrt.Pp.pp_record_field ~first:false "resultcollid" Pbrt.Pp.pp_int32 fmt v.resultcollid;
    Pbrt.Pp.pp_record_field ~first:false "coercionformat" pp_coercion_form fmt v.coercionformat;
    Pbrt.Pp.pp_record_field ~first:false "location" Pbrt.Pp.pp_int32 fmt v.location;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_coerce_to_domain_value fmt (v:coerce_to_domain_value) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "xpr" (Pbrt.Pp.pp_option pp_node) fmt v.xpr;
    Pbrt.Pp.pp_record_field ~first:false "type_id" Pbrt.Pp.pp_int32 fmt v.type_id;
    Pbrt.Pp.pp_record_field ~first:false "type_mod" Pbrt.Pp.pp_int32 fmt v.type_mod;
    Pbrt.Pp.pp_record_field ~first:false "collation" Pbrt.Pp.pp_int32 fmt v.collation;
    Pbrt.Pp.pp_record_field ~first:false "location" Pbrt.Pp.pp_int32 fmt v.location;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_set_to_default fmt (v:set_to_default) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "xpr" (Pbrt.Pp.pp_option pp_node) fmt v.xpr;
    Pbrt.Pp.pp_record_field ~first:false "type_id" Pbrt.Pp.pp_int32 fmt v.type_id;
    Pbrt.Pp.pp_record_field ~first:false "type_mod" Pbrt.Pp.pp_int32 fmt v.type_mod;
    Pbrt.Pp.pp_record_field ~first:false "collation" Pbrt.Pp.pp_int32 fmt v.collation;
    Pbrt.Pp.pp_record_field ~first:false "location" Pbrt.Pp.pp_int32 fmt v.location;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_current_of_expr fmt (v:current_of_expr) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "xpr" (Pbrt.Pp.pp_option pp_node) fmt v.xpr;
    Pbrt.Pp.pp_record_field ~first:false "cvarno" Pbrt.Pp.pp_int32 fmt v.cvarno;
    Pbrt.Pp.pp_record_field ~first:false "cursor_name" Pbrt.Pp.pp_string fmt v.cursor_name;
    Pbrt.Pp.pp_record_field ~first:false "cursor_param" Pbrt.Pp.pp_int32 fmt v.cursor_param;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_next_value_expr fmt (v:next_value_expr) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "xpr" (Pbrt.Pp.pp_option pp_node) fmt v.xpr;
    Pbrt.Pp.pp_record_field ~first:false "seqid" Pbrt.Pp.pp_int32 fmt v.seqid;
    Pbrt.Pp.pp_record_field ~first:false "type_id" Pbrt.Pp.pp_int32 fmt v.type_id;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_inference_elem fmt (v:inference_elem) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "xpr" (Pbrt.Pp.pp_option pp_node) fmt v.xpr;
    Pbrt.Pp.pp_record_field ~first:false "expr" (Pbrt.Pp.pp_option pp_node) fmt v.expr;
    Pbrt.Pp.pp_record_field ~first:false "infercollid" Pbrt.Pp.pp_int32 fmt v.infercollid;
    Pbrt.Pp.pp_record_field ~first:false "inferopclass" Pbrt.Pp.pp_int32 fmt v.inferopclass;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_target_entry fmt (v:target_entry) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "xpr" (Pbrt.Pp.pp_option pp_node) fmt v.xpr;
    Pbrt.Pp.pp_record_field ~first:false "expr" (Pbrt.Pp.pp_option pp_node) fmt v.expr;
    Pbrt.Pp.pp_record_field ~first:false "resno" Pbrt.Pp.pp_int32 fmt v.resno;
    Pbrt.Pp.pp_record_field ~first:false "resname" Pbrt.Pp.pp_string fmt v.resname;
    Pbrt.Pp.pp_record_field ~first:false "ressortgroupref" Pbrt.Pp.pp_int32 fmt v.ressortgroupref;
    Pbrt.Pp.pp_record_field ~first:false "resorigtbl" Pbrt.Pp.pp_int32 fmt v.resorigtbl;
    Pbrt.Pp.pp_record_field ~first:false "resorigcol" Pbrt.Pp.pp_int32 fmt v.resorigcol;
    Pbrt.Pp.pp_record_field ~first:false "resjunk" Pbrt.Pp.pp_bool fmt v.resjunk;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_join_expr fmt (v:join_expr) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "jointype" pp_join_type fmt v.jointype;
    Pbrt.Pp.pp_record_field ~first:false "is_natural" Pbrt.Pp.pp_bool fmt v.is_natural;
    Pbrt.Pp.pp_record_field ~first:false "larg" (Pbrt.Pp.pp_option pp_node) fmt v.larg;
    Pbrt.Pp.pp_record_field ~first:false "rarg" (Pbrt.Pp.pp_option pp_node) fmt v.rarg;
    Pbrt.Pp.pp_record_field ~first:false "using_clause" (Pbrt.Pp.pp_list pp_node) fmt v.using_clause;
    Pbrt.Pp.pp_record_field ~first:false "quals" (Pbrt.Pp.pp_option pp_node) fmt v.quals;
    Pbrt.Pp.pp_record_field ~first:false "alias" (Pbrt.Pp.pp_option pp_alias) fmt v.alias;
    Pbrt.Pp.pp_record_field ~first:false "rtindex" Pbrt.Pp.pp_int32 fmt v.rtindex;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_from_expr fmt (v:from_expr) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "fromlist" (Pbrt.Pp.pp_list pp_node) fmt v.fromlist;
    Pbrt.Pp.pp_record_field ~first:false "quals" (Pbrt.Pp.pp_option pp_node) fmt v.quals;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_on_conflict_expr fmt (v:on_conflict_expr) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "action" pp_on_conflict_action fmt v.action;
    Pbrt.Pp.pp_record_field ~first:false "arbiter_elems" (Pbrt.Pp.pp_list pp_node) fmt v.arbiter_elems;
    Pbrt.Pp.pp_record_field ~first:false "arbiter_where" (Pbrt.Pp.pp_option pp_node) fmt v.arbiter_where;
    Pbrt.Pp.pp_record_field ~first:false "constraint_" Pbrt.Pp.pp_int32 fmt v.constraint_;
    Pbrt.Pp.pp_record_field ~first:false "on_conflict_set" (Pbrt.Pp.pp_list pp_node) fmt v.on_conflict_set;
    Pbrt.Pp.pp_record_field ~first:false "on_conflict_where" (Pbrt.Pp.pp_option pp_node) fmt v.on_conflict_where;
    Pbrt.Pp.pp_record_field ~first:false "excl_rel_index" Pbrt.Pp.pp_int32 fmt v.excl_rel_index;
    Pbrt.Pp.pp_record_field ~first:false "excl_rel_tlist" (Pbrt.Pp.pp_list pp_node) fmt v.excl_rel_tlist;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_into_clause fmt (v:into_clause) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "rel" (Pbrt.Pp.pp_option pp_range_var) fmt v.rel;
    Pbrt.Pp.pp_record_field ~first:false "col_names" (Pbrt.Pp.pp_list pp_node) fmt v.col_names;
    Pbrt.Pp.pp_record_field ~first:false "access_method" Pbrt.Pp.pp_string fmt v.access_method;
    Pbrt.Pp.pp_record_field ~first:false "options" (Pbrt.Pp.pp_list pp_node) fmt v.options;
    Pbrt.Pp.pp_record_field ~first:false "on_commit" pp_on_commit_action fmt v.on_commit;
    Pbrt.Pp.pp_record_field ~first:false "table_space_name" Pbrt.Pp.pp_string fmt v.table_space_name;
    Pbrt.Pp.pp_record_field ~first:false "view_query" (Pbrt.Pp.pp_option pp_node) fmt v.view_query;
    Pbrt.Pp.pp_record_field ~first:false "skip_data" Pbrt.Pp.pp_bool fmt v.skip_data;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_query fmt (v:query) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "command_type" pp_cmd_type fmt v.command_type;
    Pbrt.Pp.pp_record_field ~first:false "query_source" pp_query_source fmt v.query_source;
    Pbrt.Pp.pp_record_field ~first:false "can_set_tag" Pbrt.Pp.pp_bool fmt v.can_set_tag;
    Pbrt.Pp.pp_record_field ~first:false "utility_stmt" (Pbrt.Pp.pp_option pp_node) fmt v.utility_stmt;
    Pbrt.Pp.pp_record_field ~first:false "result_relation" Pbrt.Pp.pp_int32 fmt v.result_relation;
    Pbrt.Pp.pp_record_field ~first:false "has_aggs" Pbrt.Pp.pp_bool fmt v.has_aggs;
    Pbrt.Pp.pp_record_field ~first:false "has_window_funcs" Pbrt.Pp.pp_bool fmt v.has_window_funcs;
    Pbrt.Pp.pp_record_field ~first:false "has_target_srfs" Pbrt.Pp.pp_bool fmt v.has_target_srfs;
    Pbrt.Pp.pp_record_field ~first:false "has_sub_links" Pbrt.Pp.pp_bool fmt v.has_sub_links;
    Pbrt.Pp.pp_record_field ~first:false "has_distinct_on" Pbrt.Pp.pp_bool fmt v.has_distinct_on;
    Pbrt.Pp.pp_record_field ~first:false "has_recursive" Pbrt.Pp.pp_bool fmt v.has_recursive;
    Pbrt.Pp.pp_record_field ~first:false "has_modifying_cte" Pbrt.Pp.pp_bool fmt v.has_modifying_cte;
    Pbrt.Pp.pp_record_field ~first:false "has_for_update" Pbrt.Pp.pp_bool fmt v.has_for_update;
    Pbrt.Pp.pp_record_field ~first:false "has_row_security" Pbrt.Pp.pp_bool fmt v.has_row_security;
    Pbrt.Pp.pp_record_field ~first:false "cte_list" (Pbrt.Pp.pp_list pp_node) fmt v.cte_list;
    Pbrt.Pp.pp_record_field ~first:false "rtable" (Pbrt.Pp.pp_list pp_node) fmt v.rtable;
    Pbrt.Pp.pp_record_field ~first:false "jointree" (Pbrt.Pp.pp_option pp_from_expr) fmt v.jointree;
    Pbrt.Pp.pp_record_field ~first:false "target_list" (Pbrt.Pp.pp_list pp_node) fmt v.target_list;
    Pbrt.Pp.pp_record_field ~first:false "override" pp_overriding_kind fmt v.override;
    Pbrt.Pp.pp_record_field ~first:false "on_conflict" (Pbrt.Pp.pp_option pp_on_conflict_expr) fmt v.on_conflict;
    Pbrt.Pp.pp_record_field ~first:false "returning_list" (Pbrt.Pp.pp_list pp_node) fmt v.returning_list;
    Pbrt.Pp.pp_record_field ~first:false "group_clause" (Pbrt.Pp.pp_list pp_node) fmt v.group_clause;
    Pbrt.Pp.pp_record_field ~first:false "grouping_sets" (Pbrt.Pp.pp_list pp_node) fmt v.grouping_sets;
    Pbrt.Pp.pp_record_field ~first:false "having_qual" (Pbrt.Pp.pp_option pp_node) fmt v.having_qual;
    Pbrt.Pp.pp_record_field ~first:false "window_clause" (Pbrt.Pp.pp_list pp_node) fmt v.window_clause;
    Pbrt.Pp.pp_record_field ~first:false "distinct_clause" (Pbrt.Pp.pp_list pp_node) fmt v.distinct_clause;
    Pbrt.Pp.pp_record_field ~first:false "sort_clause" (Pbrt.Pp.pp_list pp_node) fmt v.sort_clause;
    Pbrt.Pp.pp_record_field ~first:false "limit_offset" (Pbrt.Pp.pp_option pp_node) fmt v.limit_offset;
    Pbrt.Pp.pp_record_field ~first:false "limit_count" (Pbrt.Pp.pp_option pp_node) fmt v.limit_count;
    Pbrt.Pp.pp_record_field ~first:false "limit_option" pp_limit_option fmt v.limit_option;
    Pbrt.Pp.pp_record_field ~first:false "row_marks" (Pbrt.Pp.pp_list pp_node) fmt v.row_marks;
    Pbrt.Pp.pp_record_field ~first:false "set_operations" (Pbrt.Pp.pp_option pp_node) fmt v.set_operations;
    Pbrt.Pp.pp_record_field ~first:false "constraint_deps" (Pbrt.Pp.pp_list pp_node) fmt v.constraint_deps;
    Pbrt.Pp.pp_record_field ~first:false "with_check_options" (Pbrt.Pp.pp_list pp_node) fmt v.with_check_options;
    Pbrt.Pp.pp_record_field ~first:false "stmt_location" Pbrt.Pp.pp_int32 fmt v.stmt_location;
    Pbrt.Pp.pp_record_field ~first:false "stmt_len" Pbrt.Pp.pp_int32 fmt v.stmt_len;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_insert_stmt fmt (v:insert_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "relation" (Pbrt.Pp.pp_option pp_range_var) fmt v.relation;
    Pbrt.Pp.pp_record_field ~first:false "cols" (Pbrt.Pp.pp_list pp_node) fmt v.cols;
    Pbrt.Pp.pp_record_field ~first:false "select_stmt" (Pbrt.Pp.pp_option pp_node) fmt v.select_stmt;
    Pbrt.Pp.pp_record_field ~first:false "on_conflict_clause" (Pbrt.Pp.pp_option pp_on_conflict_clause) fmt v.on_conflict_clause;
    Pbrt.Pp.pp_record_field ~first:false "returning_list" (Pbrt.Pp.pp_list pp_node) fmt v.returning_list;
    Pbrt.Pp.pp_record_field ~first:false "with_clause" (Pbrt.Pp.pp_option pp_with_clause) fmt v.with_clause;
    Pbrt.Pp.pp_record_field ~first:false "override" pp_overriding_kind fmt v.override;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_on_conflict_clause fmt (v:on_conflict_clause) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "action" pp_on_conflict_action fmt v.action;
    Pbrt.Pp.pp_record_field ~first:false "infer" (Pbrt.Pp.pp_option pp_infer_clause) fmt v.infer;
    Pbrt.Pp.pp_record_field ~first:false "target_list" (Pbrt.Pp.pp_list pp_node) fmt v.target_list;
    Pbrt.Pp.pp_record_field ~first:false "where_clause" (Pbrt.Pp.pp_option pp_node) fmt v.where_clause;
    Pbrt.Pp.pp_record_field ~first:false "location" Pbrt.Pp.pp_int32 fmt v.location;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_infer_clause fmt (v:infer_clause) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "index_elems" (Pbrt.Pp.pp_list pp_node) fmt v.index_elems;
    Pbrt.Pp.pp_record_field ~first:false "where_clause" (Pbrt.Pp.pp_option pp_node) fmt v.where_clause;
    Pbrt.Pp.pp_record_field ~first:false "conname" Pbrt.Pp.pp_string fmt v.conname;
    Pbrt.Pp.pp_record_field ~first:false "location" Pbrt.Pp.pp_int32 fmt v.location;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_with_clause fmt (v:with_clause) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "ctes" (Pbrt.Pp.pp_list pp_node) fmt v.ctes;
    Pbrt.Pp.pp_record_field ~first:false "recursive" Pbrt.Pp.pp_bool fmt v.recursive;
    Pbrt.Pp.pp_record_field ~first:false "location" Pbrt.Pp.pp_int32 fmt v.location;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_delete_stmt fmt (v:delete_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "relation" (Pbrt.Pp.pp_option pp_range_var) fmt v.relation;
    Pbrt.Pp.pp_record_field ~first:false "using_clause" (Pbrt.Pp.pp_list pp_node) fmt v.using_clause;
    Pbrt.Pp.pp_record_field ~first:false "where_clause" (Pbrt.Pp.pp_option pp_node) fmt v.where_clause;
    Pbrt.Pp.pp_record_field ~first:false "returning_list" (Pbrt.Pp.pp_list pp_node) fmt v.returning_list;
    Pbrt.Pp.pp_record_field ~first:false "with_clause" (Pbrt.Pp.pp_option pp_with_clause) fmt v.with_clause;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_update_stmt fmt (v:update_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "relation" (Pbrt.Pp.pp_option pp_range_var) fmt v.relation;
    Pbrt.Pp.pp_record_field ~first:false "target_list" (Pbrt.Pp.pp_list pp_node) fmt v.target_list;
    Pbrt.Pp.pp_record_field ~first:false "where_clause" (Pbrt.Pp.pp_option pp_node) fmt v.where_clause;
    Pbrt.Pp.pp_record_field ~first:false "from_clause" (Pbrt.Pp.pp_list pp_node) fmt v.from_clause;
    Pbrt.Pp.pp_record_field ~first:false "returning_list" (Pbrt.Pp.pp_list pp_node) fmt v.returning_list;
    Pbrt.Pp.pp_record_field ~first:false "with_clause" (Pbrt.Pp.pp_option pp_with_clause) fmt v.with_clause;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_select_stmt fmt (v:select_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "distinct_clause" (Pbrt.Pp.pp_list pp_node) fmt v.distinct_clause;
    Pbrt.Pp.pp_record_field ~first:false "into_clause" (Pbrt.Pp.pp_option pp_into_clause) fmt v.into_clause;
    Pbrt.Pp.pp_record_field ~first:false "target_list" (Pbrt.Pp.pp_list pp_node) fmt v.target_list;
    Pbrt.Pp.pp_record_field ~first:false "from_clause" (Pbrt.Pp.pp_list pp_node) fmt v.from_clause;
    Pbrt.Pp.pp_record_field ~first:false "where_clause" (Pbrt.Pp.pp_option pp_node) fmt v.where_clause;
    Pbrt.Pp.pp_record_field ~first:false "group_clause" (Pbrt.Pp.pp_list pp_node) fmt v.group_clause;
    Pbrt.Pp.pp_record_field ~first:false "having_clause" (Pbrt.Pp.pp_option pp_node) fmt v.having_clause;
    Pbrt.Pp.pp_record_field ~first:false "window_clause" (Pbrt.Pp.pp_list pp_node) fmt v.window_clause;
    Pbrt.Pp.pp_record_field ~first:false "values_lists" (Pbrt.Pp.pp_list pp_node) fmt v.values_lists;
    Pbrt.Pp.pp_record_field ~first:false "sort_clause" (Pbrt.Pp.pp_list pp_node) fmt v.sort_clause;
    Pbrt.Pp.pp_record_field ~first:false "limit_offset" (Pbrt.Pp.pp_option pp_node) fmt v.limit_offset;
    Pbrt.Pp.pp_record_field ~first:false "limit_count" (Pbrt.Pp.pp_option pp_node) fmt v.limit_count;
    Pbrt.Pp.pp_record_field ~first:false "limit_option" pp_limit_option fmt v.limit_option;
    Pbrt.Pp.pp_record_field ~first:false "locking_clause" (Pbrt.Pp.pp_list pp_node) fmt v.locking_clause;
    Pbrt.Pp.pp_record_field ~first:false "with_clause" (Pbrt.Pp.pp_option pp_with_clause) fmt v.with_clause;
    Pbrt.Pp.pp_record_field ~first:false "op" pp_set_operation fmt v.op;
    Pbrt.Pp.pp_record_field ~first:false "all" Pbrt.Pp.pp_bool fmt v.all;
    Pbrt.Pp.pp_record_field ~first:false "larg" (Pbrt.Pp.pp_option pp_select_stmt) fmt v.larg;
    Pbrt.Pp.pp_record_field ~first:false "rarg" (Pbrt.Pp.pp_option pp_select_stmt) fmt v.rarg;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_alter_table_stmt fmt (v:alter_table_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "relation" (Pbrt.Pp.pp_option pp_range_var) fmt v.relation;
    Pbrt.Pp.pp_record_field ~first:false "cmds" (Pbrt.Pp.pp_list pp_node) fmt v.cmds;
    Pbrt.Pp.pp_record_field ~first:false "relkind" pp_object_type fmt v.relkind;
    Pbrt.Pp.pp_record_field ~first:false "missing_ok" Pbrt.Pp.pp_bool fmt v.missing_ok;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_alter_table_cmd fmt (v:alter_table_cmd) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "subtype" pp_alter_table_type fmt v.subtype;
    Pbrt.Pp.pp_record_field ~first:false "name" Pbrt.Pp.pp_string fmt v.name;
    Pbrt.Pp.pp_record_field ~first:false "num" Pbrt.Pp.pp_int32 fmt v.num;
    Pbrt.Pp.pp_record_field ~first:false "newowner" (Pbrt.Pp.pp_option pp_role_spec) fmt v.newowner;
    Pbrt.Pp.pp_record_field ~first:false "def" (Pbrt.Pp.pp_option pp_node) fmt v.def;
    Pbrt.Pp.pp_record_field ~first:false "behavior" pp_drop_behavior fmt v.behavior;
    Pbrt.Pp.pp_record_field ~first:false "missing_ok" Pbrt.Pp.pp_bool fmt v.missing_ok;
    Pbrt.Pp.pp_record_field ~first:false "recurse" Pbrt.Pp.pp_bool fmt v.recurse;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_alter_domain_stmt fmt (v:alter_domain_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "subtype" Pbrt.Pp.pp_string fmt v.subtype;
    Pbrt.Pp.pp_record_field ~first:false "type_name" (Pbrt.Pp.pp_list pp_node) fmt v.type_name;
    Pbrt.Pp.pp_record_field ~first:false "name" Pbrt.Pp.pp_string fmt v.name;
    Pbrt.Pp.pp_record_field ~first:false "def" (Pbrt.Pp.pp_option pp_node) fmt v.def;
    Pbrt.Pp.pp_record_field ~first:false "behavior" pp_drop_behavior fmt v.behavior;
    Pbrt.Pp.pp_record_field ~first:false "missing_ok" Pbrt.Pp.pp_bool fmt v.missing_ok;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_set_operation_stmt fmt (v:set_operation_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "op" pp_set_operation fmt v.op;
    Pbrt.Pp.pp_record_field ~first:false "all" Pbrt.Pp.pp_bool fmt v.all;
    Pbrt.Pp.pp_record_field ~first:false "larg" (Pbrt.Pp.pp_option pp_node) fmt v.larg;
    Pbrt.Pp.pp_record_field ~first:false "rarg" (Pbrt.Pp.pp_option pp_node) fmt v.rarg;
    Pbrt.Pp.pp_record_field ~first:false "col_types" (Pbrt.Pp.pp_list pp_node) fmt v.col_types;
    Pbrt.Pp.pp_record_field ~first:false "col_typmods" (Pbrt.Pp.pp_list pp_node) fmt v.col_typmods;
    Pbrt.Pp.pp_record_field ~first:false "col_collations" (Pbrt.Pp.pp_list pp_node) fmt v.col_collations;
    Pbrt.Pp.pp_record_field ~first:false "group_clauses" (Pbrt.Pp.pp_list pp_node) fmt v.group_clauses;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_grant_stmt fmt (v:grant_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "is_grant" Pbrt.Pp.pp_bool fmt v.is_grant;
    Pbrt.Pp.pp_record_field ~first:false "targtype" pp_grant_target_type fmt v.targtype;
    Pbrt.Pp.pp_record_field ~first:false "objtype" pp_object_type fmt v.objtype;
    Pbrt.Pp.pp_record_field ~first:false "objects" (Pbrt.Pp.pp_list pp_node) fmt v.objects;
    Pbrt.Pp.pp_record_field ~first:false "privileges" (Pbrt.Pp.pp_list pp_node) fmt v.privileges;
    Pbrt.Pp.pp_record_field ~first:false "grantees" (Pbrt.Pp.pp_list pp_node) fmt v.grantees;
    Pbrt.Pp.pp_record_field ~first:false "grant_option" Pbrt.Pp.pp_bool fmt v.grant_option;
    Pbrt.Pp.pp_record_field ~first:false "behavior" pp_drop_behavior fmt v.behavior;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_grant_role_stmt fmt (v:grant_role_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "granted_roles" (Pbrt.Pp.pp_list pp_node) fmt v.granted_roles;
    Pbrt.Pp.pp_record_field ~first:false "grantee_roles" (Pbrt.Pp.pp_list pp_node) fmt v.grantee_roles;
    Pbrt.Pp.pp_record_field ~first:false "is_grant" Pbrt.Pp.pp_bool fmt v.is_grant;
    Pbrt.Pp.pp_record_field ~first:false "admin_opt" Pbrt.Pp.pp_bool fmt v.admin_opt;
    Pbrt.Pp.pp_record_field ~first:false "grantor" (Pbrt.Pp.pp_option pp_role_spec) fmt v.grantor;
    Pbrt.Pp.pp_record_field ~first:false "behavior" pp_drop_behavior fmt v.behavior;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_alter_default_privileges_stmt fmt (v:alter_default_privileges_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "options" (Pbrt.Pp.pp_list pp_node) fmt v.options;
    Pbrt.Pp.pp_record_field ~first:false "action" (Pbrt.Pp.pp_option pp_grant_stmt) fmt v.action;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_cluster_stmt fmt (v:cluster_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "relation" (Pbrt.Pp.pp_option pp_range_var) fmt v.relation;
    Pbrt.Pp.pp_record_field ~first:false "indexname" Pbrt.Pp.pp_string fmt v.indexname;
    Pbrt.Pp.pp_record_field ~first:false "options" Pbrt.Pp.pp_int32 fmt v.options;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_copy_stmt fmt (v:copy_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "relation" (Pbrt.Pp.pp_option pp_range_var) fmt v.relation;
    Pbrt.Pp.pp_record_field ~first:false "query" (Pbrt.Pp.pp_option pp_node) fmt v.query;
    Pbrt.Pp.pp_record_field ~first:false "attlist" (Pbrt.Pp.pp_list pp_node) fmt v.attlist;
    Pbrt.Pp.pp_record_field ~first:false "is_from" Pbrt.Pp.pp_bool fmt v.is_from;
    Pbrt.Pp.pp_record_field ~first:false "is_program" Pbrt.Pp.pp_bool fmt v.is_program;
    Pbrt.Pp.pp_record_field ~first:false "filename" Pbrt.Pp.pp_string fmt v.filename;
    Pbrt.Pp.pp_record_field ~first:false "options" (Pbrt.Pp.pp_list pp_node) fmt v.options;
    Pbrt.Pp.pp_record_field ~first:false "where_clause" (Pbrt.Pp.pp_option pp_node) fmt v.where_clause;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_create_stmt fmt (v:create_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "relation" (Pbrt.Pp.pp_option pp_range_var) fmt v.relation;
    Pbrt.Pp.pp_record_field ~first:false "table_elts" (Pbrt.Pp.pp_list pp_node) fmt v.table_elts;
    Pbrt.Pp.pp_record_field ~first:false "inh_relations" (Pbrt.Pp.pp_list pp_node) fmt v.inh_relations;
    Pbrt.Pp.pp_record_field ~first:false "partbound" (Pbrt.Pp.pp_option pp_partition_bound_spec) fmt v.partbound;
    Pbrt.Pp.pp_record_field ~first:false "partspec" (Pbrt.Pp.pp_option pp_partition_spec) fmt v.partspec;
    Pbrt.Pp.pp_record_field ~first:false "of_typename" (Pbrt.Pp.pp_option pp_type_name) fmt v.of_typename;
    Pbrt.Pp.pp_record_field ~first:false "constraints" (Pbrt.Pp.pp_list pp_node) fmt v.constraints;
    Pbrt.Pp.pp_record_field ~first:false "options" (Pbrt.Pp.pp_list pp_node) fmt v.options;
    Pbrt.Pp.pp_record_field ~first:false "oncommit" pp_on_commit_action fmt v.oncommit;
    Pbrt.Pp.pp_record_field ~first:false "tablespacename" Pbrt.Pp.pp_string fmt v.tablespacename;
    Pbrt.Pp.pp_record_field ~first:false "access_method" Pbrt.Pp.pp_string fmt v.access_method;
    Pbrt.Pp.pp_record_field ~first:false "if_not_exists" Pbrt.Pp.pp_bool fmt v.if_not_exists;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_partition_bound_spec fmt (v:partition_bound_spec) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "strategy" Pbrt.Pp.pp_string fmt v.strategy;
    Pbrt.Pp.pp_record_field ~first:false "is_default" Pbrt.Pp.pp_bool fmt v.is_default;
    Pbrt.Pp.pp_record_field ~first:false "modulus" Pbrt.Pp.pp_int32 fmt v.modulus;
    Pbrt.Pp.pp_record_field ~first:false "remainder" Pbrt.Pp.pp_int32 fmt v.remainder;
    Pbrt.Pp.pp_record_field ~first:false "listdatums" (Pbrt.Pp.pp_list pp_node) fmt v.listdatums;
    Pbrt.Pp.pp_record_field ~first:false "lowerdatums" (Pbrt.Pp.pp_list pp_node) fmt v.lowerdatums;
    Pbrt.Pp.pp_record_field ~first:false "upperdatums" (Pbrt.Pp.pp_list pp_node) fmt v.upperdatums;
    Pbrt.Pp.pp_record_field ~first:false "location" Pbrt.Pp.pp_int32 fmt v.location;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_partition_spec fmt (v:partition_spec) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "strategy" Pbrt.Pp.pp_string fmt v.strategy;
    Pbrt.Pp.pp_record_field ~first:false "part_params" (Pbrt.Pp.pp_list pp_node) fmt v.part_params;
    Pbrt.Pp.pp_record_field ~first:false "location" Pbrt.Pp.pp_int32 fmt v.location;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_type_name fmt (v:type_name) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "names" (Pbrt.Pp.pp_list pp_node) fmt v.names;
    Pbrt.Pp.pp_record_field ~first:false "type_oid" Pbrt.Pp.pp_int32 fmt v.type_oid;
    Pbrt.Pp.pp_record_field ~first:false "setof" Pbrt.Pp.pp_bool fmt v.setof;
    Pbrt.Pp.pp_record_field ~first:false "pct_type" Pbrt.Pp.pp_bool fmt v.pct_type;
    Pbrt.Pp.pp_record_field ~first:false "typmods" (Pbrt.Pp.pp_list pp_node) fmt v.typmods;
    Pbrt.Pp.pp_record_field ~first:false "typemod" Pbrt.Pp.pp_int32 fmt v.typemod;
    Pbrt.Pp.pp_record_field ~first:false "array_bounds" (Pbrt.Pp.pp_list pp_node) fmt v.array_bounds;
    Pbrt.Pp.pp_record_field ~first:false "location" Pbrt.Pp.pp_int32 fmt v.location;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_define_stmt fmt (v:define_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "kind" pp_object_type fmt v.kind;
    Pbrt.Pp.pp_record_field ~first:false "oldstyle" Pbrt.Pp.pp_bool fmt v.oldstyle;
    Pbrt.Pp.pp_record_field ~first:false "defnames" (Pbrt.Pp.pp_list pp_node) fmt v.defnames;
    Pbrt.Pp.pp_record_field ~first:false "args" (Pbrt.Pp.pp_list pp_node) fmt v.args;
    Pbrt.Pp.pp_record_field ~first:false "definition" (Pbrt.Pp.pp_list pp_node) fmt v.definition;
    Pbrt.Pp.pp_record_field ~first:false "if_not_exists" Pbrt.Pp.pp_bool fmt v.if_not_exists;
    Pbrt.Pp.pp_record_field ~first:false "replace" Pbrt.Pp.pp_bool fmt v.replace;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_drop_stmt fmt (v:drop_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "objects" (Pbrt.Pp.pp_list pp_node) fmt v.objects;
    Pbrt.Pp.pp_record_field ~first:false "remove_type" pp_object_type fmt v.remove_type;
    Pbrt.Pp.pp_record_field ~first:false "behavior" pp_drop_behavior fmt v.behavior;
    Pbrt.Pp.pp_record_field ~first:false "missing_ok" Pbrt.Pp.pp_bool fmt v.missing_ok;
    Pbrt.Pp.pp_record_field ~first:false "concurrent" Pbrt.Pp.pp_bool fmt v.concurrent;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_truncate_stmt fmt (v:truncate_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "relations" (Pbrt.Pp.pp_list pp_node) fmt v.relations;
    Pbrt.Pp.pp_record_field ~first:false "restart_seqs" Pbrt.Pp.pp_bool fmt v.restart_seqs;
    Pbrt.Pp.pp_record_field ~first:false "behavior" pp_drop_behavior fmt v.behavior;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_comment_stmt fmt (v:comment_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "objtype" pp_object_type fmt v.objtype;
    Pbrt.Pp.pp_record_field ~first:false "object_" (Pbrt.Pp.pp_option pp_node) fmt v.object_;
    Pbrt.Pp.pp_record_field ~first:false "comment" Pbrt.Pp.pp_string fmt v.comment;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_index_stmt fmt (v:index_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "idxname" Pbrt.Pp.pp_string fmt v.idxname;
    Pbrt.Pp.pp_record_field ~first:false "relation" (Pbrt.Pp.pp_option pp_range_var) fmt v.relation;
    Pbrt.Pp.pp_record_field ~first:false "access_method" Pbrt.Pp.pp_string fmt v.access_method;
    Pbrt.Pp.pp_record_field ~first:false "table_space" Pbrt.Pp.pp_string fmt v.table_space;
    Pbrt.Pp.pp_record_field ~first:false "index_params" (Pbrt.Pp.pp_list pp_node) fmt v.index_params;
    Pbrt.Pp.pp_record_field ~first:false "index_including_params" (Pbrt.Pp.pp_list pp_node) fmt v.index_including_params;
    Pbrt.Pp.pp_record_field ~first:false "options" (Pbrt.Pp.pp_list pp_node) fmt v.options;
    Pbrt.Pp.pp_record_field ~first:false "where_clause" (Pbrt.Pp.pp_option pp_node) fmt v.where_clause;
    Pbrt.Pp.pp_record_field ~first:false "exclude_op_names" (Pbrt.Pp.pp_list pp_node) fmt v.exclude_op_names;
    Pbrt.Pp.pp_record_field ~first:false "idxcomment" Pbrt.Pp.pp_string fmt v.idxcomment;
    Pbrt.Pp.pp_record_field ~first:false "index_oid" Pbrt.Pp.pp_int32 fmt v.index_oid;
    Pbrt.Pp.pp_record_field ~first:false "old_node" Pbrt.Pp.pp_int32 fmt v.old_node;
    Pbrt.Pp.pp_record_field ~first:false "old_create_subid" Pbrt.Pp.pp_int32 fmt v.old_create_subid;
    Pbrt.Pp.pp_record_field ~first:false "old_first_relfilenode_subid" Pbrt.Pp.pp_int32 fmt v.old_first_relfilenode_subid;
    Pbrt.Pp.pp_record_field ~first:false "unique" Pbrt.Pp.pp_bool fmt v.unique;
    Pbrt.Pp.pp_record_field ~first:false "primary" Pbrt.Pp.pp_bool fmt v.primary;
    Pbrt.Pp.pp_record_field ~first:false "isconstraint" Pbrt.Pp.pp_bool fmt v.isconstraint;
    Pbrt.Pp.pp_record_field ~first:false "deferrable" Pbrt.Pp.pp_bool fmt v.deferrable;
    Pbrt.Pp.pp_record_field ~first:false "initdeferred" Pbrt.Pp.pp_bool fmt v.initdeferred;
    Pbrt.Pp.pp_record_field ~first:false "transformed" Pbrt.Pp.pp_bool fmt v.transformed;
    Pbrt.Pp.pp_record_field ~first:false "concurrent" Pbrt.Pp.pp_bool fmt v.concurrent;
    Pbrt.Pp.pp_record_field ~first:false "if_not_exists" Pbrt.Pp.pp_bool fmt v.if_not_exists;
    Pbrt.Pp.pp_record_field ~first:false "reset_default_tblspc" Pbrt.Pp.pp_bool fmt v.reset_default_tblspc;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_create_function_stmt fmt (v:create_function_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "is_procedure" Pbrt.Pp.pp_bool fmt v.is_procedure;
    Pbrt.Pp.pp_record_field ~first:false "replace" Pbrt.Pp.pp_bool fmt v.replace;
    Pbrt.Pp.pp_record_field ~first:false "funcname" (Pbrt.Pp.pp_list pp_node) fmt v.funcname;
    Pbrt.Pp.pp_record_field ~first:false "parameters" (Pbrt.Pp.pp_list pp_node) fmt v.parameters;
    Pbrt.Pp.pp_record_field ~first:false "return_type" (Pbrt.Pp.pp_option pp_type_name) fmt v.return_type;
    Pbrt.Pp.pp_record_field ~first:false "options" (Pbrt.Pp.pp_list pp_node) fmt v.options;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_alter_function_stmt fmt (v:alter_function_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "objtype" pp_object_type fmt v.objtype;
    Pbrt.Pp.pp_record_field ~first:false "func" (Pbrt.Pp.pp_option pp_object_with_args) fmt v.func;
    Pbrt.Pp.pp_record_field ~first:false "actions" (Pbrt.Pp.pp_list pp_node) fmt v.actions;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_object_with_args fmt (v:object_with_args) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "objname" (Pbrt.Pp.pp_list pp_node) fmt v.objname;
    Pbrt.Pp.pp_record_field ~first:false "objargs" (Pbrt.Pp.pp_list pp_node) fmt v.objargs;
    Pbrt.Pp.pp_record_field ~first:false "args_unspecified" Pbrt.Pp.pp_bool fmt v.args_unspecified;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_do_stmt fmt (v:do_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "args" (Pbrt.Pp.pp_list pp_node) fmt v.args;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_rename_stmt fmt (v:rename_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "rename_type" pp_object_type fmt v.rename_type;
    Pbrt.Pp.pp_record_field ~first:false "relation_type" pp_object_type fmt v.relation_type;
    Pbrt.Pp.pp_record_field ~first:false "relation" (Pbrt.Pp.pp_option pp_range_var) fmt v.relation;
    Pbrt.Pp.pp_record_field ~first:false "object_" (Pbrt.Pp.pp_option pp_node) fmt v.object_;
    Pbrt.Pp.pp_record_field ~first:false "subname" Pbrt.Pp.pp_string fmt v.subname;
    Pbrt.Pp.pp_record_field ~first:false "newname" Pbrt.Pp.pp_string fmt v.newname;
    Pbrt.Pp.pp_record_field ~first:false "behavior" pp_drop_behavior fmt v.behavior;
    Pbrt.Pp.pp_record_field ~first:false "missing_ok" Pbrt.Pp.pp_bool fmt v.missing_ok;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_rule_stmt fmt (v:rule_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "relation" (Pbrt.Pp.pp_option pp_range_var) fmt v.relation;
    Pbrt.Pp.pp_record_field ~first:false "rulename" Pbrt.Pp.pp_string fmt v.rulename;
    Pbrt.Pp.pp_record_field ~first:false "where_clause" (Pbrt.Pp.pp_option pp_node) fmt v.where_clause;
    Pbrt.Pp.pp_record_field ~first:false "event" pp_cmd_type fmt v.event;
    Pbrt.Pp.pp_record_field ~first:false "instead" Pbrt.Pp.pp_bool fmt v.instead;
    Pbrt.Pp.pp_record_field ~first:false "actions" (Pbrt.Pp.pp_list pp_node) fmt v.actions;
    Pbrt.Pp.pp_record_field ~first:false "replace" Pbrt.Pp.pp_bool fmt v.replace;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_transaction_stmt fmt (v:transaction_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "kind" pp_transaction_stmt_kind fmt v.kind;
    Pbrt.Pp.pp_record_field ~first:false "options" (Pbrt.Pp.pp_list pp_node) fmt v.options;
    Pbrt.Pp.pp_record_field ~first:false "savepoint_name" Pbrt.Pp.pp_string fmt v.savepoint_name;
    Pbrt.Pp.pp_record_field ~first:false "gid" Pbrt.Pp.pp_string fmt v.gid;
    Pbrt.Pp.pp_record_field ~first:false "chain" Pbrt.Pp.pp_bool fmt v.chain;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_view_stmt fmt (v:view_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "view" (Pbrt.Pp.pp_option pp_range_var) fmt v.view;
    Pbrt.Pp.pp_record_field ~first:false "aliases" (Pbrt.Pp.pp_list pp_node) fmt v.aliases;
    Pbrt.Pp.pp_record_field ~first:false "query" (Pbrt.Pp.pp_option pp_node) fmt v.query;
    Pbrt.Pp.pp_record_field ~first:false "replace" Pbrt.Pp.pp_bool fmt v.replace;
    Pbrt.Pp.pp_record_field ~first:false "options" (Pbrt.Pp.pp_list pp_node) fmt v.options;
    Pbrt.Pp.pp_record_field ~first:false "with_check_option" pp_view_check_option fmt v.with_check_option;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_create_domain_stmt fmt (v:create_domain_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "domainname" (Pbrt.Pp.pp_list pp_node) fmt v.domainname;
    Pbrt.Pp.pp_record_field ~first:false "type_name" (Pbrt.Pp.pp_option pp_type_name) fmt v.type_name;
    Pbrt.Pp.pp_record_field ~first:false "coll_clause" (Pbrt.Pp.pp_option pp_collate_clause) fmt v.coll_clause;
    Pbrt.Pp.pp_record_field ~first:false "constraints" (Pbrt.Pp.pp_list pp_node) fmt v.constraints;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_collate_clause fmt (v:collate_clause) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "arg" (Pbrt.Pp.pp_option pp_node) fmt v.arg;
    Pbrt.Pp.pp_record_field ~first:false "collname" (Pbrt.Pp.pp_list pp_node) fmt v.collname;
    Pbrt.Pp.pp_record_field ~first:false "location" Pbrt.Pp.pp_int32 fmt v.location;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_createdb_stmt fmt (v:createdb_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "dbname" Pbrt.Pp.pp_string fmt v.dbname;
    Pbrt.Pp.pp_record_field ~first:false "options" (Pbrt.Pp.pp_list pp_node) fmt v.options;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_dropdb_stmt fmt (v:dropdb_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "dbname" Pbrt.Pp.pp_string fmt v.dbname;
    Pbrt.Pp.pp_record_field ~first:false "missing_ok" Pbrt.Pp.pp_bool fmt v.missing_ok;
    Pbrt.Pp.pp_record_field ~first:false "options" (Pbrt.Pp.pp_list pp_node) fmt v.options;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_vacuum_stmt fmt (v:vacuum_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "options" (Pbrt.Pp.pp_list pp_node) fmt v.options;
    Pbrt.Pp.pp_record_field ~first:false "rels" (Pbrt.Pp.pp_list pp_node) fmt v.rels;
    Pbrt.Pp.pp_record_field ~first:false "is_vacuumcmd" Pbrt.Pp.pp_bool fmt v.is_vacuumcmd;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_explain_stmt fmt (v:explain_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "query" (Pbrt.Pp.pp_option pp_node) fmt v.query;
    Pbrt.Pp.pp_record_field ~first:false "options" (Pbrt.Pp.pp_list pp_node) fmt v.options;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_create_table_as_stmt fmt (v:create_table_as_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "query" (Pbrt.Pp.pp_option pp_node) fmt v.query;
    Pbrt.Pp.pp_record_field ~first:false "into" (Pbrt.Pp.pp_option pp_into_clause) fmt v.into;
    Pbrt.Pp.pp_record_field ~first:false "relkind" pp_object_type fmt v.relkind;
    Pbrt.Pp.pp_record_field ~first:false "is_select_into" Pbrt.Pp.pp_bool fmt v.is_select_into;
    Pbrt.Pp.pp_record_field ~first:false "if_not_exists" Pbrt.Pp.pp_bool fmt v.if_not_exists;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_create_seq_stmt fmt (v:create_seq_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "sequence" (Pbrt.Pp.pp_option pp_range_var) fmt v.sequence;
    Pbrt.Pp.pp_record_field ~first:false "options" (Pbrt.Pp.pp_list pp_node) fmt v.options;
    Pbrt.Pp.pp_record_field ~first:false "owner_id" Pbrt.Pp.pp_int32 fmt v.owner_id;
    Pbrt.Pp.pp_record_field ~first:false "for_identity" Pbrt.Pp.pp_bool fmt v.for_identity;
    Pbrt.Pp.pp_record_field ~first:false "if_not_exists" Pbrt.Pp.pp_bool fmt v.if_not_exists;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_alter_seq_stmt fmt (v:alter_seq_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "sequence" (Pbrt.Pp.pp_option pp_range_var) fmt v.sequence;
    Pbrt.Pp.pp_record_field ~first:false "options" (Pbrt.Pp.pp_list pp_node) fmt v.options;
    Pbrt.Pp.pp_record_field ~first:false "for_identity" Pbrt.Pp.pp_bool fmt v.for_identity;
    Pbrt.Pp.pp_record_field ~first:false "missing_ok" Pbrt.Pp.pp_bool fmt v.missing_ok;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_variable_set_stmt fmt (v:variable_set_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "kind" pp_variable_set_kind fmt v.kind;
    Pbrt.Pp.pp_record_field ~first:false "name" Pbrt.Pp.pp_string fmt v.name;
    Pbrt.Pp.pp_record_field ~first:false "args" (Pbrt.Pp.pp_list pp_node) fmt v.args;
    Pbrt.Pp.pp_record_field ~first:false "is_local" Pbrt.Pp.pp_bool fmt v.is_local;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_create_trig_stmt fmt (v:create_trig_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "trigname" Pbrt.Pp.pp_string fmt v.trigname;
    Pbrt.Pp.pp_record_field ~first:false "relation" (Pbrt.Pp.pp_option pp_range_var) fmt v.relation;
    Pbrt.Pp.pp_record_field ~first:false "funcname" (Pbrt.Pp.pp_list pp_node) fmt v.funcname;
    Pbrt.Pp.pp_record_field ~first:false "args" (Pbrt.Pp.pp_list pp_node) fmt v.args;
    Pbrt.Pp.pp_record_field ~first:false "row" Pbrt.Pp.pp_bool fmt v.row;
    Pbrt.Pp.pp_record_field ~first:false "timing" Pbrt.Pp.pp_int32 fmt v.timing;
    Pbrt.Pp.pp_record_field ~first:false "events" Pbrt.Pp.pp_int32 fmt v.events;
    Pbrt.Pp.pp_record_field ~first:false "columns" (Pbrt.Pp.pp_list pp_node) fmt v.columns;
    Pbrt.Pp.pp_record_field ~first:false "when_clause" (Pbrt.Pp.pp_option pp_node) fmt v.when_clause;
    Pbrt.Pp.pp_record_field ~first:false "isconstraint" Pbrt.Pp.pp_bool fmt v.isconstraint;
    Pbrt.Pp.pp_record_field ~first:false "transition_rels" (Pbrt.Pp.pp_list pp_node) fmt v.transition_rels;
    Pbrt.Pp.pp_record_field ~first:false "deferrable" Pbrt.Pp.pp_bool fmt v.deferrable;
    Pbrt.Pp.pp_record_field ~first:false "initdeferred" Pbrt.Pp.pp_bool fmt v.initdeferred;
    Pbrt.Pp.pp_record_field ~first:false "constrrel" (Pbrt.Pp.pp_option pp_range_var) fmt v.constrrel;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_create_plang_stmt fmt (v:create_plang_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "replace" Pbrt.Pp.pp_bool fmt v.replace;
    Pbrt.Pp.pp_record_field ~first:false "plname" Pbrt.Pp.pp_string fmt v.plname;
    Pbrt.Pp.pp_record_field ~first:false "plhandler" (Pbrt.Pp.pp_list pp_node) fmt v.plhandler;
    Pbrt.Pp.pp_record_field ~first:false "plinline" (Pbrt.Pp.pp_list pp_node) fmt v.plinline;
    Pbrt.Pp.pp_record_field ~first:false "plvalidator" (Pbrt.Pp.pp_list pp_node) fmt v.plvalidator;
    Pbrt.Pp.pp_record_field ~first:false "pltrusted" Pbrt.Pp.pp_bool fmt v.pltrusted;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_create_role_stmt fmt (v:create_role_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "stmt_type" pp_role_stmt_type fmt v.stmt_type;
    Pbrt.Pp.pp_record_field ~first:false "role" Pbrt.Pp.pp_string fmt v.role;
    Pbrt.Pp.pp_record_field ~first:false "options" (Pbrt.Pp.pp_list pp_node) fmt v.options;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_alter_role_stmt fmt (v:alter_role_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "role" (Pbrt.Pp.pp_option pp_role_spec) fmt v.role;
    Pbrt.Pp.pp_record_field ~first:false "options" (Pbrt.Pp.pp_list pp_node) fmt v.options;
    Pbrt.Pp.pp_record_field ~first:false "action" Pbrt.Pp.pp_int32 fmt v.action;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_drop_role_stmt fmt (v:drop_role_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "roles" (Pbrt.Pp.pp_list pp_node) fmt v.roles;
    Pbrt.Pp.pp_record_field ~first:false "missing_ok" Pbrt.Pp.pp_bool fmt v.missing_ok;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_lock_stmt fmt (v:lock_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "relations" (Pbrt.Pp.pp_list pp_node) fmt v.relations;
    Pbrt.Pp.pp_record_field ~first:false "mode" Pbrt.Pp.pp_int32 fmt v.mode;
    Pbrt.Pp.pp_record_field ~first:false "nowait" Pbrt.Pp.pp_bool fmt v.nowait;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_constraints_set_stmt fmt (v:constraints_set_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "constraints" (Pbrt.Pp.pp_list pp_node) fmt v.constraints;
    Pbrt.Pp.pp_record_field ~first:false "deferred" Pbrt.Pp.pp_bool fmt v.deferred;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_reindex_stmt fmt (v:reindex_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "kind" pp_reindex_object_type fmt v.kind;
    Pbrt.Pp.pp_record_field ~first:false "relation" (Pbrt.Pp.pp_option pp_range_var) fmt v.relation;
    Pbrt.Pp.pp_record_field ~first:false "name" Pbrt.Pp.pp_string fmt v.name;
    Pbrt.Pp.pp_record_field ~first:false "options" Pbrt.Pp.pp_int32 fmt v.options;
    Pbrt.Pp.pp_record_field ~first:false "concurrent" Pbrt.Pp.pp_bool fmt v.concurrent;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_create_schema_stmt fmt (v:create_schema_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "schemaname" Pbrt.Pp.pp_string fmt v.schemaname;
    Pbrt.Pp.pp_record_field ~first:false "authrole" (Pbrt.Pp.pp_option pp_role_spec) fmt v.authrole;
    Pbrt.Pp.pp_record_field ~first:false "schema_elts" (Pbrt.Pp.pp_list pp_node) fmt v.schema_elts;
    Pbrt.Pp.pp_record_field ~first:false "if_not_exists" Pbrt.Pp.pp_bool fmt v.if_not_exists;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_alter_database_stmt fmt (v:alter_database_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "dbname" Pbrt.Pp.pp_string fmt v.dbname;
    Pbrt.Pp.pp_record_field ~first:false "options" (Pbrt.Pp.pp_list pp_node) fmt v.options;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_alter_database_set_stmt fmt (v:alter_database_set_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "dbname" Pbrt.Pp.pp_string fmt v.dbname;
    Pbrt.Pp.pp_record_field ~first:false "setstmt" (Pbrt.Pp.pp_option pp_variable_set_stmt) fmt v.setstmt;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_alter_role_set_stmt fmt (v:alter_role_set_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "role" (Pbrt.Pp.pp_option pp_role_spec) fmt v.role;
    Pbrt.Pp.pp_record_field ~first:false "database" Pbrt.Pp.pp_string fmt v.database;
    Pbrt.Pp.pp_record_field ~first:false "setstmt" (Pbrt.Pp.pp_option pp_variable_set_stmt) fmt v.setstmt;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_create_conversion_stmt fmt (v:create_conversion_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "conversion_name" (Pbrt.Pp.pp_list pp_node) fmt v.conversion_name;
    Pbrt.Pp.pp_record_field ~first:false "for_encoding_name" Pbrt.Pp.pp_string fmt v.for_encoding_name;
    Pbrt.Pp.pp_record_field ~first:false "to_encoding_name" Pbrt.Pp.pp_string fmt v.to_encoding_name;
    Pbrt.Pp.pp_record_field ~first:false "func_name" (Pbrt.Pp.pp_list pp_node) fmt v.func_name;
    Pbrt.Pp.pp_record_field ~first:false "def" Pbrt.Pp.pp_bool fmt v.def;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_create_cast_stmt fmt (v:create_cast_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "sourcetype" (Pbrt.Pp.pp_option pp_type_name) fmt v.sourcetype;
    Pbrt.Pp.pp_record_field ~first:false "targettype" (Pbrt.Pp.pp_option pp_type_name) fmt v.targettype;
    Pbrt.Pp.pp_record_field ~first:false "func" (Pbrt.Pp.pp_option pp_object_with_args) fmt v.func;
    Pbrt.Pp.pp_record_field ~first:false "context" pp_coercion_context fmt v.context;
    Pbrt.Pp.pp_record_field ~first:false "inout" Pbrt.Pp.pp_bool fmt v.inout;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_create_op_class_stmt fmt (v:create_op_class_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "opclassname" (Pbrt.Pp.pp_list pp_node) fmt v.opclassname;
    Pbrt.Pp.pp_record_field ~first:false "opfamilyname" (Pbrt.Pp.pp_list pp_node) fmt v.opfamilyname;
    Pbrt.Pp.pp_record_field ~first:false "amname" Pbrt.Pp.pp_string fmt v.amname;
    Pbrt.Pp.pp_record_field ~first:false "datatype" (Pbrt.Pp.pp_option pp_type_name) fmt v.datatype;
    Pbrt.Pp.pp_record_field ~first:false "items" (Pbrt.Pp.pp_list pp_node) fmt v.items;
    Pbrt.Pp.pp_record_field ~first:false "is_default" Pbrt.Pp.pp_bool fmt v.is_default;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_create_op_family_stmt fmt (v:create_op_family_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "opfamilyname" (Pbrt.Pp.pp_list pp_node) fmt v.opfamilyname;
    Pbrt.Pp.pp_record_field ~first:false "amname" Pbrt.Pp.pp_string fmt v.amname;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_alter_op_family_stmt fmt (v:alter_op_family_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "opfamilyname" (Pbrt.Pp.pp_list pp_node) fmt v.opfamilyname;
    Pbrt.Pp.pp_record_field ~first:false "amname" Pbrt.Pp.pp_string fmt v.amname;
    Pbrt.Pp.pp_record_field ~first:false "is_drop" Pbrt.Pp.pp_bool fmt v.is_drop;
    Pbrt.Pp.pp_record_field ~first:false "items" (Pbrt.Pp.pp_list pp_node) fmt v.items;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_prepare_stmt fmt (v:prepare_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "name" Pbrt.Pp.pp_string fmt v.name;
    Pbrt.Pp.pp_record_field ~first:false "argtypes" (Pbrt.Pp.pp_list pp_node) fmt v.argtypes;
    Pbrt.Pp.pp_record_field ~first:false "query" (Pbrt.Pp.pp_option pp_node) fmt v.query;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_execute_stmt fmt (v:execute_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "name" Pbrt.Pp.pp_string fmt v.name;
    Pbrt.Pp.pp_record_field ~first:false "params" (Pbrt.Pp.pp_list pp_node) fmt v.params;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_declare_cursor_stmt fmt (v:declare_cursor_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "portalname" Pbrt.Pp.pp_string fmt v.portalname;
    Pbrt.Pp.pp_record_field ~first:false "options" Pbrt.Pp.pp_int32 fmt v.options;
    Pbrt.Pp.pp_record_field ~first:false "query" (Pbrt.Pp.pp_option pp_node) fmt v.query;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_create_table_space_stmt fmt (v:create_table_space_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "tablespacename" Pbrt.Pp.pp_string fmt v.tablespacename;
    Pbrt.Pp.pp_record_field ~first:false "owner" (Pbrt.Pp.pp_option pp_role_spec) fmt v.owner;
    Pbrt.Pp.pp_record_field ~first:false "location" Pbrt.Pp.pp_string fmt v.location;
    Pbrt.Pp.pp_record_field ~first:false "options" (Pbrt.Pp.pp_list pp_node) fmt v.options;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_alter_object_depends_stmt fmt (v:alter_object_depends_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "object_type" pp_object_type fmt v.object_type;
    Pbrt.Pp.pp_record_field ~first:false "relation" (Pbrt.Pp.pp_option pp_range_var) fmt v.relation;
    Pbrt.Pp.pp_record_field ~first:false "object_" (Pbrt.Pp.pp_option pp_node) fmt v.object_;
    Pbrt.Pp.pp_record_field ~first:false "extname" (Pbrt.Pp.pp_option pp_node) fmt v.extname;
    Pbrt.Pp.pp_record_field ~first:false "remove" Pbrt.Pp.pp_bool fmt v.remove;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_alter_object_schema_stmt fmt (v:alter_object_schema_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "object_type" pp_object_type fmt v.object_type;
    Pbrt.Pp.pp_record_field ~first:false "relation" (Pbrt.Pp.pp_option pp_range_var) fmt v.relation;
    Pbrt.Pp.pp_record_field ~first:false "object_" (Pbrt.Pp.pp_option pp_node) fmt v.object_;
    Pbrt.Pp.pp_record_field ~first:false "newschema" Pbrt.Pp.pp_string fmt v.newschema;
    Pbrt.Pp.pp_record_field ~first:false "missing_ok" Pbrt.Pp.pp_bool fmt v.missing_ok;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_alter_owner_stmt fmt (v:alter_owner_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "object_type" pp_object_type fmt v.object_type;
    Pbrt.Pp.pp_record_field ~first:false "relation" (Pbrt.Pp.pp_option pp_range_var) fmt v.relation;
    Pbrt.Pp.pp_record_field ~first:false "object_" (Pbrt.Pp.pp_option pp_node) fmt v.object_;
    Pbrt.Pp.pp_record_field ~first:false "newowner" (Pbrt.Pp.pp_option pp_role_spec) fmt v.newowner;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_alter_operator_stmt fmt (v:alter_operator_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "opername" (Pbrt.Pp.pp_option pp_object_with_args) fmt v.opername;
    Pbrt.Pp.pp_record_field ~first:false "options" (Pbrt.Pp.pp_list pp_node) fmt v.options;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_alter_type_stmt fmt (v:alter_type_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "type_name" (Pbrt.Pp.pp_list pp_node) fmt v.type_name;
    Pbrt.Pp.pp_record_field ~first:false "options" (Pbrt.Pp.pp_list pp_node) fmt v.options;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_drop_owned_stmt fmt (v:drop_owned_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "roles" (Pbrt.Pp.pp_list pp_node) fmt v.roles;
    Pbrt.Pp.pp_record_field ~first:false "behavior" pp_drop_behavior fmt v.behavior;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_reassign_owned_stmt fmt (v:reassign_owned_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "roles" (Pbrt.Pp.pp_list pp_node) fmt v.roles;
    Pbrt.Pp.pp_record_field ~first:false "newrole" (Pbrt.Pp.pp_option pp_role_spec) fmt v.newrole;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_composite_type_stmt fmt (v:composite_type_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "typevar" (Pbrt.Pp.pp_option pp_range_var) fmt v.typevar;
    Pbrt.Pp.pp_record_field ~first:false "coldeflist" (Pbrt.Pp.pp_list pp_node) fmt v.coldeflist;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_create_enum_stmt fmt (v:create_enum_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "type_name" (Pbrt.Pp.pp_list pp_node) fmt v.type_name;
    Pbrt.Pp.pp_record_field ~first:false "vals" (Pbrt.Pp.pp_list pp_node) fmt v.vals;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_create_range_stmt fmt (v:create_range_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "type_name" (Pbrt.Pp.pp_list pp_node) fmt v.type_name;
    Pbrt.Pp.pp_record_field ~first:false "params" (Pbrt.Pp.pp_list pp_node) fmt v.params;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_alter_enum_stmt fmt (v:alter_enum_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "type_name" (Pbrt.Pp.pp_list pp_node) fmt v.type_name;
    Pbrt.Pp.pp_record_field ~first:false "old_val" Pbrt.Pp.pp_string fmt v.old_val;
    Pbrt.Pp.pp_record_field ~first:false "new_val" Pbrt.Pp.pp_string fmt v.new_val;
    Pbrt.Pp.pp_record_field ~first:false "new_val_neighbor" Pbrt.Pp.pp_string fmt v.new_val_neighbor;
    Pbrt.Pp.pp_record_field ~first:false "new_val_is_after" Pbrt.Pp.pp_bool fmt v.new_val_is_after;
    Pbrt.Pp.pp_record_field ~first:false "skip_if_new_val_exists" Pbrt.Pp.pp_bool fmt v.skip_if_new_val_exists;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_alter_tsdictionary_stmt fmt (v:alter_tsdictionary_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "dictname" (Pbrt.Pp.pp_list pp_node) fmt v.dictname;
    Pbrt.Pp.pp_record_field ~first:false "options" (Pbrt.Pp.pp_list pp_node) fmt v.options;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_alter_tsconfiguration_stmt fmt (v:alter_tsconfiguration_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "kind" pp_alter_tsconfig_type fmt v.kind;
    Pbrt.Pp.pp_record_field ~first:false "cfgname" (Pbrt.Pp.pp_list pp_node) fmt v.cfgname;
    Pbrt.Pp.pp_record_field ~first:false "tokentype" (Pbrt.Pp.pp_list pp_node) fmt v.tokentype;
    Pbrt.Pp.pp_record_field ~first:false "dicts" (Pbrt.Pp.pp_list pp_node) fmt v.dicts;
    Pbrt.Pp.pp_record_field ~first:false "override" Pbrt.Pp.pp_bool fmt v.override;
    Pbrt.Pp.pp_record_field ~first:false "replace" Pbrt.Pp.pp_bool fmt v.replace;
    Pbrt.Pp.pp_record_field ~first:false "missing_ok" Pbrt.Pp.pp_bool fmt v.missing_ok;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_create_fdw_stmt fmt (v:create_fdw_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "fdwname" Pbrt.Pp.pp_string fmt v.fdwname;
    Pbrt.Pp.pp_record_field ~first:false "func_options" (Pbrt.Pp.pp_list pp_node) fmt v.func_options;
    Pbrt.Pp.pp_record_field ~first:false "options" (Pbrt.Pp.pp_list pp_node) fmt v.options;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_alter_fdw_stmt fmt (v:alter_fdw_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "fdwname" Pbrt.Pp.pp_string fmt v.fdwname;
    Pbrt.Pp.pp_record_field ~first:false "func_options" (Pbrt.Pp.pp_list pp_node) fmt v.func_options;
    Pbrt.Pp.pp_record_field ~first:false "options" (Pbrt.Pp.pp_list pp_node) fmt v.options;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_create_foreign_server_stmt fmt (v:create_foreign_server_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "servername" Pbrt.Pp.pp_string fmt v.servername;
    Pbrt.Pp.pp_record_field ~first:false "servertype" Pbrt.Pp.pp_string fmt v.servertype;
    Pbrt.Pp.pp_record_field ~first:false "version" Pbrt.Pp.pp_string fmt v.version;
    Pbrt.Pp.pp_record_field ~first:false "fdwname" Pbrt.Pp.pp_string fmt v.fdwname;
    Pbrt.Pp.pp_record_field ~first:false "if_not_exists" Pbrt.Pp.pp_bool fmt v.if_not_exists;
    Pbrt.Pp.pp_record_field ~first:false "options" (Pbrt.Pp.pp_list pp_node) fmt v.options;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_alter_foreign_server_stmt fmt (v:alter_foreign_server_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "servername" Pbrt.Pp.pp_string fmt v.servername;
    Pbrt.Pp.pp_record_field ~first:false "version" Pbrt.Pp.pp_string fmt v.version;
    Pbrt.Pp.pp_record_field ~first:false "options" (Pbrt.Pp.pp_list pp_node) fmt v.options;
    Pbrt.Pp.pp_record_field ~first:false "has_version" Pbrt.Pp.pp_bool fmt v.has_version;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_create_user_mapping_stmt fmt (v:create_user_mapping_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "user" (Pbrt.Pp.pp_option pp_role_spec) fmt v.user;
    Pbrt.Pp.pp_record_field ~first:false "servername" Pbrt.Pp.pp_string fmt v.servername;
    Pbrt.Pp.pp_record_field ~first:false "if_not_exists" Pbrt.Pp.pp_bool fmt v.if_not_exists;
    Pbrt.Pp.pp_record_field ~first:false "options" (Pbrt.Pp.pp_list pp_node) fmt v.options;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_alter_user_mapping_stmt fmt (v:alter_user_mapping_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "user" (Pbrt.Pp.pp_option pp_role_spec) fmt v.user;
    Pbrt.Pp.pp_record_field ~first:false "servername" Pbrt.Pp.pp_string fmt v.servername;
    Pbrt.Pp.pp_record_field ~first:false "options" (Pbrt.Pp.pp_list pp_node) fmt v.options;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_alter_table_space_options_stmt fmt (v:alter_table_space_options_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "tablespacename" Pbrt.Pp.pp_string fmt v.tablespacename;
    Pbrt.Pp.pp_record_field ~first:false "options" (Pbrt.Pp.pp_list pp_node) fmt v.options;
    Pbrt.Pp.pp_record_field ~first:false "is_reset" Pbrt.Pp.pp_bool fmt v.is_reset;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_alter_table_move_all_stmt fmt (v:alter_table_move_all_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "orig_tablespacename" Pbrt.Pp.pp_string fmt v.orig_tablespacename;
    Pbrt.Pp.pp_record_field ~first:false "objtype" pp_object_type fmt v.objtype;
    Pbrt.Pp.pp_record_field ~first:false "roles" (Pbrt.Pp.pp_list pp_node) fmt v.roles;
    Pbrt.Pp.pp_record_field ~first:false "new_tablespacename" Pbrt.Pp.pp_string fmt v.new_tablespacename;
    Pbrt.Pp.pp_record_field ~first:false "nowait" Pbrt.Pp.pp_bool fmt v.nowait;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_sec_label_stmt fmt (v:sec_label_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "objtype" pp_object_type fmt v.objtype;
    Pbrt.Pp.pp_record_field ~first:false "object_" (Pbrt.Pp.pp_option pp_node) fmt v.object_;
    Pbrt.Pp.pp_record_field ~first:false "provider" Pbrt.Pp.pp_string fmt v.provider;
    Pbrt.Pp.pp_record_field ~first:false "label" Pbrt.Pp.pp_string fmt v.label;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_create_foreign_table_stmt fmt (v:create_foreign_table_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "base_stmt" (Pbrt.Pp.pp_option pp_create_stmt) fmt v.base_stmt;
    Pbrt.Pp.pp_record_field ~first:false "servername" Pbrt.Pp.pp_string fmt v.servername;
    Pbrt.Pp.pp_record_field ~first:false "options" (Pbrt.Pp.pp_list pp_node) fmt v.options;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_import_foreign_schema_stmt fmt (v:import_foreign_schema_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "server_name" Pbrt.Pp.pp_string fmt v.server_name;
    Pbrt.Pp.pp_record_field ~first:false "remote_schema" Pbrt.Pp.pp_string fmt v.remote_schema;
    Pbrt.Pp.pp_record_field ~first:false "local_schema" Pbrt.Pp.pp_string fmt v.local_schema;
    Pbrt.Pp.pp_record_field ~first:false "list_type" pp_import_foreign_schema_type fmt v.list_type;
    Pbrt.Pp.pp_record_field ~first:false "table_list" (Pbrt.Pp.pp_list pp_node) fmt v.table_list;
    Pbrt.Pp.pp_record_field ~first:false "options" (Pbrt.Pp.pp_list pp_node) fmt v.options;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_create_extension_stmt fmt (v:create_extension_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "extname" Pbrt.Pp.pp_string fmt v.extname;
    Pbrt.Pp.pp_record_field ~first:false "if_not_exists" Pbrt.Pp.pp_bool fmt v.if_not_exists;
    Pbrt.Pp.pp_record_field ~first:false "options" (Pbrt.Pp.pp_list pp_node) fmt v.options;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_alter_extension_stmt fmt (v:alter_extension_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "extname" Pbrt.Pp.pp_string fmt v.extname;
    Pbrt.Pp.pp_record_field ~first:false "options" (Pbrt.Pp.pp_list pp_node) fmt v.options;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_alter_extension_contents_stmt fmt (v:alter_extension_contents_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "extname" Pbrt.Pp.pp_string fmt v.extname;
    Pbrt.Pp.pp_record_field ~first:false "action" Pbrt.Pp.pp_int32 fmt v.action;
    Pbrt.Pp.pp_record_field ~first:false "objtype" pp_object_type fmt v.objtype;
    Pbrt.Pp.pp_record_field ~first:false "object_" (Pbrt.Pp.pp_option pp_node) fmt v.object_;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_create_event_trig_stmt fmt (v:create_event_trig_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "trigname" Pbrt.Pp.pp_string fmt v.trigname;
    Pbrt.Pp.pp_record_field ~first:false "eventname" Pbrt.Pp.pp_string fmt v.eventname;
    Pbrt.Pp.pp_record_field ~first:false "whenclause" (Pbrt.Pp.pp_list pp_node) fmt v.whenclause;
    Pbrt.Pp.pp_record_field ~first:false "funcname" (Pbrt.Pp.pp_list pp_node) fmt v.funcname;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_refresh_mat_view_stmt fmt (v:refresh_mat_view_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "concurrent" Pbrt.Pp.pp_bool fmt v.concurrent;
    Pbrt.Pp.pp_record_field ~first:false "skip_data" Pbrt.Pp.pp_bool fmt v.skip_data;
    Pbrt.Pp.pp_record_field ~first:false "relation" (Pbrt.Pp.pp_option pp_range_var) fmt v.relation;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_alter_system_stmt fmt (v:alter_system_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "setstmt" (Pbrt.Pp.pp_option pp_variable_set_stmt) fmt v.setstmt;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_create_policy_stmt fmt (v:create_policy_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "policy_name" Pbrt.Pp.pp_string fmt v.policy_name;
    Pbrt.Pp.pp_record_field ~first:false "table" (Pbrt.Pp.pp_option pp_range_var) fmt v.table;
    Pbrt.Pp.pp_record_field ~first:false "cmd_name" Pbrt.Pp.pp_string fmt v.cmd_name;
    Pbrt.Pp.pp_record_field ~first:false "permissive" Pbrt.Pp.pp_bool fmt v.permissive;
    Pbrt.Pp.pp_record_field ~first:false "roles" (Pbrt.Pp.pp_list pp_node) fmt v.roles;
    Pbrt.Pp.pp_record_field ~first:false "qual" (Pbrt.Pp.pp_option pp_node) fmt v.qual;
    Pbrt.Pp.pp_record_field ~first:false "with_check" (Pbrt.Pp.pp_option pp_node) fmt v.with_check;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_alter_policy_stmt fmt (v:alter_policy_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "policy_name" Pbrt.Pp.pp_string fmt v.policy_name;
    Pbrt.Pp.pp_record_field ~first:false "table" (Pbrt.Pp.pp_option pp_range_var) fmt v.table;
    Pbrt.Pp.pp_record_field ~first:false "roles" (Pbrt.Pp.pp_list pp_node) fmt v.roles;
    Pbrt.Pp.pp_record_field ~first:false "qual" (Pbrt.Pp.pp_option pp_node) fmt v.qual;
    Pbrt.Pp.pp_record_field ~first:false "with_check" (Pbrt.Pp.pp_option pp_node) fmt v.with_check;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_create_transform_stmt fmt (v:create_transform_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "replace" Pbrt.Pp.pp_bool fmt v.replace;
    Pbrt.Pp.pp_record_field ~first:false "type_name" (Pbrt.Pp.pp_option pp_type_name) fmt v.type_name;
    Pbrt.Pp.pp_record_field ~first:false "lang" Pbrt.Pp.pp_string fmt v.lang;
    Pbrt.Pp.pp_record_field ~first:false "fromsql" (Pbrt.Pp.pp_option pp_object_with_args) fmt v.fromsql;
    Pbrt.Pp.pp_record_field ~first:false "tosql" (Pbrt.Pp.pp_option pp_object_with_args) fmt v.tosql;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_create_am_stmt fmt (v:create_am_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "amname" Pbrt.Pp.pp_string fmt v.amname;
    Pbrt.Pp.pp_record_field ~first:false "handler_name" (Pbrt.Pp.pp_list pp_node) fmt v.handler_name;
    Pbrt.Pp.pp_record_field ~first:false "amtype" Pbrt.Pp.pp_string fmt v.amtype;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_create_publication_stmt fmt (v:create_publication_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "pubname" Pbrt.Pp.pp_string fmt v.pubname;
    Pbrt.Pp.pp_record_field ~first:false "options" (Pbrt.Pp.pp_list pp_node) fmt v.options;
    Pbrt.Pp.pp_record_field ~first:false "tables" (Pbrt.Pp.pp_list pp_node) fmt v.tables;
    Pbrt.Pp.pp_record_field ~first:false "for_all_tables" Pbrt.Pp.pp_bool fmt v.for_all_tables;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_alter_publication_stmt fmt (v:alter_publication_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "pubname" Pbrt.Pp.pp_string fmt v.pubname;
    Pbrt.Pp.pp_record_field ~first:false "options" (Pbrt.Pp.pp_list pp_node) fmt v.options;
    Pbrt.Pp.pp_record_field ~first:false "tables" (Pbrt.Pp.pp_list pp_node) fmt v.tables;
    Pbrt.Pp.pp_record_field ~first:false "for_all_tables" Pbrt.Pp.pp_bool fmt v.for_all_tables;
    Pbrt.Pp.pp_record_field ~first:false "table_action" pp_def_elem_action fmt v.table_action;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_create_subscription_stmt fmt (v:create_subscription_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "subname" Pbrt.Pp.pp_string fmt v.subname;
    Pbrt.Pp.pp_record_field ~first:false "conninfo" Pbrt.Pp.pp_string fmt v.conninfo;
    Pbrt.Pp.pp_record_field ~first:false "publication" (Pbrt.Pp.pp_list pp_node) fmt v.publication;
    Pbrt.Pp.pp_record_field ~first:false "options" (Pbrt.Pp.pp_list pp_node) fmt v.options;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_alter_subscription_stmt fmt (v:alter_subscription_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "kind" pp_alter_subscription_type fmt v.kind;
    Pbrt.Pp.pp_record_field ~first:false "subname" Pbrt.Pp.pp_string fmt v.subname;
    Pbrt.Pp.pp_record_field ~first:false "conninfo" Pbrt.Pp.pp_string fmt v.conninfo;
    Pbrt.Pp.pp_record_field ~first:false "publication" (Pbrt.Pp.pp_list pp_node) fmt v.publication;
    Pbrt.Pp.pp_record_field ~first:false "options" (Pbrt.Pp.pp_list pp_node) fmt v.options;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_create_stats_stmt fmt (v:create_stats_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "defnames" (Pbrt.Pp.pp_list pp_node) fmt v.defnames;
    Pbrt.Pp.pp_record_field ~first:false "stat_types" (Pbrt.Pp.pp_list pp_node) fmt v.stat_types;
    Pbrt.Pp.pp_record_field ~first:false "exprs" (Pbrt.Pp.pp_list pp_node) fmt v.exprs;
    Pbrt.Pp.pp_record_field ~first:false "relations" (Pbrt.Pp.pp_list pp_node) fmt v.relations;
    Pbrt.Pp.pp_record_field ~first:false "stxcomment" Pbrt.Pp.pp_string fmt v.stxcomment;
    Pbrt.Pp.pp_record_field ~first:false "if_not_exists" Pbrt.Pp.pp_bool fmt v.if_not_exists;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_alter_collation_stmt fmt (v:alter_collation_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "collname" (Pbrt.Pp.pp_list pp_node) fmt v.collname;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_call_stmt fmt (v:call_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "funccall" (Pbrt.Pp.pp_option pp_func_call) fmt v.funccall;
    Pbrt.Pp.pp_record_field ~first:false "funcexpr" (Pbrt.Pp.pp_option pp_func_expr) fmt v.funcexpr;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_func_call fmt (v:func_call) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "funcname" (Pbrt.Pp.pp_list pp_node) fmt v.funcname;
    Pbrt.Pp.pp_record_field ~first:false "args" (Pbrt.Pp.pp_list pp_node) fmt v.args;
    Pbrt.Pp.pp_record_field ~first:false "agg_order" (Pbrt.Pp.pp_list pp_node) fmt v.agg_order;
    Pbrt.Pp.pp_record_field ~first:false "agg_filter" (Pbrt.Pp.pp_option pp_node) fmt v.agg_filter;
    Pbrt.Pp.pp_record_field ~first:false "agg_within_group" Pbrt.Pp.pp_bool fmt v.agg_within_group;
    Pbrt.Pp.pp_record_field ~first:false "agg_star" Pbrt.Pp.pp_bool fmt v.agg_star;
    Pbrt.Pp.pp_record_field ~first:false "agg_distinct" Pbrt.Pp.pp_bool fmt v.agg_distinct;
    Pbrt.Pp.pp_record_field ~first:false "func_variadic" Pbrt.Pp.pp_bool fmt v.func_variadic;
    Pbrt.Pp.pp_record_field ~first:false "over" (Pbrt.Pp.pp_option pp_window_def) fmt v.over;
    Pbrt.Pp.pp_record_field ~first:false "location" Pbrt.Pp.pp_int32 fmt v.location;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_window_def fmt (v:window_def) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "name" Pbrt.Pp.pp_string fmt v.name;
    Pbrt.Pp.pp_record_field ~first:false "refname" Pbrt.Pp.pp_string fmt v.refname;
    Pbrt.Pp.pp_record_field ~first:false "partition_clause" (Pbrt.Pp.pp_list pp_node) fmt v.partition_clause;
    Pbrt.Pp.pp_record_field ~first:false "order_clause" (Pbrt.Pp.pp_list pp_node) fmt v.order_clause;
    Pbrt.Pp.pp_record_field ~first:false "frame_options" Pbrt.Pp.pp_int32 fmt v.frame_options;
    Pbrt.Pp.pp_record_field ~first:false "start_offset" (Pbrt.Pp.pp_option pp_node) fmt v.start_offset;
    Pbrt.Pp.pp_record_field ~first:false "end_offset" (Pbrt.Pp.pp_option pp_node) fmt v.end_offset;
    Pbrt.Pp.pp_record_field ~first:false "location" Pbrt.Pp.pp_int32 fmt v.location;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_alter_stats_stmt fmt (v:alter_stats_stmt) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "defnames" (Pbrt.Pp.pp_list pp_node) fmt v.defnames;
    Pbrt.Pp.pp_record_field ~first:false "stxstattarget" Pbrt.Pp.pp_int32 fmt v.stxstattarget;
    Pbrt.Pp.pp_record_field ~first:false "missing_ok" Pbrt.Pp.pp_bool fmt v.missing_ok;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_a_expr fmt (v:a_expr) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "kind" pp_a_expr_kind fmt v.kind;
    Pbrt.Pp.pp_record_field ~first:false "name" (Pbrt.Pp.pp_list pp_node) fmt v.name;
    Pbrt.Pp.pp_record_field ~first:false "lexpr" (Pbrt.Pp.pp_option pp_node) fmt v.lexpr;
    Pbrt.Pp.pp_record_field ~first:false "rexpr" (Pbrt.Pp.pp_option pp_node) fmt v.rexpr;
    Pbrt.Pp.pp_record_field ~first:false "location" Pbrt.Pp.pp_int32 fmt v.location;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_column_ref fmt (v:column_ref) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "fields" (Pbrt.Pp.pp_list pp_node) fmt v.fields;
    Pbrt.Pp.pp_record_field ~first:false "location" Pbrt.Pp.pp_int32 fmt v.location;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_a_const fmt (v:a_const) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "val_" (Pbrt.Pp.pp_option pp_node) fmt v.val_;
    Pbrt.Pp.pp_record_field ~first:false "location" Pbrt.Pp.pp_int32 fmt v.location;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_a_indices fmt (v:a_indices) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "is_slice" Pbrt.Pp.pp_bool fmt v.is_slice;
    Pbrt.Pp.pp_record_field ~first:false "lidx" (Pbrt.Pp.pp_option pp_node) fmt v.lidx;
    Pbrt.Pp.pp_record_field ~first:false "uidx" (Pbrt.Pp.pp_option pp_node) fmt v.uidx;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_a_indirection fmt (v:a_indirection) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "arg" (Pbrt.Pp.pp_option pp_node) fmt v.arg;
    Pbrt.Pp.pp_record_field ~first:false "indirection" (Pbrt.Pp.pp_list pp_node) fmt v.indirection;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_a_array_expr fmt (v:a_array_expr) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "elements" (Pbrt.Pp.pp_list pp_node) fmt v.elements;
    Pbrt.Pp.pp_record_field ~first:false "location" Pbrt.Pp.pp_int32 fmt v.location;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_res_target fmt (v:res_target) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "name" Pbrt.Pp.pp_string fmt v.name;
    Pbrt.Pp.pp_record_field ~first:false "indirection" (Pbrt.Pp.pp_list pp_node) fmt v.indirection;
    Pbrt.Pp.pp_record_field ~first:false "val_" (Pbrt.Pp.pp_option pp_node) fmt v.val_;
    Pbrt.Pp.pp_record_field ~first:false "location" Pbrt.Pp.pp_int32 fmt v.location;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_multi_assign_ref fmt (v:multi_assign_ref) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "source" (Pbrt.Pp.pp_option pp_node) fmt v.source;
    Pbrt.Pp.pp_record_field ~first:false "colno" Pbrt.Pp.pp_int32 fmt v.colno;
    Pbrt.Pp.pp_record_field ~first:false "ncolumns" Pbrt.Pp.pp_int32 fmt v.ncolumns;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_type_cast fmt (v:type_cast) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "arg" (Pbrt.Pp.pp_option pp_node) fmt v.arg;
    Pbrt.Pp.pp_record_field ~first:false "type_name" (Pbrt.Pp.pp_option pp_type_name) fmt v.type_name;
    Pbrt.Pp.pp_record_field ~first:false "location" Pbrt.Pp.pp_int32 fmt v.location;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_sort_by fmt (v:sort_by) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "node" (Pbrt.Pp.pp_option pp_node) fmt v.node;
    Pbrt.Pp.pp_record_field ~first:false "sortby_dir" pp_sort_by_dir fmt v.sortby_dir;
    Pbrt.Pp.pp_record_field ~first:false "sortby_nulls" pp_sort_by_nulls fmt v.sortby_nulls;
    Pbrt.Pp.pp_record_field ~first:false "use_op" (Pbrt.Pp.pp_list pp_node) fmt v.use_op;
    Pbrt.Pp.pp_record_field ~first:false "location" Pbrt.Pp.pp_int32 fmt v.location;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_range_subselect fmt (v:range_subselect) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "lateral" Pbrt.Pp.pp_bool fmt v.lateral;
    Pbrt.Pp.pp_record_field ~first:false "subquery" (Pbrt.Pp.pp_option pp_node) fmt v.subquery;
    Pbrt.Pp.pp_record_field ~first:false "alias" (Pbrt.Pp.pp_option pp_alias) fmt v.alias;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_range_function fmt (v:range_function) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "lateral" Pbrt.Pp.pp_bool fmt v.lateral;
    Pbrt.Pp.pp_record_field ~first:false "ordinality" Pbrt.Pp.pp_bool fmt v.ordinality;
    Pbrt.Pp.pp_record_field ~first:false "is_rowsfrom" Pbrt.Pp.pp_bool fmt v.is_rowsfrom;
    Pbrt.Pp.pp_record_field ~first:false "functions" (Pbrt.Pp.pp_list pp_node) fmt v.functions;
    Pbrt.Pp.pp_record_field ~first:false "alias" (Pbrt.Pp.pp_option pp_alias) fmt v.alias;
    Pbrt.Pp.pp_record_field ~first:false "coldeflist" (Pbrt.Pp.pp_list pp_node) fmt v.coldeflist;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_range_table_sample fmt (v:range_table_sample) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "relation" (Pbrt.Pp.pp_option pp_node) fmt v.relation;
    Pbrt.Pp.pp_record_field ~first:false "method_" (Pbrt.Pp.pp_list pp_node) fmt v.method_;
    Pbrt.Pp.pp_record_field ~first:false "args" (Pbrt.Pp.pp_list pp_node) fmt v.args;
    Pbrt.Pp.pp_record_field ~first:false "repeatable" (Pbrt.Pp.pp_option pp_node) fmt v.repeatable;
    Pbrt.Pp.pp_record_field ~first:false "location" Pbrt.Pp.pp_int32 fmt v.location;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_range_table_func fmt (v:range_table_func) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "lateral" Pbrt.Pp.pp_bool fmt v.lateral;
    Pbrt.Pp.pp_record_field ~first:false "docexpr" (Pbrt.Pp.pp_option pp_node) fmt v.docexpr;
    Pbrt.Pp.pp_record_field ~first:false "rowexpr" (Pbrt.Pp.pp_option pp_node) fmt v.rowexpr;
    Pbrt.Pp.pp_record_field ~first:false "namespaces" (Pbrt.Pp.pp_list pp_node) fmt v.namespaces;
    Pbrt.Pp.pp_record_field ~first:false "columns" (Pbrt.Pp.pp_list pp_node) fmt v.columns;
    Pbrt.Pp.pp_record_field ~first:false "alias" (Pbrt.Pp.pp_option pp_alias) fmt v.alias;
    Pbrt.Pp.pp_record_field ~first:false "location" Pbrt.Pp.pp_int32 fmt v.location;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_range_table_func_col fmt (v:range_table_func_col) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "colname" Pbrt.Pp.pp_string fmt v.colname;
    Pbrt.Pp.pp_record_field ~first:false "type_name" (Pbrt.Pp.pp_option pp_type_name) fmt v.type_name;
    Pbrt.Pp.pp_record_field ~first:false "for_ordinality" Pbrt.Pp.pp_bool fmt v.for_ordinality;
    Pbrt.Pp.pp_record_field ~first:false "is_not_null" Pbrt.Pp.pp_bool fmt v.is_not_null;
    Pbrt.Pp.pp_record_field ~first:false "colexpr" (Pbrt.Pp.pp_option pp_node) fmt v.colexpr;
    Pbrt.Pp.pp_record_field ~first:false "coldefexpr" (Pbrt.Pp.pp_option pp_node) fmt v.coldefexpr;
    Pbrt.Pp.pp_record_field ~first:false "location" Pbrt.Pp.pp_int32 fmt v.location;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_column_def fmt (v:column_def) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "colname" Pbrt.Pp.pp_string fmt v.colname;
    Pbrt.Pp.pp_record_field ~first:false "type_name" (Pbrt.Pp.pp_option pp_type_name) fmt v.type_name;
    Pbrt.Pp.pp_record_field ~first:false "inhcount" Pbrt.Pp.pp_int32 fmt v.inhcount;
    Pbrt.Pp.pp_record_field ~first:false "is_local" Pbrt.Pp.pp_bool fmt v.is_local;
    Pbrt.Pp.pp_record_field ~first:false "is_not_null" Pbrt.Pp.pp_bool fmt v.is_not_null;
    Pbrt.Pp.pp_record_field ~first:false "is_from_type" Pbrt.Pp.pp_bool fmt v.is_from_type;
    Pbrt.Pp.pp_record_field ~first:false "storage" Pbrt.Pp.pp_string fmt v.storage;
    Pbrt.Pp.pp_record_field ~first:false "raw_default" (Pbrt.Pp.pp_option pp_node) fmt v.raw_default;
    Pbrt.Pp.pp_record_field ~first:false "cooked_default" (Pbrt.Pp.pp_option pp_node) fmt v.cooked_default;
    Pbrt.Pp.pp_record_field ~first:false "identity" Pbrt.Pp.pp_string fmt v.identity;
    Pbrt.Pp.pp_record_field ~first:false "identity_sequence" (Pbrt.Pp.pp_option pp_range_var) fmt v.identity_sequence;
    Pbrt.Pp.pp_record_field ~first:false "generated" Pbrt.Pp.pp_string fmt v.generated;
    Pbrt.Pp.pp_record_field ~first:false "coll_clause" (Pbrt.Pp.pp_option pp_collate_clause) fmt v.coll_clause;
    Pbrt.Pp.pp_record_field ~first:false "coll_oid" Pbrt.Pp.pp_int32 fmt v.coll_oid;
    Pbrt.Pp.pp_record_field ~first:false "constraints" (Pbrt.Pp.pp_list pp_node) fmt v.constraints;
    Pbrt.Pp.pp_record_field ~first:false "fdwoptions" (Pbrt.Pp.pp_list pp_node) fmt v.fdwoptions;
    Pbrt.Pp.pp_record_field ~first:false "location" Pbrt.Pp.pp_int32 fmt v.location;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_index_elem fmt (v:index_elem) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "name" Pbrt.Pp.pp_string fmt v.name;
    Pbrt.Pp.pp_record_field ~first:false "expr" (Pbrt.Pp.pp_option pp_node) fmt v.expr;
    Pbrt.Pp.pp_record_field ~first:false "indexcolname" Pbrt.Pp.pp_string fmt v.indexcolname;
    Pbrt.Pp.pp_record_field ~first:false "collation" (Pbrt.Pp.pp_list pp_node) fmt v.collation;
    Pbrt.Pp.pp_record_field ~first:false "opclass" (Pbrt.Pp.pp_list pp_node) fmt v.opclass;
    Pbrt.Pp.pp_record_field ~first:false "opclassopts" (Pbrt.Pp.pp_list pp_node) fmt v.opclassopts;
    Pbrt.Pp.pp_record_field ~first:false "ordering" pp_sort_by_dir fmt v.ordering;
    Pbrt.Pp.pp_record_field ~first:false "nulls_ordering" pp_sort_by_nulls fmt v.nulls_ordering;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_constraint_ fmt (v:constraint_) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "contype" pp_constr_type fmt v.contype;
    Pbrt.Pp.pp_record_field ~first:false "conname" Pbrt.Pp.pp_string fmt v.conname;
    Pbrt.Pp.pp_record_field ~first:false "deferrable" Pbrt.Pp.pp_bool fmt v.deferrable;
    Pbrt.Pp.pp_record_field ~first:false "initdeferred" Pbrt.Pp.pp_bool fmt v.initdeferred;
    Pbrt.Pp.pp_record_field ~first:false "location" Pbrt.Pp.pp_int32 fmt v.location;
    Pbrt.Pp.pp_record_field ~first:false "is_no_inherit" Pbrt.Pp.pp_bool fmt v.is_no_inherit;
    Pbrt.Pp.pp_record_field ~first:false "raw_expr" (Pbrt.Pp.pp_option pp_node) fmt v.raw_expr;
    Pbrt.Pp.pp_record_field ~first:false "cooked_expr" Pbrt.Pp.pp_string fmt v.cooked_expr;
    Pbrt.Pp.pp_record_field ~first:false "generated_when" Pbrt.Pp.pp_string fmt v.generated_when;
    Pbrt.Pp.pp_record_field ~first:false "keys" (Pbrt.Pp.pp_list pp_node) fmt v.keys;
    Pbrt.Pp.pp_record_field ~first:false "including" (Pbrt.Pp.pp_list pp_node) fmt v.including;
    Pbrt.Pp.pp_record_field ~first:false "exclusions" (Pbrt.Pp.pp_list pp_node) fmt v.exclusions;
    Pbrt.Pp.pp_record_field ~first:false "options" (Pbrt.Pp.pp_list pp_node) fmt v.options;
    Pbrt.Pp.pp_record_field ~first:false "indexname" Pbrt.Pp.pp_string fmt v.indexname;
    Pbrt.Pp.pp_record_field ~first:false "indexspace" Pbrt.Pp.pp_string fmt v.indexspace;
    Pbrt.Pp.pp_record_field ~first:false "reset_default_tblspc" Pbrt.Pp.pp_bool fmt v.reset_default_tblspc;
    Pbrt.Pp.pp_record_field ~first:false "access_method" Pbrt.Pp.pp_string fmt v.access_method;
    Pbrt.Pp.pp_record_field ~first:false "where_clause" (Pbrt.Pp.pp_option pp_node) fmt v.where_clause;
    Pbrt.Pp.pp_record_field ~first:false "pktable" (Pbrt.Pp.pp_option pp_range_var) fmt v.pktable;
    Pbrt.Pp.pp_record_field ~first:false "fk_attrs" (Pbrt.Pp.pp_list pp_node) fmt v.fk_attrs;
    Pbrt.Pp.pp_record_field ~first:false "pk_attrs" (Pbrt.Pp.pp_list pp_node) fmt v.pk_attrs;
    Pbrt.Pp.pp_record_field ~first:false "fk_matchtype" Pbrt.Pp.pp_string fmt v.fk_matchtype;
    Pbrt.Pp.pp_record_field ~first:false "fk_upd_action" Pbrt.Pp.pp_string fmt v.fk_upd_action;
    Pbrt.Pp.pp_record_field ~first:false "fk_del_action" Pbrt.Pp.pp_string fmt v.fk_del_action;
    Pbrt.Pp.pp_record_field ~first:false "old_conpfeqop" (Pbrt.Pp.pp_list pp_node) fmt v.old_conpfeqop;
    Pbrt.Pp.pp_record_field ~first:false "old_pktable_oid" Pbrt.Pp.pp_int32 fmt v.old_pktable_oid;
    Pbrt.Pp.pp_record_field ~first:false "skip_validation" Pbrt.Pp.pp_bool fmt v.skip_validation;
    Pbrt.Pp.pp_record_field ~first:false "initially_valid" Pbrt.Pp.pp_bool fmt v.initially_valid;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_def_elem fmt (v:def_elem) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "defnamespace" Pbrt.Pp.pp_string fmt v.defnamespace;
    Pbrt.Pp.pp_record_field ~first:false "defname" Pbrt.Pp.pp_string fmt v.defname;
    Pbrt.Pp.pp_record_field ~first:false "arg" (Pbrt.Pp.pp_option pp_node) fmt v.arg;
    Pbrt.Pp.pp_record_field ~first:false "defaction" pp_def_elem_action fmt v.defaction;
    Pbrt.Pp.pp_record_field ~first:false "location" Pbrt.Pp.pp_int32 fmt v.location;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_range_tbl_entry fmt (v:range_tbl_entry) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "rtekind" pp_rtekind fmt v.rtekind;
    Pbrt.Pp.pp_record_field ~first:false "relid" Pbrt.Pp.pp_int32 fmt v.relid;
    Pbrt.Pp.pp_record_field ~first:false "relkind" Pbrt.Pp.pp_string fmt v.relkind;
    Pbrt.Pp.pp_record_field ~first:false "rellockmode" Pbrt.Pp.pp_int32 fmt v.rellockmode;
    Pbrt.Pp.pp_record_field ~first:false "tablesample" (Pbrt.Pp.pp_option pp_table_sample_clause) fmt v.tablesample;
    Pbrt.Pp.pp_record_field ~first:false "subquery" (Pbrt.Pp.pp_option pp_query) fmt v.subquery;
    Pbrt.Pp.pp_record_field ~first:false "security_barrier" Pbrt.Pp.pp_bool fmt v.security_barrier;
    Pbrt.Pp.pp_record_field ~first:false "jointype" pp_join_type fmt v.jointype;
    Pbrt.Pp.pp_record_field ~first:false "joinmergedcols" Pbrt.Pp.pp_int32 fmt v.joinmergedcols;
    Pbrt.Pp.pp_record_field ~first:false "joinaliasvars" (Pbrt.Pp.pp_list pp_node) fmt v.joinaliasvars;
    Pbrt.Pp.pp_record_field ~first:false "joinleftcols" (Pbrt.Pp.pp_list pp_node) fmt v.joinleftcols;
    Pbrt.Pp.pp_record_field ~first:false "joinrightcols" (Pbrt.Pp.pp_list pp_node) fmt v.joinrightcols;
    Pbrt.Pp.pp_record_field ~first:false "functions" (Pbrt.Pp.pp_list pp_node) fmt v.functions;
    Pbrt.Pp.pp_record_field ~first:false "funcordinality" Pbrt.Pp.pp_bool fmt v.funcordinality;
    Pbrt.Pp.pp_record_field ~first:false "tablefunc" (Pbrt.Pp.pp_option pp_table_func) fmt v.tablefunc;
    Pbrt.Pp.pp_record_field ~first:false "values_lists" (Pbrt.Pp.pp_list pp_node) fmt v.values_lists;
    Pbrt.Pp.pp_record_field ~first:false "ctename" Pbrt.Pp.pp_string fmt v.ctename;
    Pbrt.Pp.pp_record_field ~first:false "ctelevelsup" Pbrt.Pp.pp_int32 fmt v.ctelevelsup;
    Pbrt.Pp.pp_record_field ~first:false "self_reference" Pbrt.Pp.pp_bool fmt v.self_reference;
    Pbrt.Pp.pp_record_field ~first:false "coltypes" (Pbrt.Pp.pp_list pp_node) fmt v.coltypes;
    Pbrt.Pp.pp_record_field ~first:false "coltypmods" (Pbrt.Pp.pp_list pp_node) fmt v.coltypmods;
    Pbrt.Pp.pp_record_field ~first:false "colcollations" (Pbrt.Pp.pp_list pp_node) fmt v.colcollations;
    Pbrt.Pp.pp_record_field ~first:false "enrname" Pbrt.Pp.pp_string fmt v.enrname;
    Pbrt.Pp.pp_record_field ~first:false "enrtuples" Pbrt.Pp.pp_float fmt v.enrtuples;
    Pbrt.Pp.pp_record_field ~first:false "alias" (Pbrt.Pp.pp_option pp_alias) fmt v.alias;
    Pbrt.Pp.pp_record_field ~first:false "eref" (Pbrt.Pp.pp_option pp_alias) fmt v.eref;
    Pbrt.Pp.pp_record_field ~first:false "lateral" Pbrt.Pp.pp_bool fmt v.lateral;
    Pbrt.Pp.pp_record_field ~first:false "inh" Pbrt.Pp.pp_bool fmt v.inh;
    Pbrt.Pp.pp_record_field ~first:false "in_from_cl" Pbrt.Pp.pp_bool fmt v.in_from_cl;
    Pbrt.Pp.pp_record_field ~first:false "required_perms" Pbrt.Pp.pp_int32 fmt v.required_perms;
    Pbrt.Pp.pp_record_field ~first:false "check_as_user" Pbrt.Pp.pp_int32 fmt v.check_as_user;
    Pbrt.Pp.pp_record_field ~first:false "selected_cols" (Pbrt.Pp.pp_list Pbrt.Pp.pp_int64) fmt v.selected_cols;
    Pbrt.Pp.pp_record_field ~first:false "inserted_cols" (Pbrt.Pp.pp_list Pbrt.Pp.pp_int64) fmt v.inserted_cols;
    Pbrt.Pp.pp_record_field ~first:false "updated_cols" (Pbrt.Pp.pp_list Pbrt.Pp.pp_int64) fmt v.updated_cols;
    Pbrt.Pp.pp_record_field ~first:false "extra_updated_cols" (Pbrt.Pp.pp_list Pbrt.Pp.pp_int64) fmt v.extra_updated_cols;
    Pbrt.Pp.pp_record_field ~first:false "security_quals" (Pbrt.Pp.pp_list pp_node) fmt v.security_quals;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_table_sample_clause fmt (v:table_sample_clause) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "tsmhandler" Pbrt.Pp.pp_int32 fmt v.tsmhandler;
    Pbrt.Pp.pp_record_field ~first:false "args" (Pbrt.Pp.pp_list pp_node) fmt v.args;
    Pbrt.Pp.pp_record_field ~first:false "repeatable" (Pbrt.Pp.pp_option pp_node) fmt v.repeatable;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_range_tbl_function fmt (v:range_tbl_function) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "funcexpr" (Pbrt.Pp.pp_option pp_node) fmt v.funcexpr;
    Pbrt.Pp.pp_record_field ~first:false "funccolcount" Pbrt.Pp.pp_int32 fmt v.funccolcount;
    Pbrt.Pp.pp_record_field ~first:false "funccolnames" (Pbrt.Pp.pp_list pp_node) fmt v.funccolnames;
    Pbrt.Pp.pp_record_field ~first:false "funccoltypes" (Pbrt.Pp.pp_list pp_node) fmt v.funccoltypes;
    Pbrt.Pp.pp_record_field ~first:false "funccoltypmods" (Pbrt.Pp.pp_list pp_node) fmt v.funccoltypmods;
    Pbrt.Pp.pp_record_field ~first:false "funccolcollations" (Pbrt.Pp.pp_list pp_node) fmt v.funccolcollations;
    Pbrt.Pp.pp_record_field ~first:false "funcparams" (Pbrt.Pp.pp_list Pbrt.Pp.pp_int64) fmt v.funcparams;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_with_check_option fmt (v:with_check_option) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "kind" pp_wcokind fmt v.kind;
    Pbrt.Pp.pp_record_field ~first:false "relname" Pbrt.Pp.pp_string fmt v.relname;
    Pbrt.Pp.pp_record_field ~first:false "polname" Pbrt.Pp.pp_string fmt v.polname;
    Pbrt.Pp.pp_record_field ~first:false "qual" (Pbrt.Pp.pp_option pp_node) fmt v.qual;
    Pbrt.Pp.pp_record_field ~first:false "cascaded" Pbrt.Pp.pp_bool fmt v.cascaded;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_grouping_set fmt (v:grouping_set) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "kind" pp_grouping_set_kind fmt v.kind;
    Pbrt.Pp.pp_record_field ~first:false "content" (Pbrt.Pp.pp_list pp_node) fmt v.content;
    Pbrt.Pp.pp_record_field ~first:false "location" Pbrt.Pp.pp_int32 fmt v.location;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_window_clause fmt (v:window_clause) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "name" Pbrt.Pp.pp_string fmt v.name;
    Pbrt.Pp.pp_record_field ~first:false "refname" Pbrt.Pp.pp_string fmt v.refname;
    Pbrt.Pp.pp_record_field ~first:false "partition_clause" (Pbrt.Pp.pp_list pp_node) fmt v.partition_clause;
    Pbrt.Pp.pp_record_field ~first:false "order_clause" (Pbrt.Pp.pp_list pp_node) fmt v.order_clause;
    Pbrt.Pp.pp_record_field ~first:false "frame_options" Pbrt.Pp.pp_int32 fmt v.frame_options;
    Pbrt.Pp.pp_record_field ~first:false "start_offset" (Pbrt.Pp.pp_option pp_node) fmt v.start_offset;
    Pbrt.Pp.pp_record_field ~first:false "end_offset" (Pbrt.Pp.pp_option pp_node) fmt v.end_offset;
    Pbrt.Pp.pp_record_field ~first:false "start_in_range_func" Pbrt.Pp.pp_int32 fmt v.start_in_range_func;
    Pbrt.Pp.pp_record_field ~first:false "end_in_range_func" Pbrt.Pp.pp_int32 fmt v.end_in_range_func;
    Pbrt.Pp.pp_record_field ~first:false "in_range_coll" Pbrt.Pp.pp_int32 fmt v.in_range_coll;
    Pbrt.Pp.pp_record_field ~first:false "in_range_asc" Pbrt.Pp.pp_bool fmt v.in_range_asc;
    Pbrt.Pp.pp_record_field ~first:false "in_range_nulls_first" Pbrt.Pp.pp_bool fmt v.in_range_nulls_first;
    Pbrt.Pp.pp_record_field ~first:false "winref" Pbrt.Pp.pp_int32 fmt v.winref;
    Pbrt.Pp.pp_record_field ~first:false "copied_order" Pbrt.Pp.pp_bool fmt v.copied_order;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_access_priv fmt (v:access_priv) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "priv_name" Pbrt.Pp.pp_string fmt v.priv_name;
    Pbrt.Pp.pp_record_field ~first:false "cols" (Pbrt.Pp.pp_list pp_node) fmt v.cols;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_create_op_class_item fmt (v:create_op_class_item) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "itemtype" Pbrt.Pp.pp_int32 fmt v.itemtype;
    Pbrt.Pp.pp_record_field ~first:false "name" (Pbrt.Pp.pp_option pp_object_with_args) fmt v.name;
    Pbrt.Pp.pp_record_field ~first:false "number" Pbrt.Pp.pp_int32 fmt v.number;
    Pbrt.Pp.pp_record_field ~first:false "order_family" (Pbrt.Pp.pp_list pp_node) fmt v.order_family;
    Pbrt.Pp.pp_record_field ~first:false "class_args" (Pbrt.Pp.pp_list pp_node) fmt v.class_args;
    Pbrt.Pp.pp_record_field ~first:false "storedtype" (Pbrt.Pp.pp_option pp_type_name) fmt v.storedtype;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_table_like_clause fmt (v:table_like_clause) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "relation" (Pbrt.Pp.pp_option pp_range_var) fmt v.relation;
    Pbrt.Pp.pp_record_field ~first:false "options" Pbrt.Pp.pp_int32 fmt v.options;
    Pbrt.Pp.pp_record_field ~first:false "relation_oid" Pbrt.Pp.pp_int32 fmt v.relation_oid;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_function_parameter fmt (v:function_parameter) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "name" Pbrt.Pp.pp_string fmt v.name;
    Pbrt.Pp.pp_record_field ~first:false "arg_type" (Pbrt.Pp.pp_option pp_type_name) fmt v.arg_type;
    Pbrt.Pp.pp_record_field ~first:false "mode" pp_function_parameter_mode fmt v.mode;
    Pbrt.Pp.pp_record_field ~first:false "defexpr" (Pbrt.Pp.pp_option pp_node) fmt v.defexpr;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_locking_clause fmt (v:locking_clause) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "locked_rels" (Pbrt.Pp.pp_list pp_node) fmt v.locked_rels;
    Pbrt.Pp.pp_record_field ~first:false "strength" pp_lock_clause_strength fmt v.strength;
    Pbrt.Pp.pp_record_field ~first:false "wait_policy" pp_lock_wait_policy fmt v.wait_policy;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_xml_serialize fmt (v:xml_serialize) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "xmloption" pp_xml_option_type fmt v.xmloption;
    Pbrt.Pp.pp_record_field ~first:false "expr" (Pbrt.Pp.pp_option pp_node) fmt v.expr;
    Pbrt.Pp.pp_record_field ~first:false "type_name" (Pbrt.Pp.pp_option pp_type_name) fmt v.type_name;
    Pbrt.Pp.pp_record_field ~first:false "location" Pbrt.Pp.pp_int32 fmt v.location;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_common_table_expr fmt (v:common_table_expr) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "ctename" Pbrt.Pp.pp_string fmt v.ctename;
    Pbrt.Pp.pp_record_field ~first:false "aliascolnames" (Pbrt.Pp.pp_list pp_node) fmt v.aliascolnames;
    Pbrt.Pp.pp_record_field ~first:false "ctematerialized" pp_ctematerialize fmt v.ctematerialized;
    Pbrt.Pp.pp_record_field ~first:false "ctequery" (Pbrt.Pp.pp_option pp_node) fmt v.ctequery;
    Pbrt.Pp.pp_record_field ~first:false "location" Pbrt.Pp.pp_int32 fmt v.location;
    Pbrt.Pp.pp_record_field ~first:false "cterecursive" Pbrt.Pp.pp_bool fmt v.cterecursive;
    Pbrt.Pp.pp_record_field ~first:false "cterefcount" Pbrt.Pp.pp_int32 fmt v.cterefcount;
    Pbrt.Pp.pp_record_field ~first:false "ctecolnames" (Pbrt.Pp.pp_list pp_node) fmt v.ctecolnames;
    Pbrt.Pp.pp_record_field ~first:false "ctecoltypes" (Pbrt.Pp.pp_list pp_node) fmt v.ctecoltypes;
    Pbrt.Pp.pp_record_field ~first:false "ctecoltypmods" (Pbrt.Pp.pp_list pp_node) fmt v.ctecoltypmods;
    Pbrt.Pp.pp_record_field ~first:false "ctecolcollations" (Pbrt.Pp.pp_list pp_node) fmt v.ctecolcollations;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_partition_elem fmt (v:partition_elem) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "name" Pbrt.Pp.pp_string fmt v.name;
    Pbrt.Pp.pp_record_field ~first:false "expr" (Pbrt.Pp.pp_option pp_node) fmt v.expr;
    Pbrt.Pp.pp_record_field ~first:false "collation" (Pbrt.Pp.pp_list pp_node) fmt v.collation;
    Pbrt.Pp.pp_record_field ~first:false "opclass" (Pbrt.Pp.pp_list pp_node) fmt v.opclass;
    Pbrt.Pp.pp_record_field ~first:false "location" Pbrt.Pp.pp_int32 fmt v.location;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_partition_range_datum fmt (v:partition_range_datum) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "kind" pp_partition_range_datum_kind fmt v.kind;
    Pbrt.Pp.pp_record_field ~first:false "value" (Pbrt.Pp.pp_option pp_node) fmt v.value;
    Pbrt.Pp.pp_record_field ~first:false "location" Pbrt.Pp.pp_int32 fmt v.location;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_partition_cmd fmt (v:partition_cmd) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "name" (Pbrt.Pp.pp_option pp_range_var) fmt v.name;
    Pbrt.Pp.pp_record_field ~first:false "bound" (Pbrt.Pp.pp_option pp_partition_bound_spec) fmt v.bound;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_vacuum_relation fmt (v:vacuum_relation) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "relation" (Pbrt.Pp.pp_option pp_range_var) fmt v.relation;
    Pbrt.Pp.pp_record_field ~first:false "oid" Pbrt.Pp.pp_int32 fmt v.oid;
    Pbrt.Pp.pp_record_field ~first:false "va_cols" (Pbrt.Pp.pp_list pp_node) fmt v.va_cols;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_pglist fmt (v:pglist) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "items" (Pbrt.Pp.pp_list pp_node) fmt v.items;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_int_list fmt (v:int_list) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "items" (Pbrt.Pp.pp_list pp_node) fmt v.items;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

and pp_oid_list fmt (v:oid_list) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "items" (Pbrt.Pp.pp_list pp_node) fmt v.items;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

let rec pp_parse_result fmt (v:parse_result) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "version" Pbrt.Pp.pp_int32 fmt v.version;
    Pbrt.Pp.pp_record_field ~first:false "stmts" (Pbrt.Pp.pp_list pp_raw_stmt) fmt v.stmts;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

let rec pp_token fmt (v:token) =
  match v with
  | Nul -> Format.fprintf fmt "Nul"
  | Ascii_37 -> Format.fprintf fmt "Ascii_37"
  | Ascii_40 -> Format.fprintf fmt "Ascii_40"
  | Ascii_41 -> Format.fprintf fmt "Ascii_41"
  | Ascii_42 -> Format.fprintf fmt "Ascii_42"
  | Ascii_43 -> Format.fprintf fmt "Ascii_43"
  | Ascii_44 -> Format.fprintf fmt "Ascii_44"
  | Ascii_45 -> Format.fprintf fmt "Ascii_45"
  | Ascii_46 -> Format.fprintf fmt "Ascii_46"
  | Ascii_47 -> Format.fprintf fmt "Ascii_47"
  | Ascii_58 -> Format.fprintf fmt "Ascii_58"
  | Ascii_59 -> Format.fprintf fmt "Ascii_59"
  | Ascii_60 -> Format.fprintf fmt "Ascii_60"
  | Ascii_61 -> Format.fprintf fmt "Ascii_61"
  | Ascii_62 -> Format.fprintf fmt "Ascii_62"
  | Ascii_63 -> Format.fprintf fmt "Ascii_63"
  | Ascii_91 -> Format.fprintf fmt "Ascii_91"
  | Ascii_92 -> Format.fprintf fmt "Ascii_92"
  | Ascii_93 -> Format.fprintf fmt "Ascii_93"
  | Ascii_94 -> Format.fprintf fmt "Ascii_94"
  | Ident -> Format.fprintf fmt "Ident"
  | Uident -> Format.fprintf fmt "Uident"
  | Fconst -> Format.fprintf fmt "Fconst"
  | Sconst -> Format.fprintf fmt "Sconst"
  | Usconst -> Format.fprintf fmt "Usconst"
  | Bconst -> Format.fprintf fmt "Bconst"
  | Xconst -> Format.fprintf fmt "Xconst"
  | Op -> Format.fprintf fmt "Op"
  | Iconst -> Format.fprintf fmt "Iconst"
  | Param -> Format.fprintf fmt "Param"
  | Typecast -> Format.fprintf fmt "Typecast"
  | Dot_dot -> Format.fprintf fmt "Dot_dot"
  | Colon_equals -> Format.fprintf fmt "Colon_equals"
  | Equals_greater -> Format.fprintf fmt "Equals_greater"
  | Less_equals -> Format.fprintf fmt "Less_equals"
  | Greater_equals -> Format.fprintf fmt "Greater_equals"
  | Not_equals -> Format.fprintf fmt "Not_equals"
  | Sql_comment -> Format.fprintf fmt "Sql_comment"
  | C_comment -> Format.fprintf fmt "C_comment"
  | Abort_p -> Format.fprintf fmt "Abort_p"
  | Absolute_p -> Format.fprintf fmt "Absolute_p"
  | Access -> Format.fprintf fmt "Access"
  | Action -> Format.fprintf fmt "Action"
  | Add_p -> Format.fprintf fmt "Add_p"
  | Admin -> Format.fprintf fmt "Admin"
  | After -> Format.fprintf fmt "After"
  | Aggregate -> Format.fprintf fmt "Aggregate"
  | All -> Format.fprintf fmt "All"
  | Also -> Format.fprintf fmt "Also"
  | Alter -> Format.fprintf fmt "Alter"
  | Always -> Format.fprintf fmt "Always"
  | Analyse -> Format.fprintf fmt "Analyse"
  | Analyze -> Format.fprintf fmt "Analyze"
  | And -> Format.fprintf fmt "And"
  | Any -> Format.fprintf fmt "Any"
  | Array -> Format.fprintf fmt "Array"
  | As -> Format.fprintf fmt "As"
  | Asc -> Format.fprintf fmt "Asc"
  | Assertion -> Format.fprintf fmt "Assertion"
  | Assignment -> Format.fprintf fmt "Assignment"
  | Asymmetric -> Format.fprintf fmt "Asymmetric"
  | At -> Format.fprintf fmt "At"
  | Attach -> Format.fprintf fmt "Attach"
  | Attribute -> Format.fprintf fmt "Attribute"
  | Authorization -> Format.fprintf fmt "Authorization"
  | Backward -> Format.fprintf fmt "Backward"
  | Before -> Format.fprintf fmt "Before"
  | Begin_p -> Format.fprintf fmt "Begin_p"
  | Between -> Format.fprintf fmt "Between"
  | Bigint -> Format.fprintf fmt "Bigint"
  | Binary -> Format.fprintf fmt "Binary"
  | Bit -> Format.fprintf fmt "Bit"
  | Boolean_p -> Format.fprintf fmt "Boolean_p"
  | Both -> Format.fprintf fmt "Both"
  | By -> Format.fprintf fmt "By"
  | Cache -> Format.fprintf fmt "Cache"
  | Call -> Format.fprintf fmt "Call"
  | Called -> Format.fprintf fmt "Called"
  | Cascade -> Format.fprintf fmt "Cascade"
  | Cascaded -> Format.fprintf fmt "Cascaded"
  | Case -> Format.fprintf fmt "Case"
  | Cast -> Format.fprintf fmt "Cast"
  | Catalog_p -> Format.fprintf fmt "Catalog_p"
  | Chain -> Format.fprintf fmt "Chain"
  | Char_p -> Format.fprintf fmt "Char_p"
  | Character -> Format.fprintf fmt "Character"
  | Characteristics -> Format.fprintf fmt "Characteristics"
  | Check -> Format.fprintf fmt "Check"
  | Checkpoint -> Format.fprintf fmt "Checkpoint"
  | Class -> Format.fprintf fmt "Class"
  | Close -> Format.fprintf fmt "Close"
  | Cluster -> Format.fprintf fmt "Cluster"
  | Coalesce -> Format.fprintf fmt "Coalesce"
  | Collate -> Format.fprintf fmt "Collate"
  | Collation -> Format.fprintf fmt "Collation"
  | Column -> Format.fprintf fmt "Column"
  | Columns -> Format.fprintf fmt "Columns"
  | Comment -> Format.fprintf fmt "Comment"
  | Comments -> Format.fprintf fmt "Comments"
  | Commit -> Format.fprintf fmt "Commit"
  | Committed -> Format.fprintf fmt "Committed"
  | Concurrently -> Format.fprintf fmt "Concurrently"
  | Configuration -> Format.fprintf fmt "Configuration"
  | Conflict -> Format.fprintf fmt "Conflict"
  | Connection -> Format.fprintf fmt "Connection"
  | Constraint -> Format.fprintf fmt "Constraint"
  | Constraints -> Format.fprintf fmt "Constraints"
  | Content_p -> Format.fprintf fmt "Content_p"
  | Continue_p -> Format.fprintf fmt "Continue_p"
  | Conversion_p -> Format.fprintf fmt "Conversion_p"
  | Copy -> Format.fprintf fmt "Copy"
  | Cost -> Format.fprintf fmt "Cost"
  | Create -> Format.fprintf fmt "Create"
  | Cross -> Format.fprintf fmt "Cross"
  | Csv -> Format.fprintf fmt "Csv"
  | Cube -> Format.fprintf fmt "Cube"
  | Current_p -> Format.fprintf fmt "Current_p"
  | Current_catalog -> Format.fprintf fmt "Current_catalog"
  | Current_date -> Format.fprintf fmt "Current_date"
  | Current_role -> Format.fprintf fmt "Current_role"
  | Current_schema -> Format.fprintf fmt "Current_schema"
  | Current_time -> Format.fprintf fmt "Current_time"
  | Current_timestamp -> Format.fprintf fmt "Current_timestamp"
  | Current_user -> Format.fprintf fmt "Current_user"
  | Cursor -> Format.fprintf fmt "Cursor"
  | Cycle -> Format.fprintf fmt "Cycle"
  | Data_p -> Format.fprintf fmt "Data_p"
  | Database -> Format.fprintf fmt "Database"
  | Day_p -> Format.fprintf fmt "Day_p"
  | Deallocate -> Format.fprintf fmt "Deallocate"
  | Dec -> Format.fprintf fmt "Dec"
  | Decimal_p -> Format.fprintf fmt "Decimal_p"
  | Declare -> Format.fprintf fmt "Declare"
  | Default -> Format.fprintf fmt "Default"
  | Defaults -> Format.fprintf fmt "Defaults"
  | Deferrable -> Format.fprintf fmt "Deferrable"
  | Deferred -> Format.fprintf fmt "Deferred"
  | Definer -> Format.fprintf fmt "Definer"
  | Delete_p -> Format.fprintf fmt "Delete_p"
  | Delimiter -> Format.fprintf fmt "Delimiter"
  | Delimiters -> Format.fprintf fmt "Delimiters"
  | Depends -> Format.fprintf fmt "Depends"
  | Desc -> Format.fprintf fmt "Desc"
  | Detach -> Format.fprintf fmt "Detach"
  | Dictionary -> Format.fprintf fmt "Dictionary"
  | Disable_p -> Format.fprintf fmt "Disable_p"
  | Discard -> Format.fprintf fmt "Discard"
  | Distinct -> Format.fprintf fmt "Distinct"
  | Do -> Format.fprintf fmt "Do"
  | Document_p -> Format.fprintf fmt "Document_p"
  | Domain_p -> Format.fprintf fmt "Domain_p"
  | Double_p -> Format.fprintf fmt "Double_p"
  | Drop -> Format.fprintf fmt "Drop"
  | Each -> Format.fprintf fmt "Each"
  | Else -> Format.fprintf fmt "Else"
  | Enable_p -> Format.fprintf fmt "Enable_p"
  | Encoding -> Format.fprintf fmt "Encoding"
  | Encrypted -> Format.fprintf fmt "Encrypted"
  | End_p -> Format.fprintf fmt "End_p"
  | Enum_p -> Format.fprintf fmt "Enum_p"
  | Escape -> Format.fprintf fmt "Escape"
  | Event -> Format.fprintf fmt "Event"
  | Except -> Format.fprintf fmt "Except"
  | Exclude -> Format.fprintf fmt "Exclude"
  | Excluding -> Format.fprintf fmt "Excluding"
  | Exclusive -> Format.fprintf fmt "Exclusive"
  | Execute -> Format.fprintf fmt "Execute"
  | Exists -> Format.fprintf fmt "Exists"
  | Explain -> Format.fprintf fmt "Explain"
  | Expression -> Format.fprintf fmt "Expression"
  | Extension -> Format.fprintf fmt "Extension"
  | External -> Format.fprintf fmt "External"
  | Extract -> Format.fprintf fmt "Extract"
  | False_p -> Format.fprintf fmt "False_p"
  | Family -> Format.fprintf fmt "Family"
  | Fetch -> Format.fprintf fmt "Fetch"
  | Filter -> Format.fprintf fmt "Filter"
  | First_p -> Format.fprintf fmt "First_p"
  | Float_p -> Format.fprintf fmt "Float_p"
  | Following -> Format.fprintf fmt "Following"
  | For -> Format.fprintf fmt "For"
  | Force -> Format.fprintf fmt "Force"
  | Foreign -> Format.fprintf fmt "Foreign"
  | Forward -> Format.fprintf fmt "Forward"
  | Freeze -> Format.fprintf fmt "Freeze"
  | From -> Format.fprintf fmt "From"
  | Full -> Format.fprintf fmt "Full"
  | Function -> Format.fprintf fmt "Function"
  | Functions -> Format.fprintf fmt "Functions"
  | Generated -> Format.fprintf fmt "Generated"
  | Global -> Format.fprintf fmt "Global"
  | Grant -> Format.fprintf fmt "Grant"
  | Granted -> Format.fprintf fmt "Granted"
  | Greatest -> Format.fprintf fmt "Greatest"
  | Group_p -> Format.fprintf fmt "Group_p"
  | Grouping -> Format.fprintf fmt "Grouping"
  | Groups -> Format.fprintf fmt "Groups"
  | Handler -> Format.fprintf fmt "Handler"
  | Having -> Format.fprintf fmt "Having"
  | Header_p -> Format.fprintf fmt "Header_p"
  | Hold -> Format.fprintf fmt "Hold"
  | Hour_p -> Format.fprintf fmt "Hour_p"
  | Identity_p -> Format.fprintf fmt "Identity_p"
  | If_p -> Format.fprintf fmt "If_p"
  | Ilike -> Format.fprintf fmt "Ilike"
  | Immediate -> Format.fprintf fmt "Immediate"
  | Immutable -> Format.fprintf fmt "Immutable"
  | Implicit_p -> Format.fprintf fmt "Implicit_p"
  | Import_p -> Format.fprintf fmt "Import_p"
  | In_p -> Format.fprintf fmt "In_p"
  | Include -> Format.fprintf fmt "Include"
  | Including -> Format.fprintf fmt "Including"
  | Increment -> Format.fprintf fmt "Increment"
  | Index -> Format.fprintf fmt "Index"
  | Indexes -> Format.fprintf fmt "Indexes"
  | Inherit -> Format.fprintf fmt "Inherit"
  | Inherits -> Format.fprintf fmt "Inherits"
  | Initially -> Format.fprintf fmt "Initially"
  | Inline_p -> Format.fprintf fmt "Inline_p"
  | Inner_p -> Format.fprintf fmt "Inner_p"
  | Inout -> Format.fprintf fmt "Inout"
  | Input_p -> Format.fprintf fmt "Input_p"
  | Insensitive -> Format.fprintf fmt "Insensitive"
  | Insert -> Format.fprintf fmt "Insert"
  | Instead -> Format.fprintf fmt "Instead"
  | Int_p -> Format.fprintf fmt "Int_p"
  | Integer -> Format.fprintf fmt "Integer"
  | Intersect -> Format.fprintf fmt "Intersect"
  | Interval -> Format.fprintf fmt "Interval"
  | Into -> Format.fprintf fmt "Into"
  | Invoker -> Format.fprintf fmt "Invoker"
  | Is -> Format.fprintf fmt "Is"
  | Isnull -> Format.fprintf fmt "Isnull"
  | Isolation -> Format.fprintf fmt "Isolation"
  | Join -> Format.fprintf fmt "Join"
  | Key -> Format.fprintf fmt "Key"
  | Label -> Format.fprintf fmt "Label"
  | Language -> Format.fprintf fmt "Language"
  | Large_p -> Format.fprintf fmt "Large_p"
  | Last_p -> Format.fprintf fmt "Last_p"
  | Lateral_p -> Format.fprintf fmt "Lateral_p"
  | Leading -> Format.fprintf fmt "Leading"
  | Leakproof -> Format.fprintf fmt "Leakproof"
  | Least -> Format.fprintf fmt "Least"
  | Left -> Format.fprintf fmt "Left"
  | Level -> Format.fprintf fmt "Level"
  | Like -> Format.fprintf fmt "Like"
  | Limit -> Format.fprintf fmt "Limit"
  | Listen -> Format.fprintf fmt "Listen"
  | Load -> Format.fprintf fmt "Load"
  | Local -> Format.fprintf fmt "Local"
  | Localtime -> Format.fprintf fmt "Localtime"
  | Localtimestamp -> Format.fprintf fmt "Localtimestamp"
  | Location -> Format.fprintf fmt "Location"
  | Lock_p -> Format.fprintf fmt "Lock_p"
  | Locked -> Format.fprintf fmt "Locked"
  | Logged -> Format.fprintf fmt "Logged"
  | Mapping -> Format.fprintf fmt "Mapping"
  | Match -> Format.fprintf fmt "Match"
  | Materialized -> Format.fprintf fmt "Materialized"
  | Maxvalue -> Format.fprintf fmt "Maxvalue"
  | Method -> Format.fprintf fmt "Method"
  | Minute_p -> Format.fprintf fmt "Minute_p"
  | Minvalue -> Format.fprintf fmt "Minvalue"
  | Mode -> Format.fprintf fmt "Mode"
  | Month_p -> Format.fprintf fmt "Month_p"
  | Move -> Format.fprintf fmt "Move"
  | Name_p -> Format.fprintf fmt "Name_p"
  | Names -> Format.fprintf fmt "Names"
  | National -> Format.fprintf fmt "National"
  | Natural -> Format.fprintf fmt "Natural"
  | Nchar -> Format.fprintf fmt "Nchar"
  | New -> Format.fprintf fmt "New"
  | Next -> Format.fprintf fmt "Next"
  | Nfc -> Format.fprintf fmt "Nfc"
  | Nfd -> Format.fprintf fmt "Nfd"
  | Nfkc -> Format.fprintf fmt "Nfkc"
  | Nfkd -> Format.fprintf fmt "Nfkd"
  | No -> Format.fprintf fmt "No"
  | None -> Format.fprintf fmt "None"
  | Normalize -> Format.fprintf fmt "Normalize"
  | Normalized -> Format.fprintf fmt "Normalized"
  | Not -> Format.fprintf fmt "Not"
  | Nothing -> Format.fprintf fmt "Nothing"
  | Notify -> Format.fprintf fmt "Notify"
  | Notnull -> Format.fprintf fmt "Notnull"
  | Nowait -> Format.fprintf fmt "Nowait"
  | Null_p -> Format.fprintf fmt "Null_p"
  | Nullif -> Format.fprintf fmt "Nullif"
  | Nulls_p -> Format.fprintf fmt "Nulls_p"
  | Numeric -> Format.fprintf fmt "Numeric"
  | Object_p -> Format.fprintf fmt "Object_p"
  | Of -> Format.fprintf fmt "Of"
  | Off -> Format.fprintf fmt "Off"
  | Offset -> Format.fprintf fmt "Offset"
  | Oids -> Format.fprintf fmt "Oids"
  | Old -> Format.fprintf fmt "Old"
  | On -> Format.fprintf fmt "On"
  | Only -> Format.fprintf fmt "Only"
  | Operator -> Format.fprintf fmt "Operator"
  | Option -> Format.fprintf fmt "Option"
  | Options -> Format.fprintf fmt "Options"
  | Or -> Format.fprintf fmt "Or"
  | Order -> Format.fprintf fmt "Order"
  | Ordinality -> Format.fprintf fmt "Ordinality"
  | Others -> Format.fprintf fmt "Others"
  | Out_p -> Format.fprintf fmt "Out_p"
  | Outer_p -> Format.fprintf fmt "Outer_p"
  | Over -> Format.fprintf fmt "Over"
  | Overlaps -> Format.fprintf fmt "Overlaps"
  | Overlay -> Format.fprintf fmt "Overlay"
  | Overriding -> Format.fprintf fmt "Overriding"
  | Owned -> Format.fprintf fmt "Owned"
  | Owner -> Format.fprintf fmt "Owner"
  | Parallel -> Format.fprintf fmt "Parallel"
  | Parser -> Format.fprintf fmt "Parser"
  | Partial -> Format.fprintf fmt "Partial"
  | Partition -> Format.fprintf fmt "Partition"
  | Passing -> Format.fprintf fmt "Passing"
  | Password -> Format.fprintf fmt "Password"
  | Placing -> Format.fprintf fmt "Placing"
  | Plans -> Format.fprintf fmt "Plans"
  | Policy -> Format.fprintf fmt "Policy"
  | Position -> Format.fprintf fmt "Position"
  | Preceding -> Format.fprintf fmt "Preceding"
  | Precision -> Format.fprintf fmt "Precision"
  | Preserve -> Format.fprintf fmt "Preserve"
  | Prepare -> Format.fprintf fmt "Prepare"
  | Prepared -> Format.fprintf fmt "Prepared"
  | Primary -> Format.fprintf fmt "Primary"
  | Prior -> Format.fprintf fmt "Prior"
  | Privileges -> Format.fprintf fmt "Privileges"
  | Procedural -> Format.fprintf fmt "Procedural"
  | Procedure -> Format.fprintf fmt "Procedure"
  | Procedures -> Format.fprintf fmt "Procedures"
  | Program -> Format.fprintf fmt "Program"
  | Publication -> Format.fprintf fmt "Publication"
  | Quote -> Format.fprintf fmt "Quote"
  | Range -> Format.fprintf fmt "Range"
  | Read -> Format.fprintf fmt "Read"
  | Real -> Format.fprintf fmt "Real"
  | Reassign -> Format.fprintf fmt "Reassign"
  | Recheck -> Format.fprintf fmt "Recheck"
  | Recursive -> Format.fprintf fmt "Recursive"
  | Ref_p -> Format.fprintf fmt "Ref_p"
  | References -> Format.fprintf fmt "References"
  | Referencing -> Format.fprintf fmt "Referencing"
  | Refresh -> Format.fprintf fmt "Refresh"
  | Reindex -> Format.fprintf fmt "Reindex"
  | Relative_p -> Format.fprintf fmt "Relative_p"
  | Release -> Format.fprintf fmt "Release"
  | Rename -> Format.fprintf fmt "Rename"
  | Repeatable -> Format.fprintf fmt "Repeatable"
  | Replace -> Format.fprintf fmt "Replace"
  | Replica -> Format.fprintf fmt "Replica"
  | Reset -> Format.fprintf fmt "Reset"
  | Restart -> Format.fprintf fmt "Restart"
  | Restrict -> Format.fprintf fmt "Restrict"
  | Returning -> Format.fprintf fmt "Returning"
  | Returns -> Format.fprintf fmt "Returns"
  | Revoke -> Format.fprintf fmt "Revoke"
  | Right -> Format.fprintf fmt "Right"
  | Role -> Format.fprintf fmt "Role"
  | Rollback -> Format.fprintf fmt "Rollback"
  | Rollup -> Format.fprintf fmt "Rollup"
  | Routine -> Format.fprintf fmt "Routine"
  | Routines -> Format.fprintf fmt "Routines"
  | Row -> Format.fprintf fmt "Row"
  | Rows -> Format.fprintf fmt "Rows"
  | Rule -> Format.fprintf fmt "Rule"
  | Savepoint -> Format.fprintf fmt "Savepoint"
  | Schema -> Format.fprintf fmt "Schema"
  | Schemas -> Format.fprintf fmt "Schemas"
  | Scroll -> Format.fprintf fmt "Scroll"
  | Search -> Format.fprintf fmt "Search"
  | Second_p -> Format.fprintf fmt "Second_p"
  | Security -> Format.fprintf fmt "Security"
  | Select -> Format.fprintf fmt "Select"
  | Sequence -> Format.fprintf fmt "Sequence"
  | Sequences -> Format.fprintf fmt "Sequences"
  | Serializable -> Format.fprintf fmt "Serializable"
  | Server -> Format.fprintf fmt "Server"
  | Session -> Format.fprintf fmt "Session"
  | Session_user -> Format.fprintf fmt "Session_user"
  | Set -> Format.fprintf fmt "Set"
  | Sets -> Format.fprintf fmt "Sets"
  | Setof -> Format.fprintf fmt "Setof"
  | Share -> Format.fprintf fmt "Share"
  | Show -> Format.fprintf fmt "Show"
  | Similar -> Format.fprintf fmt "Similar"
  | Simple -> Format.fprintf fmt "Simple"
  | Skip -> Format.fprintf fmt "Skip"
  | Smallint -> Format.fprintf fmt "Smallint"
  | Snapshot -> Format.fprintf fmt "Snapshot"
  | Some -> Format.fprintf fmt "Some"
  | Sql_p -> Format.fprintf fmt "Sql_p"
  | Stable -> Format.fprintf fmt "Stable"
  | Standalone_p -> Format.fprintf fmt "Standalone_p"
  | Start -> Format.fprintf fmt "Start"
  | Statement -> Format.fprintf fmt "Statement"
  | Statistics -> Format.fprintf fmt "Statistics"
  | Stdin -> Format.fprintf fmt "Stdin"
  | Stdout -> Format.fprintf fmt "Stdout"
  | Storage -> Format.fprintf fmt "Storage"
  | Stored -> Format.fprintf fmt "Stored"
  | Strict_p -> Format.fprintf fmt "Strict_p"
  | Strip_p -> Format.fprintf fmt "Strip_p"
  | Subscription -> Format.fprintf fmt "Subscription"
  | Substring -> Format.fprintf fmt "Substring"
  | Support -> Format.fprintf fmt "Support"
  | Symmetric -> Format.fprintf fmt "Symmetric"
  | Sysid -> Format.fprintf fmt "Sysid"
  | System_p -> Format.fprintf fmt "System_p"
  | Table -> Format.fprintf fmt "Table"
  | Tables -> Format.fprintf fmt "Tables"
  | Tablesample -> Format.fprintf fmt "Tablesample"
  | Tablespace -> Format.fprintf fmt "Tablespace"
  | Temp -> Format.fprintf fmt "Temp"
  | Template -> Format.fprintf fmt "Template"
  | Temporary -> Format.fprintf fmt "Temporary"
  | Text_p -> Format.fprintf fmt "Text_p"
  | Then -> Format.fprintf fmt "Then"
  | Ties -> Format.fprintf fmt "Ties"
  | Time -> Format.fprintf fmt "Time"
  | Timestamp -> Format.fprintf fmt "Timestamp"
  | To -> Format.fprintf fmt "To"
  | Trailing -> Format.fprintf fmt "Trailing"
  | Transaction -> Format.fprintf fmt "Transaction"
  | Transform -> Format.fprintf fmt "Transform"
  | Treat -> Format.fprintf fmt "Treat"
  | Trigger -> Format.fprintf fmt "Trigger"
  | Trim -> Format.fprintf fmt "Trim"
  | True_p -> Format.fprintf fmt "True_p"
  | Truncate -> Format.fprintf fmt "Truncate"
  | Trusted -> Format.fprintf fmt "Trusted"
  | Type_p -> Format.fprintf fmt "Type_p"
  | Types_p -> Format.fprintf fmt "Types_p"
  | Uescape -> Format.fprintf fmt "Uescape"
  | Unbounded -> Format.fprintf fmt "Unbounded"
  | Uncommitted -> Format.fprintf fmt "Uncommitted"
  | Unencrypted -> Format.fprintf fmt "Unencrypted"
  | Union -> Format.fprintf fmt "Union"
  | Unique -> Format.fprintf fmt "Unique"
  | Unknown -> Format.fprintf fmt "Unknown"
  | Unlisten -> Format.fprintf fmt "Unlisten"
  | Unlogged -> Format.fprintf fmt "Unlogged"
  | Until -> Format.fprintf fmt "Until"
  | Update -> Format.fprintf fmt "Update"
  | User -> Format.fprintf fmt "User"
  | Using -> Format.fprintf fmt "Using"
  | Vacuum -> Format.fprintf fmt "Vacuum"
  | Valid -> Format.fprintf fmt "Valid"
  | Validate -> Format.fprintf fmt "Validate"
  | Validator -> Format.fprintf fmt "Validator"
  | Value_p -> Format.fprintf fmt "Value_p"
  | Values -> Format.fprintf fmt "Values"
  | Varchar -> Format.fprintf fmt "Varchar"
  | Variadic -> Format.fprintf fmt "Variadic"
  | Varying -> Format.fprintf fmt "Varying"
  | Verbose -> Format.fprintf fmt "Verbose"
  | Version_p -> Format.fprintf fmt "Version_p"
  | View -> Format.fprintf fmt "View"
  | Views -> Format.fprintf fmt "Views"
  | Volatile -> Format.fprintf fmt "Volatile"
  | When -> Format.fprintf fmt "When"
  | Where -> Format.fprintf fmt "Where"
  | Whitespace_p -> Format.fprintf fmt "Whitespace_p"
  | Window -> Format.fprintf fmt "Window"
  | With -> Format.fprintf fmt "With"
  | Within -> Format.fprintf fmt "Within"
  | Without -> Format.fprintf fmt "Without"
  | Work -> Format.fprintf fmt "Work"
  | Wrapper -> Format.fprintf fmt "Wrapper"
  | Write -> Format.fprintf fmt "Write"
  | Xml_p -> Format.fprintf fmt "Xml_p"
  | Xmlattributes -> Format.fprintf fmt "Xmlattributes"
  | Xmlconcat -> Format.fprintf fmt "Xmlconcat"
  | Xmlelement -> Format.fprintf fmt "Xmlelement"
  | Xmlexists -> Format.fprintf fmt "Xmlexists"
  | Xmlforest -> Format.fprintf fmt "Xmlforest"
  | Xmlnamespaces -> Format.fprintf fmt "Xmlnamespaces"
  | Xmlparse -> Format.fprintf fmt "Xmlparse"
  | Xmlpi -> Format.fprintf fmt "Xmlpi"
  | Xmlroot -> Format.fprintf fmt "Xmlroot"
  | Xmlserialize -> Format.fprintf fmt "Xmlserialize"
  | Xmltable -> Format.fprintf fmt "Xmltable"
  | Year_p -> Format.fprintf fmt "Year_p"
  | Yes_p -> Format.fprintf fmt "Yes_p"
  | Zone -> Format.fprintf fmt "Zone"
  | Not_la -> Format.fprintf fmt "Not_la"
  | Nulls_la -> Format.fprintf fmt "Nulls_la"
  | With_la -> Format.fprintf fmt "With_la"
  | Postfixop -> Format.fprintf fmt "Postfixop"
  | Uminus -> Format.fprintf fmt "Uminus"

let rec pp_keyword_kind fmt (v:keyword_kind) =
  match v with
  | No_keyword -> Format.fprintf fmt "No_keyword"
  | Unreserved_keyword -> Format.fprintf fmt "Unreserved_keyword"
  | Col_name_keyword -> Format.fprintf fmt "Col_name_keyword"
  | Type_func_name_keyword -> Format.fprintf fmt "Type_func_name_keyword"
  | Reserved_keyword -> Format.fprintf fmt "Reserved_keyword"

let rec pp_scan_token fmt (v:scan_token) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "start" Pbrt.Pp.pp_int32 fmt v.start;
    Pbrt.Pp.pp_record_field ~first:false "end_" Pbrt.Pp.pp_int32 fmt v.end_;
    Pbrt.Pp.pp_record_field ~first:false "token" pp_token fmt v.token;
    Pbrt.Pp.pp_record_field ~first:false "keyword_kind" pp_keyword_kind fmt v.keyword_kind;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

let rec pp_scan_result fmt (v:scan_result) = 
  let pp_i fmt () =
    Pbrt.Pp.pp_record_field ~first:true "version" Pbrt.Pp.pp_int32 fmt v.version;
    Pbrt.Pp.pp_record_field ~first:false "tokens" (Pbrt.Pp.pp_list pp_scan_token) fmt v.tokens;
  in
  Pbrt.Pp.pp_brk pp_i fmt ()

let rec pp_table_like_option fmt (v:table_like_option) =
  match v with
  | Table_like_option_undefined -> Format.fprintf fmt "Table_like_option_undefined"
  | Create_table_like_comments -> Format.fprintf fmt "Create_table_like_comments"
  | Create_table_like_constraints -> Format.fprintf fmt "Create_table_like_constraints"
  | Create_table_like_defaults -> Format.fprintf fmt "Create_table_like_defaults"
  | Create_table_like_generated -> Format.fprintf fmt "Create_table_like_generated"
  | Create_table_like_identity -> Format.fprintf fmt "Create_table_like_identity"
  | Create_table_like_indexes -> Format.fprintf fmt "Create_table_like_indexes"
  | Create_table_like_statistics -> Format.fprintf fmt "Create_table_like_statistics"
  | Create_table_like_storage -> Format.fprintf fmt "Create_table_like_storage"
  | Create_table_like_all -> Format.fprintf fmt "Create_table_like_all"

let rec pp_cluster_option fmt (v:cluster_option) =
  match v with
  | Cluster_option_undefined -> Format.fprintf fmt "Cluster_option_undefined"
  | Cluopt_recheck -> Format.fprintf fmt "Cluopt_recheck"
  | Cluopt_verbose -> Format.fprintf fmt "Cluopt_verbose"

let rec pp_agg_strategy fmt (v:agg_strategy) =
  match v with
  | Agg_strategy_undefined -> Format.fprintf fmt "Agg_strategy_undefined"
  | Agg_plain -> Format.fprintf fmt "Agg_plain"
  | Agg_sorted -> Format.fprintf fmt "Agg_sorted"
  | Agg_hashed -> Format.fprintf fmt "Agg_hashed"
  | Agg_mixed -> Format.fprintf fmt "Agg_mixed"

let rec pp_set_op_cmd fmt (v:set_op_cmd) =
  match v with
  | Set_op_cmd_undefined -> Format.fprintf fmt "Set_op_cmd_undefined"
  | Setopcmd_intersect -> Format.fprintf fmt "Setopcmd_intersect"
  | Setopcmd_intersect_all -> Format.fprintf fmt "Setopcmd_intersect_all"
  | Setopcmd_except -> Format.fprintf fmt "Setopcmd_except"
  | Setopcmd_except_all -> Format.fprintf fmt "Setopcmd_except_all"

let rec pp_set_op_strategy fmt (v:set_op_strategy) =
  match v with
  | Set_op_strategy_undefined -> Format.fprintf fmt "Set_op_strategy_undefined"
  | Setop_sorted -> Format.fprintf fmt "Setop_sorted"
  | Setop_hashed -> Format.fprintf fmt "Setop_hashed"

let rec pp_lock_tuple_mode fmt (v:lock_tuple_mode) =
  match v with
  | Lock_tuple_mode_undefined -> Format.fprintf fmt "Lock_tuple_mode_undefined"
  | Lock_tuple_key_share -> Format.fprintf fmt "Lock_tuple_key_share"
  | Lock_tuple_share -> Format.fprintf fmt "Lock_tuple_share"
  | Lock_tuple_no_key_exclusive -> Format.fprintf fmt "Lock_tuple_no_key_exclusive"
  | Lock_tuple_exclusive -> Format.fprintf fmt "Lock_tuple_exclusive"

[@@@ocaml.warning "-27-30-39"]

(** {2 Protobuf Encoding} *)

let rec encode_pb_expr (v:expr) encoder = 
()

let rec encode_pb_param_kind (v:param_kind) encoder =
  match v with
  | Param_kind_undefined -> Pbrt.Encoder.int_as_varint (0) encoder
  | Param_extern -> Pbrt.Encoder.int_as_varint 1 encoder
  | Param_exec -> Pbrt.Encoder.int_as_varint 2 encoder
  | Param_sublink -> Pbrt.Encoder.int_as_varint 3 encoder
  | Param_multiexpr -> Pbrt.Encoder.int_as_varint 4 encoder

let rec encode_pb_agg_split (v:agg_split) encoder =
  match v with
  | Agg_split_undefined -> Pbrt.Encoder.int_as_varint (0) encoder
  | Aggsplit_simple -> Pbrt.Encoder.int_as_varint 1 encoder
  | Aggsplit_initial_serial -> Pbrt.Encoder.int_as_varint 2 encoder
  | Aggsplit_final_deserial -> Pbrt.Encoder.int_as_varint 3 encoder

let rec encode_pb_coercion_form (v:coercion_form) encoder =
  match v with
  | Coercion_form_undefined -> Pbrt.Encoder.int_as_varint (0) encoder
  | Coerce_explicit_call -> Pbrt.Encoder.int_as_varint 1 encoder
  | Coerce_explicit_cast -> Pbrt.Encoder.int_as_varint 2 encoder
  | Coerce_implicit_cast -> Pbrt.Encoder.int_as_varint 3 encoder

let rec encode_pb_bool_expr_type (v:bool_expr_type) encoder =
  match v with
  | Bool_expr_type_undefined -> Pbrt.Encoder.int_as_varint (0) encoder
  | And_expr -> Pbrt.Encoder.int_as_varint 1 encoder
  | Or_expr -> Pbrt.Encoder.int_as_varint 2 encoder
  | Not_expr -> Pbrt.Encoder.int_as_varint 3 encoder

let rec encode_pb_sub_link_type (v:sub_link_type) encoder =
  match v with
  | Sub_link_type_undefined -> Pbrt.Encoder.int_as_varint (0) encoder
  | Exists_sublink -> Pbrt.Encoder.int_as_varint 1 encoder
  | All_sublink -> Pbrt.Encoder.int_as_varint 2 encoder
  | Any_sublink -> Pbrt.Encoder.int_as_varint 3 encoder
  | Rowcompare_sublink -> Pbrt.Encoder.int_as_varint 4 encoder
  | Expr_sublink -> Pbrt.Encoder.int_as_varint 5 encoder
  | Multiexpr_sublink -> Pbrt.Encoder.int_as_varint 6 encoder
  | Array_sublink -> Pbrt.Encoder.int_as_varint 7 encoder
  | Cte_sublink -> Pbrt.Encoder.int_as_varint 8 encoder

let rec encode_pb_row_compare_type (v:row_compare_type) encoder =
  match v with
  | Row_compare_type_undefined -> Pbrt.Encoder.int_as_varint (0) encoder
  | Rowcompare_lt -> Pbrt.Encoder.int_as_varint 1 encoder
  | Rowcompare_le -> Pbrt.Encoder.int_as_varint 2 encoder
  | Rowcompare_eq -> Pbrt.Encoder.int_as_varint 3 encoder
  | Rowcompare_ge -> Pbrt.Encoder.int_as_varint 4 encoder
  | Rowcompare_gt -> Pbrt.Encoder.int_as_varint 5 encoder
  | Rowcompare_ne -> Pbrt.Encoder.int_as_varint 6 encoder

let rec encode_pb_min_max_op (v:min_max_op) encoder =
  match v with
  | Min_max_op_undefined -> Pbrt.Encoder.int_as_varint (0) encoder
  | Is_greatest -> Pbrt.Encoder.int_as_varint 1 encoder
  | Is_least -> Pbrt.Encoder.int_as_varint 2 encoder

let rec encode_pb_sqlvalue_function_op (v:sqlvalue_function_op) encoder =
  match v with
  | Sqlvalue_function_op_undefined -> Pbrt.Encoder.int_as_varint (0) encoder
  | Svfop_current_date -> Pbrt.Encoder.int_as_varint 1 encoder
  | Svfop_current_time -> Pbrt.Encoder.int_as_varint 2 encoder
  | Svfop_current_time_n -> Pbrt.Encoder.int_as_varint 3 encoder
  | Svfop_current_timestamp -> Pbrt.Encoder.int_as_varint 4 encoder
  | Svfop_current_timestamp_n -> Pbrt.Encoder.int_as_varint 5 encoder
  | Svfop_localtime -> Pbrt.Encoder.int_as_varint 6 encoder
  | Svfop_localtime_n -> Pbrt.Encoder.int_as_varint 7 encoder
  | Svfop_localtimestamp -> Pbrt.Encoder.int_as_varint 8 encoder
  | Svfop_localtimestamp_n -> Pbrt.Encoder.int_as_varint 9 encoder
  | Svfop_current_role -> Pbrt.Encoder.int_as_varint 10 encoder
  | Svfop_current_user -> Pbrt.Encoder.int_as_varint 11 encoder
  | Svfop_user -> Pbrt.Encoder.int_as_varint 12 encoder
  | Svfop_session_user -> Pbrt.Encoder.int_as_varint 13 encoder
  | Svfop_current_catalog -> Pbrt.Encoder.int_as_varint 14 encoder
  | Svfop_current_schema -> Pbrt.Encoder.int_as_varint 15 encoder

let rec encode_pb_xml_expr_op (v:xml_expr_op) encoder =
  match v with
  | Xml_expr_op_undefined -> Pbrt.Encoder.int_as_varint (0) encoder
  | Is_xmlconcat -> Pbrt.Encoder.int_as_varint 1 encoder
  | Is_xmlelement -> Pbrt.Encoder.int_as_varint 2 encoder
  | Is_xmlforest -> Pbrt.Encoder.int_as_varint 3 encoder
  | Is_xmlparse -> Pbrt.Encoder.int_as_varint 4 encoder
  | Is_xmlpi -> Pbrt.Encoder.int_as_varint 5 encoder
  | Is_xmlroot -> Pbrt.Encoder.int_as_varint 6 encoder
  | Is_xmlserialize -> Pbrt.Encoder.int_as_varint 7 encoder
  | Is_document -> Pbrt.Encoder.int_as_varint 8 encoder

let rec encode_pb_xml_option_type (v:xml_option_type) encoder =
  match v with
  | Xml_option_type_undefined -> Pbrt.Encoder.int_as_varint (0) encoder
  | Xmloption_document -> Pbrt.Encoder.int_as_varint 1 encoder
  | Xmloption_content -> Pbrt.Encoder.int_as_varint 2 encoder

let rec encode_pb_null_test_type (v:null_test_type) encoder =
  match v with
  | Null_test_type_undefined -> Pbrt.Encoder.int_as_varint (0) encoder
  | Is_null -> Pbrt.Encoder.int_as_varint 1 encoder
  | Is_not_null -> Pbrt.Encoder.int_as_varint 2 encoder

let rec encode_pb_bool_test_type (v:bool_test_type) encoder =
  match v with
  | Bool_test_type_undefined -> Pbrt.Encoder.int_as_varint (0) encoder
  | Is_true -> Pbrt.Encoder.int_as_varint 1 encoder
  | Is_not_true -> Pbrt.Encoder.int_as_varint 2 encoder
  | Is_false -> Pbrt.Encoder.int_as_varint 3 encoder
  | Is_not_false -> Pbrt.Encoder.int_as_varint 4 encoder
  | Is_unknown -> Pbrt.Encoder.int_as_varint 5 encoder
  | Is_not_unknown -> Pbrt.Encoder.int_as_varint 6 encoder

let rec encode_pb_range_tbl_ref (v:range_tbl_ref) encoder = 
  Pbrt.Encoder.int32_as_varint v.rtindex encoder;
  Pbrt.Encoder.key 1 Pbrt.Varint encoder; 
  ()

let rec encode_pb_join_type (v:join_type) encoder =
  match v with
  | Join_type_undefined -> Pbrt.Encoder.int_as_varint (0) encoder
  | Join_inner -> Pbrt.Encoder.int_as_varint 1 encoder
  | Join_left -> Pbrt.Encoder.int_as_varint 2 encoder
  | Join_full -> Pbrt.Encoder.int_as_varint 3 encoder
  | Join_right -> Pbrt.Encoder.int_as_varint 4 encoder
  | Join_semi -> Pbrt.Encoder.int_as_varint 5 encoder
  | Join_anti -> Pbrt.Encoder.int_as_varint 6 encoder
  | Join_unique_outer -> Pbrt.Encoder.int_as_varint 7 encoder
  | Join_unique_inner -> Pbrt.Encoder.int_as_varint 8 encoder

let rec encode_pb_on_conflict_action (v:on_conflict_action) encoder =
  match v with
  | On_conflict_action_undefined -> Pbrt.Encoder.int_as_varint (0) encoder
  | Onconflict_none -> Pbrt.Encoder.int_as_varint 1 encoder
  | Onconflict_nothing -> Pbrt.Encoder.int_as_varint 2 encoder
  | Onconflict_update -> Pbrt.Encoder.int_as_varint 3 encoder

let rec encode_pb_on_commit_action (v:on_commit_action) encoder =
  match v with
  | On_commit_action_undefined -> Pbrt.Encoder.int_as_varint (0) encoder
  | Oncommit_noop -> Pbrt.Encoder.int_as_varint 1 encoder
  | Oncommit_preserve_rows -> Pbrt.Encoder.int_as_varint 2 encoder
  | Oncommit_delete_rows -> Pbrt.Encoder.int_as_varint 3 encoder
  | Oncommit_drop -> Pbrt.Encoder.int_as_varint 4 encoder

let rec encode_pb_cmd_type (v:cmd_type) encoder =
  match v with
  | Cmd_type_undefined -> Pbrt.Encoder.int_as_varint (0) encoder
  | Cmd_unknown -> Pbrt.Encoder.int_as_varint 1 encoder
  | Cmd_select -> Pbrt.Encoder.int_as_varint 2 encoder
  | Cmd_update -> Pbrt.Encoder.int_as_varint 3 encoder
  | Cmd_insert -> Pbrt.Encoder.int_as_varint 4 encoder
  | Cmd_delete -> Pbrt.Encoder.int_as_varint 5 encoder
  | Cmd_utility -> Pbrt.Encoder.int_as_varint 6 encoder
  | Cmd_nothing -> Pbrt.Encoder.int_as_varint 7 encoder

let rec encode_pb_query_source (v:query_source) encoder =
  match v with
  | Query_source_undefined -> Pbrt.Encoder.int_as_varint (0) encoder
  | Qsrc_original -> Pbrt.Encoder.int_as_varint 1 encoder
  | Qsrc_parser -> Pbrt.Encoder.int_as_varint 2 encoder
  | Qsrc_instead_rule -> Pbrt.Encoder.int_as_varint 3 encoder
  | Qsrc_qual_instead_rule -> Pbrt.Encoder.int_as_varint 4 encoder
  | Qsrc_non_instead_rule -> Pbrt.Encoder.int_as_varint 5 encoder

let rec encode_pb_overriding_kind (v:overriding_kind) encoder =
  match v with
  | Overriding_kind_undefined -> Pbrt.Encoder.int_as_varint (0) encoder
  | Overriding_not_set -> Pbrt.Encoder.int_as_varint 1 encoder
  | Overriding_user_value -> Pbrt.Encoder.int_as_varint 2 encoder
  | Overriding_system_value -> Pbrt.Encoder.int_as_varint 3 encoder

let rec encode_pb_limit_option (v:limit_option) encoder =
  match v with
  | Limit_option_undefined -> Pbrt.Encoder.int_as_varint (0) encoder
  | Limit_option_default -> Pbrt.Encoder.int_as_varint 1 encoder
  | Limit_option_count -> Pbrt.Encoder.int_as_varint 2 encoder
  | Limit_option_with_ties -> Pbrt.Encoder.int_as_varint 3 encoder

let rec encode_pb_set_operation (v:set_operation) encoder =
  match v with
  | Set_operation_undefined -> Pbrt.Encoder.int_as_varint (0) encoder
  | Setop_none -> Pbrt.Encoder.int_as_varint 1 encoder
  | Setop_union -> Pbrt.Encoder.int_as_varint 2 encoder
  | Setop_intersect -> Pbrt.Encoder.int_as_varint 3 encoder
  | Setop_except -> Pbrt.Encoder.int_as_varint 4 encoder

let rec encode_pb_object_type (v:object_type) encoder =
  match v with
  | Object_type_undefined -> Pbrt.Encoder.int_as_varint (0) encoder
  | Object_access_method -> Pbrt.Encoder.int_as_varint 1 encoder
  | Object_aggregate -> Pbrt.Encoder.int_as_varint 2 encoder
  | Object_amop -> Pbrt.Encoder.int_as_varint 3 encoder
  | Object_amproc -> Pbrt.Encoder.int_as_varint 4 encoder
  | Object_attribute -> Pbrt.Encoder.int_as_varint 5 encoder
  | Object_cast -> Pbrt.Encoder.int_as_varint 6 encoder
  | Object_column -> Pbrt.Encoder.int_as_varint 7 encoder
  | Object_collation -> Pbrt.Encoder.int_as_varint 8 encoder
  | Object_conversion -> Pbrt.Encoder.int_as_varint 9 encoder
  | Object_database -> Pbrt.Encoder.int_as_varint 10 encoder
  | Object_default -> Pbrt.Encoder.int_as_varint 11 encoder
  | Object_defacl -> Pbrt.Encoder.int_as_varint 12 encoder
  | Object_domain -> Pbrt.Encoder.int_as_varint 13 encoder
  | Object_domconstraint -> Pbrt.Encoder.int_as_varint 14 encoder
  | Object_event_trigger -> Pbrt.Encoder.int_as_varint 15 encoder
  | Object_extension -> Pbrt.Encoder.int_as_varint 16 encoder
  | Object_fdw -> Pbrt.Encoder.int_as_varint 17 encoder
  | Object_foreign_server -> Pbrt.Encoder.int_as_varint 18 encoder
  | Object_foreign_table -> Pbrt.Encoder.int_as_varint 19 encoder
  | Object_function -> Pbrt.Encoder.int_as_varint 20 encoder
  | Object_index -> Pbrt.Encoder.int_as_varint 21 encoder
  | Object_language -> Pbrt.Encoder.int_as_varint 22 encoder
  | Object_largeobject -> Pbrt.Encoder.int_as_varint 23 encoder
  | Object_matview -> Pbrt.Encoder.int_as_varint 24 encoder
  | Object_opclass -> Pbrt.Encoder.int_as_varint 25 encoder
  | Object_operator -> Pbrt.Encoder.int_as_varint 26 encoder
  | Object_opfamily -> Pbrt.Encoder.int_as_varint 27 encoder
  | Object_policy -> Pbrt.Encoder.int_as_varint 28 encoder
  | Object_procedure -> Pbrt.Encoder.int_as_varint 29 encoder
  | Object_publication -> Pbrt.Encoder.int_as_varint 30 encoder
  | Object_publication_rel -> Pbrt.Encoder.int_as_varint 31 encoder
  | Object_role -> Pbrt.Encoder.int_as_varint 32 encoder
  | Object_routine -> Pbrt.Encoder.int_as_varint 33 encoder
  | Object_rule -> Pbrt.Encoder.int_as_varint 34 encoder
  | Object_schema -> Pbrt.Encoder.int_as_varint 35 encoder
  | Object_sequence -> Pbrt.Encoder.int_as_varint 36 encoder
  | Object_subscription -> Pbrt.Encoder.int_as_varint 37 encoder
  | Object_statistic_ext -> Pbrt.Encoder.int_as_varint 38 encoder
  | Object_tabconstraint -> Pbrt.Encoder.int_as_varint 39 encoder
  | Object_table -> Pbrt.Encoder.int_as_varint 40 encoder
  | Object_tablespace -> Pbrt.Encoder.int_as_varint 41 encoder
  | Object_transform -> Pbrt.Encoder.int_as_varint 42 encoder
  | Object_trigger -> Pbrt.Encoder.int_as_varint 43 encoder
  | Object_tsconfiguration -> Pbrt.Encoder.int_as_varint 44 encoder
  | Object_tsdictionary -> Pbrt.Encoder.int_as_varint 45 encoder
  | Object_tsparser -> Pbrt.Encoder.int_as_varint 46 encoder
  | Object_tstemplate -> Pbrt.Encoder.int_as_varint 47 encoder
  | Object_type -> Pbrt.Encoder.int_as_varint 48 encoder
  | Object_user_mapping -> Pbrt.Encoder.int_as_varint 49 encoder
  | Object_view -> Pbrt.Encoder.int_as_varint 50 encoder

let rec encode_pb_alter_table_type (v:alter_table_type) encoder =
  match v with
  | Alter_table_type_undefined -> Pbrt.Encoder.int_as_varint (0) encoder
  | At_add_column -> Pbrt.Encoder.int_as_varint 1 encoder
  | At_add_column_recurse -> Pbrt.Encoder.int_as_varint 2 encoder
  | At_add_column_to_view -> Pbrt.Encoder.int_as_varint 3 encoder
  | At_column_default -> Pbrt.Encoder.int_as_varint 4 encoder
  | At_cooked_column_default -> Pbrt.Encoder.int_as_varint 5 encoder
  | At_drop_not_null -> Pbrt.Encoder.int_as_varint 6 encoder
  | At_set_not_null -> Pbrt.Encoder.int_as_varint 7 encoder
  | At_drop_expression -> Pbrt.Encoder.int_as_varint 8 encoder
  | At_check_not_null -> Pbrt.Encoder.int_as_varint 9 encoder
  | At_set_statistics -> Pbrt.Encoder.int_as_varint 10 encoder
  | At_set_options -> Pbrt.Encoder.int_as_varint 11 encoder
  | At_reset_options -> Pbrt.Encoder.int_as_varint 12 encoder
  | At_set_storage -> Pbrt.Encoder.int_as_varint 13 encoder
  | At_drop_column -> Pbrt.Encoder.int_as_varint 14 encoder
  | At_drop_column_recurse -> Pbrt.Encoder.int_as_varint 15 encoder
  | At_add_index -> Pbrt.Encoder.int_as_varint 16 encoder
  | At_re_add_index -> Pbrt.Encoder.int_as_varint 17 encoder
  | At_add_constraint -> Pbrt.Encoder.int_as_varint 18 encoder
  | At_add_constraint_recurse -> Pbrt.Encoder.int_as_varint 19 encoder
  | At_re_add_constraint -> Pbrt.Encoder.int_as_varint 20 encoder
  | At_re_add_domain_constraint -> Pbrt.Encoder.int_as_varint 21 encoder
  | At_alter_constraint -> Pbrt.Encoder.int_as_varint 22 encoder
  | At_validate_constraint -> Pbrt.Encoder.int_as_varint 23 encoder
  | At_validate_constraint_recurse -> Pbrt.Encoder.int_as_varint 24 encoder
  | At_add_index_constraint -> Pbrt.Encoder.int_as_varint 25 encoder
  | At_drop_constraint -> Pbrt.Encoder.int_as_varint 26 encoder
  | At_drop_constraint_recurse -> Pbrt.Encoder.int_as_varint 27 encoder
  | At_re_add_comment -> Pbrt.Encoder.int_as_varint 28 encoder
  | At_alter_column_type -> Pbrt.Encoder.int_as_varint 29 encoder
  | At_alter_column_generic_options -> Pbrt.Encoder.int_as_varint 30 encoder
  | At_change_owner -> Pbrt.Encoder.int_as_varint 31 encoder
  | At_cluster_on -> Pbrt.Encoder.int_as_varint 32 encoder
  | At_drop_cluster -> Pbrt.Encoder.int_as_varint 33 encoder
  | At_set_logged -> Pbrt.Encoder.int_as_varint 34 encoder
  | At_set_un_logged -> Pbrt.Encoder.int_as_varint 35 encoder
  | At_drop_oids -> Pbrt.Encoder.int_as_varint 36 encoder
  | At_set_table_space -> Pbrt.Encoder.int_as_varint 37 encoder
  | At_set_rel_options -> Pbrt.Encoder.int_as_varint 38 encoder
  | At_reset_rel_options -> Pbrt.Encoder.int_as_varint 39 encoder
  | At_replace_rel_options -> Pbrt.Encoder.int_as_varint 40 encoder
  | At_enable_trig -> Pbrt.Encoder.int_as_varint 41 encoder
  | At_enable_always_trig -> Pbrt.Encoder.int_as_varint 42 encoder
  | At_enable_replica_trig -> Pbrt.Encoder.int_as_varint 43 encoder
  | At_disable_trig -> Pbrt.Encoder.int_as_varint 44 encoder
  | At_enable_trig_all -> Pbrt.Encoder.int_as_varint 45 encoder
  | At_disable_trig_all -> Pbrt.Encoder.int_as_varint 46 encoder
  | At_enable_trig_user -> Pbrt.Encoder.int_as_varint 47 encoder
  | At_disable_trig_user -> Pbrt.Encoder.int_as_varint 48 encoder
  | At_enable_rule -> Pbrt.Encoder.int_as_varint 49 encoder
  | At_enable_always_rule -> Pbrt.Encoder.int_as_varint 50 encoder
  | At_enable_replica_rule -> Pbrt.Encoder.int_as_varint 51 encoder
  | At_disable_rule -> Pbrt.Encoder.int_as_varint 52 encoder
  | At_add_inherit -> Pbrt.Encoder.int_as_varint 53 encoder
  | At_drop_inherit -> Pbrt.Encoder.int_as_varint 54 encoder
  | At_add_of -> Pbrt.Encoder.int_as_varint 55 encoder
  | At_drop_of -> Pbrt.Encoder.int_as_varint 56 encoder
  | At_replica_identity -> Pbrt.Encoder.int_as_varint 57 encoder
  | At_enable_row_security -> Pbrt.Encoder.int_as_varint 58 encoder
  | At_disable_row_security -> Pbrt.Encoder.int_as_varint 59 encoder
  | At_force_row_security -> Pbrt.Encoder.int_as_varint 60 encoder
  | At_no_force_row_security -> Pbrt.Encoder.int_as_varint 61 encoder
  | At_generic_options -> Pbrt.Encoder.int_as_varint 62 encoder
  | At_attach_partition -> Pbrt.Encoder.int_as_varint 63 encoder
  | At_detach_partition -> Pbrt.Encoder.int_as_varint 64 encoder
  | At_add_identity -> Pbrt.Encoder.int_as_varint 65 encoder
  | At_set_identity -> Pbrt.Encoder.int_as_varint 66 encoder
  | At_drop_identity -> Pbrt.Encoder.int_as_varint 67 encoder

let rec encode_pb_role_spec_type (v:role_spec_type) encoder =
  match v with
  | Role_spec_type_undefined -> Pbrt.Encoder.int_as_varint (0) encoder
  | Rolespec_cstring -> Pbrt.Encoder.int_as_varint 1 encoder
  | Rolespec_current_user -> Pbrt.Encoder.int_as_varint 2 encoder
  | Rolespec_session_user -> Pbrt.Encoder.int_as_varint 3 encoder
  | Rolespec_public -> Pbrt.Encoder.int_as_varint 4 encoder

let rec encode_pb_role_spec (v:role_spec) encoder = 
  encode_pb_role_spec_type v.roletype encoder;
  Pbrt.Encoder.key 1 Pbrt.Varint encoder; 
  Pbrt.Encoder.string v.rolename encoder;
  Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  Pbrt.Encoder.int32_as_varint v.location encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  ()

let rec encode_pb_drop_behavior (v:drop_behavior) encoder =
  match v with
  | Drop_behavior_undefined -> Pbrt.Encoder.int_as_varint (0) encoder
  | Drop_restrict -> Pbrt.Encoder.int_as_varint 1 encoder
  | Drop_cascade -> Pbrt.Encoder.int_as_varint 2 encoder

let rec encode_pb_grant_target_type (v:grant_target_type) encoder =
  match v with
  | Grant_target_type_undefined -> Pbrt.Encoder.int_as_varint (0) encoder
  | Acl_target_object -> Pbrt.Encoder.int_as_varint 1 encoder
  | Acl_target_all_in_schema -> Pbrt.Encoder.int_as_varint 2 encoder
  | Acl_target_defaults -> Pbrt.Encoder.int_as_varint 3 encoder

let rec encode_pb_close_portal_stmt (v:close_portal_stmt) encoder = 
  Pbrt.Encoder.string v.portalname encoder;
  Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  ()

let rec encode_pb_fetch_direction (v:fetch_direction) encoder =
  match v with
  | Fetch_direction_undefined -> Pbrt.Encoder.int_as_varint (0) encoder
  | Fetch_forward -> Pbrt.Encoder.int_as_varint 1 encoder
  | Fetch_backward -> Pbrt.Encoder.int_as_varint 2 encoder
  | Fetch_absolute -> Pbrt.Encoder.int_as_varint 3 encoder
  | Fetch_relative -> Pbrt.Encoder.int_as_varint 4 encoder

let rec encode_pb_fetch_stmt (v:fetch_stmt) encoder = 
  encode_pb_fetch_direction v.direction encoder;
  Pbrt.Encoder.key 1 Pbrt.Varint encoder; 
  Pbrt.Encoder.int64_as_varint v.how_many encoder;
  Pbrt.Encoder.key 2 Pbrt.Varint encoder; 
  Pbrt.Encoder.string v.portalname encoder;
  Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  Pbrt.Encoder.bool v.ismove encoder;
  Pbrt.Encoder.key 4 Pbrt.Varint encoder; 
  ()

let rec encode_pb_notify_stmt (v:notify_stmt) encoder = 
  Pbrt.Encoder.string v.conditionname encoder;
  Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  Pbrt.Encoder.string v.payload encoder;
  Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  ()

let rec encode_pb_listen_stmt (v:listen_stmt) encoder = 
  Pbrt.Encoder.string v.conditionname encoder;
  Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  ()

let rec encode_pb_unlisten_stmt (v:unlisten_stmt) encoder = 
  Pbrt.Encoder.string v.conditionname encoder;
  Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  ()

let rec encode_pb_transaction_stmt_kind (v:transaction_stmt_kind) encoder =
  match v with
  | Transaction_stmt_kind_undefined -> Pbrt.Encoder.int_as_varint (0) encoder
  | Trans_stmt_begin -> Pbrt.Encoder.int_as_varint 1 encoder
  | Trans_stmt_start -> Pbrt.Encoder.int_as_varint 2 encoder
  | Trans_stmt_commit -> Pbrt.Encoder.int_as_varint 3 encoder
  | Trans_stmt_rollback -> Pbrt.Encoder.int_as_varint 4 encoder
  | Trans_stmt_savepoint -> Pbrt.Encoder.int_as_varint 5 encoder
  | Trans_stmt_release -> Pbrt.Encoder.int_as_varint 6 encoder
  | Trans_stmt_rollback_to -> Pbrt.Encoder.int_as_varint 7 encoder
  | Trans_stmt_prepare -> Pbrt.Encoder.int_as_varint 8 encoder
  | Trans_stmt_commit_prepared -> Pbrt.Encoder.int_as_varint 9 encoder
  | Trans_stmt_rollback_prepared -> Pbrt.Encoder.int_as_varint 10 encoder

let rec encode_pb_view_check_option (v:view_check_option) encoder =
  match v with
  | View_check_option_undefined -> Pbrt.Encoder.int_as_varint (0) encoder
  | No_check_option -> Pbrt.Encoder.int_as_varint 1 encoder
  | Local_check_option -> Pbrt.Encoder.int_as_varint 2 encoder
  | Cascaded_check_option -> Pbrt.Encoder.int_as_varint 3 encoder

let rec encode_pb_load_stmt (v:load_stmt) encoder = 
  Pbrt.Encoder.string v.filename encoder;
  Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  ()

let rec encode_pb_variable_set_kind (v:variable_set_kind) encoder =
  match v with
  | Variable_set_kind_undefined -> Pbrt.Encoder.int_as_varint (0) encoder
  | Var_set_value -> Pbrt.Encoder.int_as_varint 1 encoder
  | Var_set_default -> Pbrt.Encoder.int_as_varint 2 encoder
  | Var_set_current -> Pbrt.Encoder.int_as_varint 3 encoder
  | Var_set_multi -> Pbrt.Encoder.int_as_varint 4 encoder
  | Var_reset -> Pbrt.Encoder.int_as_varint 5 encoder
  | Var_reset_all -> Pbrt.Encoder.int_as_varint 6 encoder

let rec encode_pb_variable_show_stmt (v:variable_show_stmt) encoder = 
  Pbrt.Encoder.string v.name encoder;
  Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  ()

let rec encode_pb_discard_mode (v:discard_mode) encoder =
  match v with
  | Discard_mode_undefined -> Pbrt.Encoder.int_as_varint (0) encoder
  | Discard_all -> Pbrt.Encoder.int_as_varint 1 encoder
  | Discard_plans -> Pbrt.Encoder.int_as_varint 2 encoder
  | Discard_sequences -> Pbrt.Encoder.int_as_varint 3 encoder
  | Discard_temp -> Pbrt.Encoder.int_as_varint 4 encoder

let rec encode_pb_discard_stmt (v:discard_stmt) encoder = 
  encode_pb_discard_mode v.target encoder;
  Pbrt.Encoder.key 1 Pbrt.Varint encoder; 
  ()

let rec encode_pb_role_stmt_type (v:role_stmt_type) encoder =
  match v with
  | Role_stmt_type_undefined -> Pbrt.Encoder.int_as_varint (0) encoder
  | Rolestmt_role -> Pbrt.Encoder.int_as_varint 1 encoder
  | Rolestmt_user -> Pbrt.Encoder.int_as_varint 2 encoder
  | Rolestmt_group -> Pbrt.Encoder.int_as_varint 3 encoder

let rec encode_pb_reindex_object_type (v:reindex_object_type) encoder =
  match v with
  | Reindex_object_type_undefined -> Pbrt.Encoder.int_as_varint (0) encoder
  | Reindex_object_index -> Pbrt.Encoder.int_as_varint 1 encoder
  | Reindex_object_table -> Pbrt.Encoder.int_as_varint 2 encoder
  | Reindex_object_schema -> Pbrt.Encoder.int_as_varint 3 encoder
  | Reindex_object_system -> Pbrt.Encoder.int_as_varint 4 encoder
  | Reindex_object_database -> Pbrt.Encoder.int_as_varint 5 encoder

let rec encode_pb_check_point_stmt (v:check_point_stmt) encoder = 
()

let rec encode_pb_coercion_context (v:coercion_context) encoder =
  match v with
  | Coercion_context_undefined -> Pbrt.Encoder.int_as_varint (0) encoder
  | Coercion_implicit -> Pbrt.Encoder.int_as_varint 1 encoder
  | Coercion_assignment -> Pbrt.Encoder.int_as_varint 2 encoder
  | Coercion_explicit -> Pbrt.Encoder.int_as_varint 3 encoder

let rec encode_pb_deallocate_stmt (v:deallocate_stmt) encoder = 
  Pbrt.Encoder.string v.name encoder;
  Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  ()

let rec encode_pb_drop_table_space_stmt (v:drop_table_space_stmt) encoder = 
  Pbrt.Encoder.string v.tablespacename encoder;
  Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  Pbrt.Encoder.bool v.missing_ok encoder;
  Pbrt.Encoder.key 2 Pbrt.Varint encoder; 
  ()

let rec encode_pb_alter_tsconfig_type (v:alter_tsconfig_type) encoder =
  match v with
  | Alter_tsconfig_type_undefined -> Pbrt.Encoder.int_as_varint (0) encoder
  | Alter_tsconfig_add_mapping -> Pbrt.Encoder.int_as_varint 1 encoder
  | Alter_tsconfig_alter_mapping_for_token -> Pbrt.Encoder.int_as_varint 2 encoder
  | Alter_tsconfig_replace_dict -> Pbrt.Encoder.int_as_varint 3 encoder
  | Alter_tsconfig_replace_dict_for_token -> Pbrt.Encoder.int_as_varint 4 encoder
  | Alter_tsconfig_drop_mapping -> Pbrt.Encoder.int_as_varint 5 encoder

let rec encode_pb_drop_user_mapping_stmt (v:drop_user_mapping_stmt) encoder = 
  begin match v.user with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_role_spec x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.string v.servername encoder;
  Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  Pbrt.Encoder.bool v.missing_ok encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  ()

let rec encode_pb_import_foreign_schema_type (v:import_foreign_schema_type) encoder =
  match v with
  | Import_foreign_schema_type_undefined -> Pbrt.Encoder.int_as_varint (0) encoder
  | Fdw_import_schema_all -> Pbrt.Encoder.int_as_varint 1 encoder
  | Fdw_import_schema_limit_to -> Pbrt.Encoder.int_as_varint 2 encoder
  | Fdw_import_schema_except -> Pbrt.Encoder.int_as_varint 3 encoder

let rec encode_pb_alter_event_trig_stmt (v:alter_event_trig_stmt) encoder = 
  Pbrt.Encoder.string v.trigname encoder;
  Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  Pbrt.Encoder.string v.tgenabled encoder;
  Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  ()

let rec encode_pb_replica_identity_stmt (v:replica_identity_stmt) encoder = 
  Pbrt.Encoder.string v.identity_type encoder;
  Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  Pbrt.Encoder.string v.name encoder;
  Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  ()

let rec encode_pb_def_elem_action (v:def_elem_action) encoder =
  match v with
  | Def_elem_action_undefined -> Pbrt.Encoder.int_as_varint (0) encoder
  | Defelem_unspec -> Pbrt.Encoder.int_as_varint 1 encoder
  | Defelem_set -> Pbrt.Encoder.int_as_varint 2 encoder
  | Defelem_add -> Pbrt.Encoder.int_as_varint 3 encoder
  | Defelem_drop -> Pbrt.Encoder.int_as_varint 4 encoder

let rec encode_pb_alter_subscription_type (v:alter_subscription_type) encoder =
  match v with
  | Alter_subscription_type_undefined -> Pbrt.Encoder.int_as_varint (0) encoder
  | Alter_subscription_options -> Pbrt.Encoder.int_as_varint 1 encoder
  | Alter_subscription_connection -> Pbrt.Encoder.int_as_varint 2 encoder
  | Alter_subscription_publication -> Pbrt.Encoder.int_as_varint 3 encoder
  | Alter_subscription_refresh -> Pbrt.Encoder.int_as_varint 4 encoder
  | Alter_subscription_enabled -> Pbrt.Encoder.int_as_varint 5 encoder

let rec encode_pb_drop_subscription_stmt (v:drop_subscription_stmt) encoder = 
  Pbrt.Encoder.string v.subname encoder;
  Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  Pbrt.Encoder.bool v.missing_ok encoder;
  Pbrt.Encoder.key 2 Pbrt.Varint encoder; 
  encode_pb_drop_behavior v.behavior encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  ()

let rec encode_pb_a_expr_kind (v:a_expr_kind) encoder =
  match v with
  | A_expr_kind_undefined -> Pbrt.Encoder.int_as_varint (0) encoder
  | Aexpr_op -> Pbrt.Encoder.int_as_varint 1 encoder
  | Aexpr_op_any -> Pbrt.Encoder.int_as_varint 2 encoder
  | Aexpr_op_all -> Pbrt.Encoder.int_as_varint 3 encoder
  | Aexpr_distinct -> Pbrt.Encoder.int_as_varint 4 encoder
  | Aexpr_not_distinct -> Pbrt.Encoder.int_as_varint 5 encoder
  | Aexpr_nullif -> Pbrt.Encoder.int_as_varint 6 encoder
  | Aexpr_of -> Pbrt.Encoder.int_as_varint 7 encoder
  | Aexpr_in -> Pbrt.Encoder.int_as_varint 8 encoder
  | Aexpr_like -> Pbrt.Encoder.int_as_varint 9 encoder
  | Aexpr_ilike -> Pbrt.Encoder.int_as_varint 10 encoder
  | Aexpr_similar -> Pbrt.Encoder.int_as_varint 11 encoder
  | Aexpr_between -> Pbrt.Encoder.int_as_varint 12 encoder
  | Aexpr_not_between -> Pbrt.Encoder.int_as_varint 13 encoder
  | Aexpr_between_sym -> Pbrt.Encoder.int_as_varint 14 encoder
  | Aexpr_not_between_sym -> Pbrt.Encoder.int_as_varint 15 encoder
  | Aexpr_paren -> Pbrt.Encoder.int_as_varint 16 encoder

let rec encode_pb_param_ref (v:param_ref) encoder = 
  Pbrt.Encoder.int32_as_varint v.number encoder;
  Pbrt.Encoder.key 1 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.location encoder;
  Pbrt.Encoder.key 2 Pbrt.Varint encoder; 
  ()

let rec encode_pb_a_star (v:a_star) encoder = 
()

let rec encode_pb_sort_by_dir (v:sort_by_dir) encoder =
  match v with
  | Sort_by_dir_undefined -> Pbrt.Encoder.int_as_varint (0) encoder
  | Sortby_default -> Pbrt.Encoder.int_as_varint 1 encoder
  | Sortby_asc -> Pbrt.Encoder.int_as_varint 2 encoder
  | Sortby_desc -> Pbrt.Encoder.int_as_varint 3 encoder
  | Sortby_using -> Pbrt.Encoder.int_as_varint 4 encoder

let rec encode_pb_sort_by_nulls (v:sort_by_nulls) encoder =
  match v with
  | Sort_by_nulls_undefined -> Pbrt.Encoder.int_as_varint (0) encoder
  | Sortby_nulls_default -> Pbrt.Encoder.int_as_varint 1 encoder
  | Sortby_nulls_first -> Pbrt.Encoder.int_as_varint 2 encoder
  | Sortby_nulls_last -> Pbrt.Encoder.int_as_varint 3 encoder

let rec encode_pb_constr_type (v:constr_type) encoder =
  match v with
  | Constr_type_undefined -> Pbrt.Encoder.int_as_varint (0) encoder
  | Constr_null -> Pbrt.Encoder.int_as_varint 1 encoder
  | Constr_notnull -> Pbrt.Encoder.int_as_varint 2 encoder
  | Constr_default -> Pbrt.Encoder.int_as_varint 3 encoder
  | Constr_identity -> Pbrt.Encoder.int_as_varint 4 encoder
  | Constr_generated -> Pbrt.Encoder.int_as_varint 5 encoder
  | Constr_check -> Pbrt.Encoder.int_as_varint 6 encoder
  | Constr_primary -> Pbrt.Encoder.int_as_varint 7 encoder
  | Constr_unique -> Pbrt.Encoder.int_as_varint 8 encoder
  | Constr_exclusion -> Pbrt.Encoder.int_as_varint 9 encoder
  | Constr_foreign -> Pbrt.Encoder.int_as_varint 10 encoder
  | Constr_attr_deferrable -> Pbrt.Encoder.int_as_varint 11 encoder
  | Constr_attr_not_deferrable -> Pbrt.Encoder.int_as_varint 12 encoder
  | Constr_attr_deferred -> Pbrt.Encoder.int_as_varint 13 encoder
  | Constr_attr_immediate -> Pbrt.Encoder.int_as_varint 14 encoder

let rec encode_pb_rtekind (v:rtekind) encoder =
  match v with
  | Rtekind_undefined -> Pbrt.Encoder.int_as_varint (0) encoder
  | Rte_relation -> Pbrt.Encoder.int_as_varint 1 encoder
  | Rte_subquery -> Pbrt.Encoder.int_as_varint 2 encoder
  | Rte_join -> Pbrt.Encoder.int_as_varint 3 encoder
  | Rte_function -> Pbrt.Encoder.int_as_varint 4 encoder
  | Rte_tablefunc -> Pbrt.Encoder.int_as_varint 5 encoder
  | Rte_values -> Pbrt.Encoder.int_as_varint 6 encoder
  | Rte_cte -> Pbrt.Encoder.int_as_varint 7 encoder
  | Rte_namedtuplestore -> Pbrt.Encoder.int_as_varint 8 encoder
  | Rte_result -> Pbrt.Encoder.int_as_varint 9 encoder

let rec encode_pb_wcokind (v:wcokind) encoder =
  match v with
  | Wcokind_undefined -> Pbrt.Encoder.int_as_varint (0) encoder
  | Wco_view_check -> Pbrt.Encoder.int_as_varint 1 encoder
  | Wco_rls_insert_check -> Pbrt.Encoder.int_as_varint 2 encoder
  | Wco_rls_update_check -> Pbrt.Encoder.int_as_varint 3 encoder
  | Wco_rls_conflict_check -> Pbrt.Encoder.int_as_varint 4 encoder

let rec encode_pb_sort_group_clause (v:sort_group_clause) encoder = 
  Pbrt.Encoder.int32_as_varint v.tle_sort_group_ref encoder;
  Pbrt.Encoder.key 1 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.eqop encoder;
  Pbrt.Encoder.key 2 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.sortop encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.nulls_first encoder;
  Pbrt.Encoder.key 4 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.hashable encoder;
  Pbrt.Encoder.key 5 Pbrt.Varint encoder; 
  ()

let rec encode_pb_grouping_set_kind (v:grouping_set_kind) encoder =
  match v with
  | Grouping_set_kind_undefined -> Pbrt.Encoder.int_as_varint (0) encoder
  | Grouping_set_empty -> Pbrt.Encoder.int_as_varint 1 encoder
  | Grouping_set_simple -> Pbrt.Encoder.int_as_varint 2 encoder
  | Grouping_set_rollup -> Pbrt.Encoder.int_as_varint 3 encoder
  | Grouping_set_cube -> Pbrt.Encoder.int_as_varint 4 encoder
  | Grouping_set_sets -> Pbrt.Encoder.int_as_varint 5 encoder

let rec encode_pb_function_parameter_mode (v:function_parameter_mode) encoder =
  match v with
  | Function_parameter_mode_undefined -> Pbrt.Encoder.int_as_varint (0) encoder
  | Func_param_in -> Pbrt.Encoder.int_as_varint 1 encoder
  | Func_param_out -> Pbrt.Encoder.int_as_varint 2 encoder
  | Func_param_inout -> Pbrt.Encoder.int_as_varint 3 encoder
  | Func_param_variadic -> Pbrt.Encoder.int_as_varint 4 encoder
  | Func_param_table -> Pbrt.Encoder.int_as_varint 5 encoder

let rec encode_pb_lock_clause_strength (v:lock_clause_strength) encoder =
  match v with
  | Lock_clause_strength_undefined -> Pbrt.Encoder.int_as_varint (0) encoder
  | Lcs_none -> Pbrt.Encoder.int_as_varint 1 encoder
  | Lcs_forkeyshare -> Pbrt.Encoder.int_as_varint 2 encoder
  | Lcs_forshare -> Pbrt.Encoder.int_as_varint 3 encoder
  | Lcs_fornokeyupdate -> Pbrt.Encoder.int_as_varint 4 encoder
  | Lcs_forupdate -> Pbrt.Encoder.int_as_varint 5 encoder

let rec encode_pb_lock_wait_policy (v:lock_wait_policy) encoder =
  match v with
  | Lock_wait_policy_undefined -> Pbrt.Encoder.int_as_varint (0) encoder
  | Lock_wait_block -> Pbrt.Encoder.int_as_varint 1 encoder
  | Lock_wait_skip -> Pbrt.Encoder.int_as_varint 2 encoder
  | Lock_wait_error -> Pbrt.Encoder.int_as_varint 3 encoder

let rec encode_pb_row_mark_clause (v:row_mark_clause) encoder = 
  Pbrt.Encoder.int32_as_varint v.rti encoder;
  Pbrt.Encoder.key 1 Pbrt.Varint encoder; 
  encode_pb_lock_clause_strength v.strength encoder;
  Pbrt.Encoder.key 2 Pbrt.Varint encoder; 
  encode_pb_lock_wait_policy v.wait_policy encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.pushed_down encoder;
  Pbrt.Encoder.key 4 Pbrt.Varint encoder; 
  ()

let rec encode_pb_ctematerialize (v:ctematerialize) encoder =
  match v with
  | Ctematerialize_undefined -> Pbrt.Encoder.int_as_varint (0) encoder
  | Ctematerialize_default -> Pbrt.Encoder.int_as_varint 1 encoder
  | Ctematerialize_always -> Pbrt.Encoder.int_as_varint 2 encoder
  | Ctematerialize_never -> Pbrt.Encoder.int_as_varint 3 encoder

let rec encode_pb_trigger_transition (v:trigger_transition) encoder = 
  Pbrt.Encoder.string v.name encoder;
  Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  Pbrt.Encoder.bool v.is_new encoder;
  Pbrt.Encoder.key 2 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.is_table encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  ()

let rec encode_pb_partition_range_datum_kind (v:partition_range_datum_kind) encoder =
  match v with
  | Partition_range_datum_kind_undefined -> Pbrt.Encoder.int_as_varint (0) encoder
  | Partition_range_datum_minvalue -> Pbrt.Encoder.int_as_varint 1 encoder
  | Partition_range_datum_value -> Pbrt.Encoder.int_as_varint 2 encoder
  | Partition_range_datum_maxvalue -> Pbrt.Encoder.int_as_varint 3 encoder

let rec encode_pb_inline_code_block (v:inline_code_block) encoder = 
  Pbrt.Encoder.string v.source_text encoder;
  Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  Pbrt.Encoder.int32_as_varint v.lang_oid encoder;
  Pbrt.Encoder.key 2 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.lang_is_trusted encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.atomic encoder;
  Pbrt.Encoder.key 4 Pbrt.Varint encoder; 
  ()

let rec encode_pb_call_context (v:call_context) encoder = 
  Pbrt.Encoder.bool v.atomic encoder;
  Pbrt.Encoder.key 1 Pbrt.Varint encoder; 
  ()

let rec encode_pb_integer (v:integer) encoder = 
  Pbrt.Encoder.int32_as_varint v.ival encoder;
  Pbrt.Encoder.key 1 Pbrt.Varint encoder; 
  ()

let rec encode_pb_pgfloat (v:pgfloat) encoder = 
  Pbrt.Encoder.string v.str encoder;
  Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  ()

let rec encode_pb_pgstring (v:pgstring) encoder = 
  Pbrt.Encoder.string v.str encoder;
  Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  ()

let rec encode_pb_bit_string (v:bit_string) encoder = 
  Pbrt.Encoder.string v.str encoder;
  Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  ()

let rec encode_pb_null (v:null) encoder = 
()

let rec encode_pb_raw_stmt (v:raw_stmt) encoder = 
  begin match v.stmt with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.int32_as_varint v.stmt_location encoder;
  Pbrt.Encoder.key 2 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.stmt_len encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  ()

and encode_pb_node (v:node) encoder = 
  begin match v with
  | Alias x ->
    Pbrt.Encoder.nested encode_pb_alias x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | Range_var x ->
    Pbrt.Encoder.nested encode_pb_range_var x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  | Table_func x ->
    Pbrt.Encoder.nested encode_pb_table_func x encoder;
    Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  | Expr ->
    Pbrt.Encoder.key 4 Pbrt.Bytes encoder; 
    Pbrt.Encoder.empty_nested encoder
  | Var x ->
    Pbrt.Encoder.nested encode_pb_var x encoder;
    Pbrt.Encoder.key 5 Pbrt.Bytes encoder; 
  | Param x ->
    Pbrt.Encoder.nested encode_pb_param x encoder;
    Pbrt.Encoder.key 6 Pbrt.Bytes encoder; 
  | Aggref x ->
    Pbrt.Encoder.nested encode_pb_aggref x encoder;
    Pbrt.Encoder.key 7 Pbrt.Bytes encoder; 
  | Grouping_func x ->
    Pbrt.Encoder.nested encode_pb_grouping_func x encoder;
    Pbrt.Encoder.key 8 Pbrt.Bytes encoder; 
  | Window_func x ->
    Pbrt.Encoder.nested encode_pb_window_func x encoder;
    Pbrt.Encoder.key 9 Pbrt.Bytes encoder; 
  | Subscripting_ref x ->
    Pbrt.Encoder.nested encode_pb_subscripting_ref x encoder;
    Pbrt.Encoder.key 10 Pbrt.Bytes encoder; 
  | Func_expr x ->
    Pbrt.Encoder.nested encode_pb_func_expr x encoder;
    Pbrt.Encoder.key 11 Pbrt.Bytes encoder; 
  | Named_arg_expr x ->
    Pbrt.Encoder.nested encode_pb_named_arg_expr x encoder;
    Pbrt.Encoder.key 12 Pbrt.Bytes encoder; 
  | Op_expr x ->
    Pbrt.Encoder.nested encode_pb_op_expr x encoder;
    Pbrt.Encoder.key 13 Pbrt.Bytes encoder; 
  | Distinct_expr x ->
    Pbrt.Encoder.nested encode_pb_distinct_expr x encoder;
    Pbrt.Encoder.key 14 Pbrt.Bytes encoder; 
  | Null_if_expr x ->
    Pbrt.Encoder.nested encode_pb_null_if_expr x encoder;
    Pbrt.Encoder.key 15 Pbrt.Bytes encoder; 
  | Scalar_array_op_expr x ->
    Pbrt.Encoder.nested encode_pb_scalar_array_op_expr x encoder;
    Pbrt.Encoder.key 16 Pbrt.Bytes encoder; 
  | Bool_expr x ->
    Pbrt.Encoder.nested encode_pb_bool_expr x encoder;
    Pbrt.Encoder.key 17 Pbrt.Bytes encoder; 
  | Sub_link x ->
    Pbrt.Encoder.nested encode_pb_sub_link x encoder;
    Pbrt.Encoder.key 18 Pbrt.Bytes encoder; 
  | Sub_plan x ->
    Pbrt.Encoder.nested encode_pb_sub_plan x encoder;
    Pbrt.Encoder.key 19 Pbrt.Bytes encoder; 
  | Alternative_sub_plan x ->
    Pbrt.Encoder.nested encode_pb_alternative_sub_plan x encoder;
    Pbrt.Encoder.key 20 Pbrt.Bytes encoder; 
  | Field_select x ->
    Pbrt.Encoder.nested encode_pb_field_select x encoder;
    Pbrt.Encoder.key 21 Pbrt.Bytes encoder; 
  | Field_store x ->
    Pbrt.Encoder.nested encode_pb_field_store x encoder;
    Pbrt.Encoder.key 22 Pbrt.Bytes encoder; 
  | Relabel_type x ->
    Pbrt.Encoder.nested encode_pb_relabel_type x encoder;
    Pbrt.Encoder.key 23 Pbrt.Bytes encoder; 
  | Coerce_via_io x ->
    Pbrt.Encoder.nested encode_pb_coerce_via_io x encoder;
    Pbrt.Encoder.key 24 Pbrt.Bytes encoder; 
  | Array_coerce_expr x ->
    Pbrt.Encoder.nested encode_pb_array_coerce_expr x encoder;
    Pbrt.Encoder.key 25 Pbrt.Bytes encoder; 
  | Convert_rowtype_expr x ->
    Pbrt.Encoder.nested encode_pb_convert_rowtype_expr x encoder;
    Pbrt.Encoder.key 26 Pbrt.Bytes encoder; 
  | Collate_expr x ->
    Pbrt.Encoder.nested encode_pb_collate_expr x encoder;
    Pbrt.Encoder.key 27 Pbrt.Bytes encoder; 
  | Case_expr x ->
    Pbrt.Encoder.nested encode_pb_case_expr x encoder;
    Pbrt.Encoder.key 28 Pbrt.Bytes encoder; 
  | Case_when x ->
    Pbrt.Encoder.nested encode_pb_case_when x encoder;
    Pbrt.Encoder.key 29 Pbrt.Bytes encoder; 
  | Case_test_expr x ->
    Pbrt.Encoder.nested encode_pb_case_test_expr x encoder;
    Pbrt.Encoder.key 30 Pbrt.Bytes encoder; 
  | Array_expr x ->
    Pbrt.Encoder.nested encode_pb_array_expr x encoder;
    Pbrt.Encoder.key 31 Pbrt.Bytes encoder; 
  | Row_expr x ->
    Pbrt.Encoder.nested encode_pb_row_expr x encoder;
    Pbrt.Encoder.key 32 Pbrt.Bytes encoder; 
  | Row_compare_expr x ->
    Pbrt.Encoder.nested encode_pb_row_compare_expr x encoder;
    Pbrt.Encoder.key 33 Pbrt.Bytes encoder; 
  | Coalesce_expr x ->
    Pbrt.Encoder.nested encode_pb_coalesce_expr x encoder;
    Pbrt.Encoder.key 34 Pbrt.Bytes encoder; 
  | Min_max_expr x ->
    Pbrt.Encoder.nested encode_pb_min_max_expr x encoder;
    Pbrt.Encoder.key 35 Pbrt.Bytes encoder; 
  | Sqlvalue_function x ->
    Pbrt.Encoder.nested encode_pb_sqlvalue_function x encoder;
    Pbrt.Encoder.key 36 Pbrt.Bytes encoder; 
  | Xml_expr x ->
    Pbrt.Encoder.nested encode_pb_xml_expr x encoder;
    Pbrt.Encoder.key 37 Pbrt.Bytes encoder; 
  | Null_test x ->
    Pbrt.Encoder.nested encode_pb_null_test x encoder;
    Pbrt.Encoder.key 38 Pbrt.Bytes encoder; 
  | Boolean_test x ->
    Pbrt.Encoder.nested encode_pb_boolean_test x encoder;
    Pbrt.Encoder.key 39 Pbrt.Bytes encoder; 
  | Coerce_to_domain x ->
    Pbrt.Encoder.nested encode_pb_coerce_to_domain x encoder;
    Pbrt.Encoder.key 40 Pbrt.Bytes encoder; 
  | Coerce_to_domain_value x ->
    Pbrt.Encoder.nested encode_pb_coerce_to_domain_value x encoder;
    Pbrt.Encoder.key 41 Pbrt.Bytes encoder; 
  | Set_to_default x ->
    Pbrt.Encoder.nested encode_pb_set_to_default x encoder;
    Pbrt.Encoder.key 42 Pbrt.Bytes encoder; 
  | Current_of_expr x ->
    Pbrt.Encoder.nested encode_pb_current_of_expr x encoder;
    Pbrt.Encoder.key 43 Pbrt.Bytes encoder; 
  | Next_value_expr x ->
    Pbrt.Encoder.nested encode_pb_next_value_expr x encoder;
    Pbrt.Encoder.key 44 Pbrt.Bytes encoder; 
  | Inference_elem x ->
    Pbrt.Encoder.nested encode_pb_inference_elem x encoder;
    Pbrt.Encoder.key 45 Pbrt.Bytes encoder; 
  | Target_entry x ->
    Pbrt.Encoder.nested encode_pb_target_entry x encoder;
    Pbrt.Encoder.key 46 Pbrt.Bytes encoder; 
  | Range_tbl_ref x ->
    Pbrt.Encoder.nested encode_pb_range_tbl_ref x encoder;
    Pbrt.Encoder.key 47 Pbrt.Bytes encoder; 
  | Join_expr x ->
    Pbrt.Encoder.nested encode_pb_join_expr x encoder;
    Pbrt.Encoder.key 48 Pbrt.Bytes encoder; 
  | From_expr x ->
    Pbrt.Encoder.nested encode_pb_from_expr x encoder;
    Pbrt.Encoder.key 49 Pbrt.Bytes encoder; 
  | On_conflict_expr x ->
    Pbrt.Encoder.nested encode_pb_on_conflict_expr x encoder;
    Pbrt.Encoder.key 50 Pbrt.Bytes encoder; 
  | Into_clause x ->
    Pbrt.Encoder.nested encode_pb_into_clause x encoder;
    Pbrt.Encoder.key 51 Pbrt.Bytes encoder; 
  | Raw_stmt x ->
    Pbrt.Encoder.nested encode_pb_raw_stmt x encoder;
    Pbrt.Encoder.key 52 Pbrt.Bytes encoder; 
  | Query x ->
    Pbrt.Encoder.nested encode_pb_query x encoder;
    Pbrt.Encoder.key 53 Pbrt.Bytes encoder; 
  | Insert_stmt x ->
    Pbrt.Encoder.nested encode_pb_insert_stmt x encoder;
    Pbrt.Encoder.key 54 Pbrt.Bytes encoder; 
  | Delete_stmt x ->
    Pbrt.Encoder.nested encode_pb_delete_stmt x encoder;
    Pbrt.Encoder.key 55 Pbrt.Bytes encoder; 
  | Update_stmt x ->
    Pbrt.Encoder.nested encode_pb_update_stmt x encoder;
    Pbrt.Encoder.key 56 Pbrt.Bytes encoder; 
  | Select_stmt x ->
    Pbrt.Encoder.nested encode_pb_select_stmt x encoder;
    Pbrt.Encoder.key 57 Pbrt.Bytes encoder; 
  | Alter_table_stmt x ->
    Pbrt.Encoder.nested encode_pb_alter_table_stmt x encoder;
    Pbrt.Encoder.key 58 Pbrt.Bytes encoder; 
  | Alter_table_cmd x ->
    Pbrt.Encoder.nested encode_pb_alter_table_cmd x encoder;
    Pbrt.Encoder.key 59 Pbrt.Bytes encoder; 
  | Alter_domain_stmt x ->
    Pbrt.Encoder.nested encode_pb_alter_domain_stmt x encoder;
    Pbrt.Encoder.key 60 Pbrt.Bytes encoder; 
  | Set_operation_stmt x ->
    Pbrt.Encoder.nested encode_pb_set_operation_stmt x encoder;
    Pbrt.Encoder.key 61 Pbrt.Bytes encoder; 
  | Grant_stmt x ->
    Pbrt.Encoder.nested encode_pb_grant_stmt x encoder;
    Pbrt.Encoder.key 62 Pbrt.Bytes encoder; 
  | Grant_role_stmt x ->
    Pbrt.Encoder.nested encode_pb_grant_role_stmt x encoder;
    Pbrt.Encoder.key 63 Pbrt.Bytes encoder; 
  | Alter_default_privileges_stmt x ->
    Pbrt.Encoder.nested encode_pb_alter_default_privileges_stmt x encoder;
    Pbrt.Encoder.key 64 Pbrt.Bytes encoder; 
  | Close_portal_stmt x ->
    Pbrt.Encoder.nested encode_pb_close_portal_stmt x encoder;
    Pbrt.Encoder.key 65 Pbrt.Bytes encoder; 
  | Cluster_stmt x ->
    Pbrt.Encoder.nested encode_pb_cluster_stmt x encoder;
    Pbrt.Encoder.key 66 Pbrt.Bytes encoder; 
  | Copy_stmt x ->
    Pbrt.Encoder.nested encode_pb_copy_stmt x encoder;
    Pbrt.Encoder.key 67 Pbrt.Bytes encoder; 
  | Create_stmt x ->
    Pbrt.Encoder.nested encode_pb_create_stmt x encoder;
    Pbrt.Encoder.key 68 Pbrt.Bytes encoder; 
  | Define_stmt x ->
    Pbrt.Encoder.nested encode_pb_define_stmt x encoder;
    Pbrt.Encoder.key 69 Pbrt.Bytes encoder; 
  | Drop_stmt x ->
    Pbrt.Encoder.nested encode_pb_drop_stmt x encoder;
    Pbrt.Encoder.key 70 Pbrt.Bytes encoder; 
  | Truncate_stmt x ->
    Pbrt.Encoder.nested encode_pb_truncate_stmt x encoder;
    Pbrt.Encoder.key 71 Pbrt.Bytes encoder; 
  | Comment_stmt x ->
    Pbrt.Encoder.nested encode_pb_comment_stmt x encoder;
    Pbrt.Encoder.key 72 Pbrt.Bytes encoder; 
  | Fetch_stmt x ->
    Pbrt.Encoder.nested encode_pb_fetch_stmt x encoder;
    Pbrt.Encoder.key 73 Pbrt.Bytes encoder; 
  | Index_stmt x ->
    Pbrt.Encoder.nested encode_pb_index_stmt x encoder;
    Pbrt.Encoder.key 74 Pbrt.Bytes encoder; 
  | Create_function_stmt x ->
    Pbrt.Encoder.nested encode_pb_create_function_stmt x encoder;
    Pbrt.Encoder.key 75 Pbrt.Bytes encoder; 
  | Alter_function_stmt x ->
    Pbrt.Encoder.nested encode_pb_alter_function_stmt x encoder;
    Pbrt.Encoder.key 76 Pbrt.Bytes encoder; 
  | Do_stmt x ->
    Pbrt.Encoder.nested encode_pb_do_stmt x encoder;
    Pbrt.Encoder.key 77 Pbrt.Bytes encoder; 
  | Rename_stmt x ->
    Pbrt.Encoder.nested encode_pb_rename_stmt x encoder;
    Pbrt.Encoder.key 78 Pbrt.Bytes encoder; 
  | Rule_stmt x ->
    Pbrt.Encoder.nested encode_pb_rule_stmt x encoder;
    Pbrt.Encoder.key 79 Pbrt.Bytes encoder; 
  | Notify_stmt x ->
    Pbrt.Encoder.nested encode_pb_notify_stmt x encoder;
    Pbrt.Encoder.key 80 Pbrt.Bytes encoder; 
  | Listen_stmt x ->
    Pbrt.Encoder.nested encode_pb_listen_stmt x encoder;
    Pbrt.Encoder.key 81 Pbrt.Bytes encoder; 
  | Unlisten_stmt x ->
    Pbrt.Encoder.nested encode_pb_unlisten_stmt x encoder;
    Pbrt.Encoder.key 82 Pbrt.Bytes encoder; 
  | Transaction_stmt x ->
    Pbrt.Encoder.nested encode_pb_transaction_stmt x encoder;
    Pbrt.Encoder.key 83 Pbrt.Bytes encoder; 
  | View_stmt x ->
    Pbrt.Encoder.nested encode_pb_view_stmt x encoder;
    Pbrt.Encoder.key 84 Pbrt.Bytes encoder; 
  | Load_stmt x ->
    Pbrt.Encoder.nested encode_pb_load_stmt x encoder;
    Pbrt.Encoder.key 85 Pbrt.Bytes encoder; 
  | Create_domain_stmt x ->
    Pbrt.Encoder.nested encode_pb_create_domain_stmt x encoder;
    Pbrt.Encoder.key 86 Pbrt.Bytes encoder; 
  | Createdb_stmt x ->
    Pbrt.Encoder.nested encode_pb_createdb_stmt x encoder;
    Pbrt.Encoder.key 87 Pbrt.Bytes encoder; 
  | Dropdb_stmt x ->
    Pbrt.Encoder.nested encode_pb_dropdb_stmt x encoder;
    Pbrt.Encoder.key 88 Pbrt.Bytes encoder; 
  | Vacuum_stmt x ->
    Pbrt.Encoder.nested encode_pb_vacuum_stmt x encoder;
    Pbrt.Encoder.key 89 Pbrt.Bytes encoder; 
  | Explain_stmt x ->
    Pbrt.Encoder.nested encode_pb_explain_stmt x encoder;
    Pbrt.Encoder.key 90 Pbrt.Bytes encoder; 
  | Create_table_as_stmt x ->
    Pbrt.Encoder.nested encode_pb_create_table_as_stmt x encoder;
    Pbrt.Encoder.key 91 Pbrt.Bytes encoder; 
  | Create_seq_stmt x ->
    Pbrt.Encoder.nested encode_pb_create_seq_stmt x encoder;
    Pbrt.Encoder.key 92 Pbrt.Bytes encoder; 
  | Alter_seq_stmt x ->
    Pbrt.Encoder.nested encode_pb_alter_seq_stmt x encoder;
    Pbrt.Encoder.key 93 Pbrt.Bytes encoder; 
  | Variable_set_stmt x ->
    Pbrt.Encoder.nested encode_pb_variable_set_stmt x encoder;
    Pbrt.Encoder.key 94 Pbrt.Bytes encoder; 
  | Variable_show_stmt x ->
    Pbrt.Encoder.nested encode_pb_variable_show_stmt x encoder;
    Pbrt.Encoder.key 95 Pbrt.Bytes encoder; 
  | Discard_stmt x ->
    Pbrt.Encoder.nested encode_pb_discard_stmt x encoder;
    Pbrt.Encoder.key 96 Pbrt.Bytes encoder; 
  | Create_trig_stmt x ->
    Pbrt.Encoder.nested encode_pb_create_trig_stmt x encoder;
    Pbrt.Encoder.key 97 Pbrt.Bytes encoder; 
  | Create_plang_stmt x ->
    Pbrt.Encoder.nested encode_pb_create_plang_stmt x encoder;
    Pbrt.Encoder.key 98 Pbrt.Bytes encoder; 
  | Create_role_stmt x ->
    Pbrt.Encoder.nested encode_pb_create_role_stmt x encoder;
    Pbrt.Encoder.key 99 Pbrt.Bytes encoder; 
  | Alter_role_stmt x ->
    Pbrt.Encoder.nested encode_pb_alter_role_stmt x encoder;
    Pbrt.Encoder.key 100 Pbrt.Bytes encoder; 
  | Drop_role_stmt x ->
    Pbrt.Encoder.nested encode_pb_drop_role_stmt x encoder;
    Pbrt.Encoder.key 101 Pbrt.Bytes encoder; 
  | Lock_stmt x ->
    Pbrt.Encoder.nested encode_pb_lock_stmt x encoder;
    Pbrt.Encoder.key 102 Pbrt.Bytes encoder; 
  | Constraints_set_stmt x ->
    Pbrt.Encoder.nested encode_pb_constraints_set_stmt x encoder;
    Pbrt.Encoder.key 103 Pbrt.Bytes encoder; 
  | Reindex_stmt x ->
    Pbrt.Encoder.nested encode_pb_reindex_stmt x encoder;
    Pbrt.Encoder.key 104 Pbrt.Bytes encoder; 
  | Check_point_stmt ->
    Pbrt.Encoder.key 105 Pbrt.Bytes encoder; 
    Pbrt.Encoder.empty_nested encoder
  | Create_schema_stmt x ->
    Pbrt.Encoder.nested encode_pb_create_schema_stmt x encoder;
    Pbrt.Encoder.key 106 Pbrt.Bytes encoder; 
  | Alter_database_stmt x ->
    Pbrt.Encoder.nested encode_pb_alter_database_stmt x encoder;
    Pbrt.Encoder.key 107 Pbrt.Bytes encoder; 
  | Alter_database_set_stmt x ->
    Pbrt.Encoder.nested encode_pb_alter_database_set_stmt x encoder;
    Pbrt.Encoder.key 108 Pbrt.Bytes encoder; 
  | Alter_role_set_stmt x ->
    Pbrt.Encoder.nested encode_pb_alter_role_set_stmt x encoder;
    Pbrt.Encoder.key 109 Pbrt.Bytes encoder; 
  | Create_conversion_stmt x ->
    Pbrt.Encoder.nested encode_pb_create_conversion_stmt x encoder;
    Pbrt.Encoder.key 110 Pbrt.Bytes encoder; 
  | Create_cast_stmt x ->
    Pbrt.Encoder.nested encode_pb_create_cast_stmt x encoder;
    Pbrt.Encoder.key 111 Pbrt.Bytes encoder; 
  | Create_op_class_stmt x ->
    Pbrt.Encoder.nested encode_pb_create_op_class_stmt x encoder;
    Pbrt.Encoder.key 112 Pbrt.Bytes encoder; 
  | Create_op_family_stmt x ->
    Pbrt.Encoder.nested encode_pb_create_op_family_stmt x encoder;
    Pbrt.Encoder.key 113 Pbrt.Bytes encoder; 
  | Alter_op_family_stmt x ->
    Pbrt.Encoder.nested encode_pb_alter_op_family_stmt x encoder;
    Pbrt.Encoder.key 114 Pbrt.Bytes encoder; 
  | Prepare_stmt x ->
    Pbrt.Encoder.nested encode_pb_prepare_stmt x encoder;
    Pbrt.Encoder.key 115 Pbrt.Bytes encoder; 
  | Execute_stmt x ->
    Pbrt.Encoder.nested encode_pb_execute_stmt x encoder;
    Pbrt.Encoder.key 116 Pbrt.Bytes encoder; 
  | Deallocate_stmt x ->
    Pbrt.Encoder.nested encode_pb_deallocate_stmt x encoder;
    Pbrt.Encoder.key 117 Pbrt.Bytes encoder; 
  | Declare_cursor_stmt x ->
    Pbrt.Encoder.nested encode_pb_declare_cursor_stmt x encoder;
    Pbrt.Encoder.key 118 Pbrt.Bytes encoder; 
  | Create_table_space_stmt x ->
    Pbrt.Encoder.nested encode_pb_create_table_space_stmt x encoder;
    Pbrt.Encoder.key 119 Pbrt.Bytes encoder; 
  | Drop_table_space_stmt x ->
    Pbrt.Encoder.nested encode_pb_drop_table_space_stmt x encoder;
    Pbrt.Encoder.key 120 Pbrt.Bytes encoder; 
  | Alter_object_depends_stmt x ->
    Pbrt.Encoder.nested encode_pb_alter_object_depends_stmt x encoder;
    Pbrt.Encoder.key 121 Pbrt.Bytes encoder; 
  | Alter_object_schema_stmt x ->
    Pbrt.Encoder.nested encode_pb_alter_object_schema_stmt x encoder;
    Pbrt.Encoder.key 122 Pbrt.Bytes encoder; 
  | Alter_owner_stmt x ->
    Pbrt.Encoder.nested encode_pb_alter_owner_stmt x encoder;
    Pbrt.Encoder.key 123 Pbrt.Bytes encoder; 
  | Alter_operator_stmt x ->
    Pbrt.Encoder.nested encode_pb_alter_operator_stmt x encoder;
    Pbrt.Encoder.key 124 Pbrt.Bytes encoder; 
  | Alter_type_stmt x ->
    Pbrt.Encoder.nested encode_pb_alter_type_stmt x encoder;
    Pbrt.Encoder.key 125 Pbrt.Bytes encoder; 
  | Drop_owned_stmt x ->
    Pbrt.Encoder.nested encode_pb_drop_owned_stmt x encoder;
    Pbrt.Encoder.key 126 Pbrt.Bytes encoder; 
  | Reassign_owned_stmt x ->
    Pbrt.Encoder.nested encode_pb_reassign_owned_stmt x encoder;
    Pbrt.Encoder.key 127 Pbrt.Bytes encoder; 
  | Composite_type_stmt x ->
    Pbrt.Encoder.nested encode_pb_composite_type_stmt x encoder;
    Pbrt.Encoder.key 128 Pbrt.Bytes encoder; 
  | Create_enum_stmt x ->
    Pbrt.Encoder.nested encode_pb_create_enum_stmt x encoder;
    Pbrt.Encoder.key 129 Pbrt.Bytes encoder; 
  | Create_range_stmt x ->
    Pbrt.Encoder.nested encode_pb_create_range_stmt x encoder;
    Pbrt.Encoder.key 130 Pbrt.Bytes encoder; 
  | Alter_enum_stmt x ->
    Pbrt.Encoder.nested encode_pb_alter_enum_stmt x encoder;
    Pbrt.Encoder.key 131 Pbrt.Bytes encoder; 
  | Alter_tsdictionary_stmt x ->
    Pbrt.Encoder.nested encode_pb_alter_tsdictionary_stmt x encoder;
    Pbrt.Encoder.key 132 Pbrt.Bytes encoder; 
  | Alter_tsconfiguration_stmt x ->
    Pbrt.Encoder.nested encode_pb_alter_tsconfiguration_stmt x encoder;
    Pbrt.Encoder.key 133 Pbrt.Bytes encoder; 
  | Create_fdw_stmt x ->
    Pbrt.Encoder.nested encode_pb_create_fdw_stmt x encoder;
    Pbrt.Encoder.key 134 Pbrt.Bytes encoder; 
  | Alter_fdw_stmt x ->
    Pbrt.Encoder.nested encode_pb_alter_fdw_stmt x encoder;
    Pbrt.Encoder.key 135 Pbrt.Bytes encoder; 
  | Create_foreign_server_stmt x ->
    Pbrt.Encoder.nested encode_pb_create_foreign_server_stmt x encoder;
    Pbrt.Encoder.key 136 Pbrt.Bytes encoder; 
  | Alter_foreign_server_stmt x ->
    Pbrt.Encoder.nested encode_pb_alter_foreign_server_stmt x encoder;
    Pbrt.Encoder.key 137 Pbrt.Bytes encoder; 
  | Create_user_mapping_stmt x ->
    Pbrt.Encoder.nested encode_pb_create_user_mapping_stmt x encoder;
    Pbrt.Encoder.key 138 Pbrt.Bytes encoder; 
  | Alter_user_mapping_stmt x ->
    Pbrt.Encoder.nested encode_pb_alter_user_mapping_stmt x encoder;
    Pbrt.Encoder.key 139 Pbrt.Bytes encoder; 
  | Drop_user_mapping_stmt x ->
    Pbrt.Encoder.nested encode_pb_drop_user_mapping_stmt x encoder;
    Pbrt.Encoder.key 140 Pbrt.Bytes encoder; 
  | Alter_table_space_options_stmt x ->
    Pbrt.Encoder.nested encode_pb_alter_table_space_options_stmt x encoder;
    Pbrt.Encoder.key 141 Pbrt.Bytes encoder; 
  | Alter_table_move_all_stmt x ->
    Pbrt.Encoder.nested encode_pb_alter_table_move_all_stmt x encoder;
    Pbrt.Encoder.key 142 Pbrt.Bytes encoder; 
  | Sec_label_stmt x ->
    Pbrt.Encoder.nested encode_pb_sec_label_stmt x encoder;
    Pbrt.Encoder.key 143 Pbrt.Bytes encoder; 
  | Create_foreign_table_stmt x ->
    Pbrt.Encoder.nested encode_pb_create_foreign_table_stmt x encoder;
    Pbrt.Encoder.key 144 Pbrt.Bytes encoder; 
  | Import_foreign_schema_stmt x ->
    Pbrt.Encoder.nested encode_pb_import_foreign_schema_stmt x encoder;
    Pbrt.Encoder.key 145 Pbrt.Bytes encoder; 
  | Create_extension_stmt x ->
    Pbrt.Encoder.nested encode_pb_create_extension_stmt x encoder;
    Pbrt.Encoder.key 146 Pbrt.Bytes encoder; 
  | Alter_extension_stmt x ->
    Pbrt.Encoder.nested encode_pb_alter_extension_stmt x encoder;
    Pbrt.Encoder.key 147 Pbrt.Bytes encoder; 
  | Alter_extension_contents_stmt x ->
    Pbrt.Encoder.nested encode_pb_alter_extension_contents_stmt x encoder;
    Pbrt.Encoder.key 148 Pbrt.Bytes encoder; 
  | Create_event_trig_stmt x ->
    Pbrt.Encoder.nested encode_pb_create_event_trig_stmt x encoder;
    Pbrt.Encoder.key 149 Pbrt.Bytes encoder; 
  | Alter_event_trig_stmt x ->
    Pbrt.Encoder.nested encode_pb_alter_event_trig_stmt x encoder;
    Pbrt.Encoder.key 150 Pbrt.Bytes encoder; 
  | Refresh_mat_view_stmt x ->
    Pbrt.Encoder.nested encode_pb_refresh_mat_view_stmt x encoder;
    Pbrt.Encoder.key 151 Pbrt.Bytes encoder; 
  | Replica_identity_stmt x ->
    Pbrt.Encoder.nested encode_pb_replica_identity_stmt x encoder;
    Pbrt.Encoder.key 152 Pbrt.Bytes encoder; 
  | Alter_system_stmt x ->
    Pbrt.Encoder.nested encode_pb_alter_system_stmt x encoder;
    Pbrt.Encoder.key 153 Pbrt.Bytes encoder; 
  | Create_policy_stmt x ->
    Pbrt.Encoder.nested encode_pb_create_policy_stmt x encoder;
    Pbrt.Encoder.key 154 Pbrt.Bytes encoder; 
  | Alter_policy_stmt x ->
    Pbrt.Encoder.nested encode_pb_alter_policy_stmt x encoder;
    Pbrt.Encoder.key 155 Pbrt.Bytes encoder; 
  | Create_transform_stmt x ->
    Pbrt.Encoder.nested encode_pb_create_transform_stmt x encoder;
    Pbrt.Encoder.key 156 Pbrt.Bytes encoder; 
  | Create_am_stmt x ->
    Pbrt.Encoder.nested encode_pb_create_am_stmt x encoder;
    Pbrt.Encoder.key 157 Pbrt.Bytes encoder; 
  | Create_publication_stmt x ->
    Pbrt.Encoder.nested encode_pb_create_publication_stmt x encoder;
    Pbrt.Encoder.key 158 Pbrt.Bytes encoder; 
  | Alter_publication_stmt x ->
    Pbrt.Encoder.nested encode_pb_alter_publication_stmt x encoder;
    Pbrt.Encoder.key 159 Pbrt.Bytes encoder; 
  | Create_subscription_stmt x ->
    Pbrt.Encoder.nested encode_pb_create_subscription_stmt x encoder;
    Pbrt.Encoder.key 160 Pbrt.Bytes encoder; 
  | Alter_subscription_stmt x ->
    Pbrt.Encoder.nested encode_pb_alter_subscription_stmt x encoder;
    Pbrt.Encoder.key 161 Pbrt.Bytes encoder; 
  | Drop_subscription_stmt x ->
    Pbrt.Encoder.nested encode_pb_drop_subscription_stmt x encoder;
    Pbrt.Encoder.key 162 Pbrt.Bytes encoder; 
  | Create_stats_stmt x ->
    Pbrt.Encoder.nested encode_pb_create_stats_stmt x encoder;
    Pbrt.Encoder.key 163 Pbrt.Bytes encoder; 
  | Alter_collation_stmt x ->
    Pbrt.Encoder.nested encode_pb_alter_collation_stmt x encoder;
    Pbrt.Encoder.key 164 Pbrt.Bytes encoder; 
  | Call_stmt x ->
    Pbrt.Encoder.nested encode_pb_call_stmt x encoder;
    Pbrt.Encoder.key 165 Pbrt.Bytes encoder; 
  | Alter_stats_stmt x ->
    Pbrt.Encoder.nested encode_pb_alter_stats_stmt x encoder;
    Pbrt.Encoder.key 166 Pbrt.Bytes encoder; 
  | A_expr x ->
    Pbrt.Encoder.nested encode_pb_a_expr x encoder;
    Pbrt.Encoder.key 167 Pbrt.Bytes encoder; 
  | Column_ref x ->
    Pbrt.Encoder.nested encode_pb_column_ref x encoder;
    Pbrt.Encoder.key 168 Pbrt.Bytes encoder; 
  | Param_ref x ->
    Pbrt.Encoder.nested encode_pb_param_ref x encoder;
    Pbrt.Encoder.key 169 Pbrt.Bytes encoder; 
  | A_const x ->
    Pbrt.Encoder.nested encode_pb_a_const x encoder;
    Pbrt.Encoder.key 170 Pbrt.Bytes encoder; 
  | Func_call x ->
    Pbrt.Encoder.nested encode_pb_func_call x encoder;
    Pbrt.Encoder.key 171 Pbrt.Bytes encoder; 
  | A_star ->
    Pbrt.Encoder.key 172 Pbrt.Bytes encoder; 
    Pbrt.Encoder.empty_nested encoder
  | A_indices x ->
    Pbrt.Encoder.nested encode_pb_a_indices x encoder;
    Pbrt.Encoder.key 173 Pbrt.Bytes encoder; 
  | A_indirection x ->
    Pbrt.Encoder.nested encode_pb_a_indirection x encoder;
    Pbrt.Encoder.key 174 Pbrt.Bytes encoder; 
  | A_array_expr x ->
    Pbrt.Encoder.nested encode_pb_a_array_expr x encoder;
    Pbrt.Encoder.key 175 Pbrt.Bytes encoder; 
  | Res_target x ->
    Pbrt.Encoder.nested encode_pb_res_target x encoder;
    Pbrt.Encoder.key 176 Pbrt.Bytes encoder; 
  | Multi_assign_ref x ->
    Pbrt.Encoder.nested encode_pb_multi_assign_ref x encoder;
    Pbrt.Encoder.key 177 Pbrt.Bytes encoder; 
  | Type_cast x ->
    Pbrt.Encoder.nested encode_pb_type_cast x encoder;
    Pbrt.Encoder.key 178 Pbrt.Bytes encoder; 
  | Collate_clause x ->
    Pbrt.Encoder.nested encode_pb_collate_clause x encoder;
    Pbrt.Encoder.key 179 Pbrt.Bytes encoder; 
  | Sort_by x ->
    Pbrt.Encoder.nested encode_pb_sort_by x encoder;
    Pbrt.Encoder.key 180 Pbrt.Bytes encoder; 
  | Window_def x ->
    Pbrt.Encoder.nested encode_pb_window_def x encoder;
    Pbrt.Encoder.key 181 Pbrt.Bytes encoder; 
  | Range_subselect x ->
    Pbrt.Encoder.nested encode_pb_range_subselect x encoder;
    Pbrt.Encoder.key 182 Pbrt.Bytes encoder; 
  | Range_function x ->
    Pbrt.Encoder.nested encode_pb_range_function x encoder;
    Pbrt.Encoder.key 183 Pbrt.Bytes encoder; 
  | Range_table_sample x ->
    Pbrt.Encoder.nested encode_pb_range_table_sample x encoder;
    Pbrt.Encoder.key 184 Pbrt.Bytes encoder; 
  | Range_table_func x ->
    Pbrt.Encoder.nested encode_pb_range_table_func x encoder;
    Pbrt.Encoder.key 185 Pbrt.Bytes encoder; 
  | Range_table_func_col x ->
    Pbrt.Encoder.nested encode_pb_range_table_func_col x encoder;
    Pbrt.Encoder.key 186 Pbrt.Bytes encoder; 
  | Type_name x ->
    Pbrt.Encoder.nested encode_pb_type_name x encoder;
    Pbrt.Encoder.key 187 Pbrt.Bytes encoder; 
  | Column_def x ->
    Pbrt.Encoder.nested encode_pb_column_def x encoder;
    Pbrt.Encoder.key 188 Pbrt.Bytes encoder; 
  | Index_elem x ->
    Pbrt.Encoder.nested encode_pb_index_elem x encoder;
    Pbrt.Encoder.key 189 Pbrt.Bytes encoder; 
  | Constraint x ->
    Pbrt.Encoder.nested encode_pb_constraint_ x encoder;
    Pbrt.Encoder.key 190 Pbrt.Bytes encoder; 
  | Def_elem x ->
    Pbrt.Encoder.nested encode_pb_def_elem x encoder;
    Pbrt.Encoder.key 191 Pbrt.Bytes encoder; 
  | Range_tbl_entry x ->
    Pbrt.Encoder.nested encode_pb_range_tbl_entry x encoder;
    Pbrt.Encoder.key 192 Pbrt.Bytes encoder; 
  | Range_tbl_function x ->
    Pbrt.Encoder.nested encode_pb_range_tbl_function x encoder;
    Pbrt.Encoder.key 193 Pbrt.Bytes encoder; 
  | Table_sample_clause x ->
    Pbrt.Encoder.nested encode_pb_table_sample_clause x encoder;
    Pbrt.Encoder.key 194 Pbrt.Bytes encoder; 
  | With_check_option x ->
    Pbrt.Encoder.nested encode_pb_with_check_option x encoder;
    Pbrt.Encoder.key 195 Pbrt.Bytes encoder; 
  | Sort_group_clause x ->
    Pbrt.Encoder.nested encode_pb_sort_group_clause x encoder;
    Pbrt.Encoder.key 196 Pbrt.Bytes encoder; 
  | Grouping_set x ->
    Pbrt.Encoder.nested encode_pb_grouping_set x encoder;
    Pbrt.Encoder.key 197 Pbrt.Bytes encoder; 
  | Window_clause x ->
    Pbrt.Encoder.nested encode_pb_window_clause x encoder;
    Pbrt.Encoder.key 198 Pbrt.Bytes encoder; 
  | Object_with_args x ->
    Pbrt.Encoder.nested encode_pb_object_with_args x encoder;
    Pbrt.Encoder.key 199 Pbrt.Bytes encoder; 
  | Access_priv x ->
    Pbrt.Encoder.nested encode_pb_access_priv x encoder;
    Pbrt.Encoder.key 200 Pbrt.Bytes encoder; 
  | Create_op_class_item x ->
    Pbrt.Encoder.nested encode_pb_create_op_class_item x encoder;
    Pbrt.Encoder.key 201 Pbrt.Bytes encoder; 
  | Table_like_clause x ->
    Pbrt.Encoder.nested encode_pb_table_like_clause x encoder;
    Pbrt.Encoder.key 202 Pbrt.Bytes encoder; 
  | Function_parameter x ->
    Pbrt.Encoder.nested encode_pb_function_parameter x encoder;
    Pbrt.Encoder.key 203 Pbrt.Bytes encoder; 
  | Locking_clause x ->
    Pbrt.Encoder.nested encode_pb_locking_clause x encoder;
    Pbrt.Encoder.key 204 Pbrt.Bytes encoder; 
  | Row_mark_clause x ->
    Pbrt.Encoder.nested encode_pb_row_mark_clause x encoder;
    Pbrt.Encoder.key 205 Pbrt.Bytes encoder; 
  | Xml_serialize x ->
    Pbrt.Encoder.nested encode_pb_xml_serialize x encoder;
    Pbrt.Encoder.key 206 Pbrt.Bytes encoder; 
  | With_clause x ->
    Pbrt.Encoder.nested encode_pb_with_clause x encoder;
    Pbrt.Encoder.key 207 Pbrt.Bytes encoder; 
  | Infer_clause x ->
    Pbrt.Encoder.nested encode_pb_infer_clause x encoder;
    Pbrt.Encoder.key 208 Pbrt.Bytes encoder; 
  | On_conflict_clause x ->
    Pbrt.Encoder.nested encode_pb_on_conflict_clause x encoder;
    Pbrt.Encoder.key 209 Pbrt.Bytes encoder; 
  | Common_table_expr x ->
    Pbrt.Encoder.nested encode_pb_common_table_expr x encoder;
    Pbrt.Encoder.key 210 Pbrt.Bytes encoder; 
  | Role_spec x ->
    Pbrt.Encoder.nested encode_pb_role_spec x encoder;
    Pbrt.Encoder.key 211 Pbrt.Bytes encoder; 
  | Trigger_transition x ->
    Pbrt.Encoder.nested encode_pb_trigger_transition x encoder;
    Pbrt.Encoder.key 212 Pbrt.Bytes encoder; 
  | Partition_elem x ->
    Pbrt.Encoder.nested encode_pb_partition_elem x encoder;
    Pbrt.Encoder.key 213 Pbrt.Bytes encoder; 
  | Partition_spec x ->
    Pbrt.Encoder.nested encode_pb_partition_spec x encoder;
    Pbrt.Encoder.key 214 Pbrt.Bytes encoder; 
  | Partition_bound_spec x ->
    Pbrt.Encoder.nested encode_pb_partition_bound_spec x encoder;
    Pbrt.Encoder.key 215 Pbrt.Bytes encoder; 
  | Partition_range_datum x ->
    Pbrt.Encoder.nested encode_pb_partition_range_datum x encoder;
    Pbrt.Encoder.key 216 Pbrt.Bytes encoder; 
  | Partition_cmd x ->
    Pbrt.Encoder.nested encode_pb_partition_cmd x encoder;
    Pbrt.Encoder.key 217 Pbrt.Bytes encoder; 
  | Vacuum_relation x ->
    Pbrt.Encoder.nested encode_pb_vacuum_relation x encoder;
    Pbrt.Encoder.key 218 Pbrt.Bytes encoder; 
  | Inline_code_block x ->
    Pbrt.Encoder.nested encode_pb_inline_code_block x encoder;
    Pbrt.Encoder.key 219 Pbrt.Bytes encoder; 
  | Call_context x ->
    Pbrt.Encoder.nested encode_pb_call_context x encoder;
    Pbrt.Encoder.key 220 Pbrt.Bytes encoder; 
  | Integer x ->
    Pbrt.Encoder.nested encode_pb_integer x encoder;
    Pbrt.Encoder.key 221 Pbrt.Bytes encoder; 
  | Float x ->
    Pbrt.Encoder.nested encode_pb_pgfloat x encoder;
    Pbrt.Encoder.key 222 Pbrt.Bytes encoder; 
  | String x ->
    Pbrt.Encoder.nested encode_pb_pgstring x encoder;
    Pbrt.Encoder.key 223 Pbrt.Bytes encoder; 
  | Bit_string x ->
    Pbrt.Encoder.nested encode_pb_bit_string x encoder;
    Pbrt.Encoder.key 224 Pbrt.Bytes encoder; 
  | Null ->
    Pbrt.Encoder.key 225 Pbrt.Bytes encoder; 
    Pbrt.Encoder.empty_nested encoder
  | List x ->
    Pbrt.Encoder.nested encode_pb_pglist x encoder;
    Pbrt.Encoder.key 226 Pbrt.Bytes encoder; 
  | Int_list x ->
    Pbrt.Encoder.nested encode_pb_int_list x encoder;
    Pbrt.Encoder.key 227 Pbrt.Bytes encoder; 
  | Oid_list x ->
    Pbrt.Encoder.nested encode_pb_oid_list x encoder;
    Pbrt.Encoder.key 228 Pbrt.Bytes encoder; 
  end

and encode_pb_alias (v:alias) encoder = 
  Pbrt.Encoder.string v.aliasname encoder;
  Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  ) v.colnames encoder;
  ()

and encode_pb_range_var (v:range_var) encoder = 
  Pbrt.Encoder.string v.catalogname encoder;
  Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  Pbrt.Encoder.string v.schemaname encoder;
  Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  Pbrt.Encoder.string v.relname encoder;
  Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  Pbrt.Encoder.bool v.inh encoder;
  Pbrt.Encoder.key 4 Pbrt.Varint encoder; 
  Pbrt.Encoder.string v.relpersistence encoder;
  Pbrt.Encoder.key 5 Pbrt.Bytes encoder; 
  begin match v.alias with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_alias x encoder;
    Pbrt.Encoder.key 6 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.int32_as_varint v.location encoder;
  Pbrt.Encoder.key 7 Pbrt.Varint encoder; 
  ()

and encode_pb_table_func (v:table_func) encoder = 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  ) v.ns_uris encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  ) v.ns_names encoder;
  begin match v.docexpr with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  begin match v.rowexpr with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 4 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 5 Pbrt.Bytes encoder; 
  ) v.colnames encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 6 Pbrt.Bytes encoder; 
  ) v.coltypes encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 7 Pbrt.Bytes encoder; 
  ) v.coltypmods encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 8 Pbrt.Bytes encoder; 
  ) v.colcollations encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 9 Pbrt.Bytes encoder; 
  ) v.colexprs encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 10 Pbrt.Bytes encoder; 
  ) v.coldefexprs encoder;
  Pbrt.Encoder.nested (fun lst encoder ->
    Pbrt.List_util.rev_iter_with (fun x encoder -> 
      Pbrt.Encoder.int64_as_varint x encoder;
    ) lst encoder;
  ) v.notnulls encoder;
  Pbrt.Encoder.key 11 Pbrt.Bytes encoder; 
  Pbrt.Encoder.int32_as_varint v.ordinalitycol encoder;
  Pbrt.Encoder.key 12 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.location encoder;
  Pbrt.Encoder.key 13 Pbrt.Varint encoder; 
  ()

and encode_pb_var (v:var) encoder = 
  begin match v.xpr with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.int32_as_varint v.varno encoder;
  Pbrt.Encoder.key 2 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.varattno encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.vartype encoder;
  Pbrt.Encoder.key 4 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.vartypmod encoder;
  Pbrt.Encoder.key 5 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.varcollid encoder;
  Pbrt.Encoder.key 6 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.varlevelsup encoder;
  Pbrt.Encoder.key 7 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.varnosyn encoder;
  Pbrt.Encoder.key 8 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.varattnosyn encoder;
  Pbrt.Encoder.key 9 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.location encoder;
  Pbrt.Encoder.key 10 Pbrt.Varint encoder; 
  ()

and encode_pb_param (v:param) encoder = 
  begin match v.xpr with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  encode_pb_param_kind v.paramkind encoder;
  Pbrt.Encoder.key 2 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.paramid encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.paramtype encoder;
  Pbrt.Encoder.key 4 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.paramtypmod encoder;
  Pbrt.Encoder.key 5 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.paramcollid encoder;
  Pbrt.Encoder.key 6 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.location encoder;
  Pbrt.Encoder.key 7 Pbrt.Varint encoder; 
  ()

and encode_pb_aggref (v:aggref) encoder = 
  begin match v.xpr with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.int32_as_varint v.aggfnoid encoder;
  Pbrt.Encoder.key 2 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.aggtype encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.aggcollid encoder;
  Pbrt.Encoder.key 4 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.inputcollid encoder;
  Pbrt.Encoder.key 5 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.aggtranstype encoder;
  Pbrt.Encoder.key 6 Pbrt.Varint encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 7 Pbrt.Bytes encoder; 
  ) v.aggargtypes encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 8 Pbrt.Bytes encoder; 
  ) v.aggdirectargs encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 9 Pbrt.Bytes encoder; 
  ) v.args encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 10 Pbrt.Bytes encoder; 
  ) v.aggorder encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 11 Pbrt.Bytes encoder; 
  ) v.aggdistinct encoder;
  begin match v.aggfilter with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 12 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.bool v.aggstar encoder;
  Pbrt.Encoder.key 13 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.aggvariadic encoder;
  Pbrt.Encoder.key 14 Pbrt.Varint encoder; 
  Pbrt.Encoder.string v.aggkind encoder;
  Pbrt.Encoder.key 15 Pbrt.Bytes encoder; 
  Pbrt.Encoder.int32_as_varint v.agglevelsup encoder;
  Pbrt.Encoder.key 16 Pbrt.Varint encoder; 
  encode_pb_agg_split v.aggsplit encoder;
  Pbrt.Encoder.key 17 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.location encoder;
  Pbrt.Encoder.key 18 Pbrt.Varint encoder; 
  ()

and encode_pb_grouping_func (v:grouping_func) encoder = 
  begin match v.xpr with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  ) v.args encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  ) v.refs encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 4 Pbrt.Bytes encoder; 
  ) v.cols encoder;
  Pbrt.Encoder.int32_as_varint v.agglevelsup encoder;
  Pbrt.Encoder.key 5 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.location encoder;
  Pbrt.Encoder.key 6 Pbrt.Varint encoder; 
  ()

and encode_pb_window_func (v:window_func) encoder = 
  begin match v.xpr with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.int32_as_varint v.winfnoid encoder;
  Pbrt.Encoder.key 2 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.wintype encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.wincollid encoder;
  Pbrt.Encoder.key 4 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.inputcollid encoder;
  Pbrt.Encoder.key 5 Pbrt.Varint encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 6 Pbrt.Bytes encoder; 
  ) v.args encoder;
  begin match v.aggfilter with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 7 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.int32_as_varint v.winref encoder;
  Pbrt.Encoder.key 8 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.winstar encoder;
  Pbrt.Encoder.key 9 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.winagg encoder;
  Pbrt.Encoder.key 10 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.location encoder;
  Pbrt.Encoder.key 11 Pbrt.Varint encoder; 
  ()

and encode_pb_subscripting_ref (v:subscripting_ref) encoder = 
  begin match v.xpr with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.int32_as_varint v.refcontainertype encoder;
  Pbrt.Encoder.key 2 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.refelemtype encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.reftypmod encoder;
  Pbrt.Encoder.key 4 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.refcollid encoder;
  Pbrt.Encoder.key 5 Pbrt.Varint encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 6 Pbrt.Bytes encoder; 
  ) v.refupperindexpr encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 7 Pbrt.Bytes encoder; 
  ) v.reflowerindexpr encoder;
  begin match v.refexpr with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 8 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  begin match v.refassgnexpr with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 9 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  ()

and encode_pb_func_expr (v:func_expr) encoder = 
  begin match v.xpr with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.int32_as_varint v.funcid encoder;
  Pbrt.Encoder.key 2 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.funcresulttype encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.funcretset encoder;
  Pbrt.Encoder.key 4 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.funcvariadic encoder;
  Pbrt.Encoder.key 5 Pbrt.Varint encoder; 
  encode_pb_coercion_form v.funcformat encoder;
  Pbrt.Encoder.key 6 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.funccollid encoder;
  Pbrt.Encoder.key 7 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.inputcollid encoder;
  Pbrt.Encoder.key 8 Pbrt.Varint encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 9 Pbrt.Bytes encoder; 
  ) v.args encoder;
  Pbrt.Encoder.int32_as_varint v.location encoder;
  Pbrt.Encoder.key 10 Pbrt.Varint encoder; 
  ()

and encode_pb_named_arg_expr (v:named_arg_expr) encoder = 
  begin match v.xpr with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  begin match v.arg with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.string v.name encoder;
  Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  Pbrt.Encoder.int32_as_varint v.argnumber encoder;
  Pbrt.Encoder.key 4 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.location encoder;
  Pbrt.Encoder.key 5 Pbrt.Varint encoder; 
  ()

and encode_pb_op_expr (v:op_expr) encoder = 
  begin match v.xpr with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.int32_as_varint v.opno encoder;
  Pbrt.Encoder.key 2 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.opfuncid encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.opresulttype encoder;
  Pbrt.Encoder.key 4 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.opretset encoder;
  Pbrt.Encoder.key 5 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.opcollid encoder;
  Pbrt.Encoder.key 6 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.inputcollid encoder;
  Pbrt.Encoder.key 7 Pbrt.Varint encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 8 Pbrt.Bytes encoder; 
  ) v.args encoder;
  Pbrt.Encoder.int32_as_varint v.location encoder;
  Pbrt.Encoder.key 9 Pbrt.Varint encoder; 
  ()

and encode_pb_distinct_expr (v:distinct_expr) encoder = 
  begin match v.xpr with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.int32_as_varint v.opno encoder;
  Pbrt.Encoder.key 2 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.opfuncid encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.opresulttype encoder;
  Pbrt.Encoder.key 4 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.opretset encoder;
  Pbrt.Encoder.key 5 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.opcollid encoder;
  Pbrt.Encoder.key 6 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.inputcollid encoder;
  Pbrt.Encoder.key 7 Pbrt.Varint encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 8 Pbrt.Bytes encoder; 
  ) v.args encoder;
  Pbrt.Encoder.int32_as_varint v.location encoder;
  Pbrt.Encoder.key 9 Pbrt.Varint encoder; 
  ()

and encode_pb_null_if_expr (v:null_if_expr) encoder = 
  begin match v.xpr with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.int32_as_varint v.opno encoder;
  Pbrt.Encoder.key 2 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.opfuncid encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.opresulttype encoder;
  Pbrt.Encoder.key 4 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.opretset encoder;
  Pbrt.Encoder.key 5 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.opcollid encoder;
  Pbrt.Encoder.key 6 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.inputcollid encoder;
  Pbrt.Encoder.key 7 Pbrt.Varint encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 8 Pbrt.Bytes encoder; 
  ) v.args encoder;
  Pbrt.Encoder.int32_as_varint v.location encoder;
  Pbrt.Encoder.key 9 Pbrt.Varint encoder; 
  ()

and encode_pb_scalar_array_op_expr (v:scalar_array_op_expr) encoder = 
  begin match v.xpr with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.int32_as_varint v.opno encoder;
  Pbrt.Encoder.key 2 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.opfuncid encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.use_or encoder;
  Pbrt.Encoder.key 4 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.inputcollid encoder;
  Pbrt.Encoder.key 5 Pbrt.Varint encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 6 Pbrt.Bytes encoder; 
  ) v.args encoder;
  Pbrt.Encoder.int32_as_varint v.location encoder;
  Pbrt.Encoder.key 7 Pbrt.Varint encoder; 
  ()

and encode_pb_bool_expr (v:bool_expr) encoder = 
  begin match v.xpr with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  encode_pb_bool_expr_type v.boolop encoder;
  Pbrt.Encoder.key 2 Pbrt.Varint encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  ) v.args encoder;
  Pbrt.Encoder.int32_as_varint v.location encoder;
  Pbrt.Encoder.key 4 Pbrt.Varint encoder; 
  ()

and encode_pb_sub_link (v:sub_link) encoder = 
  begin match v.xpr with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  encode_pb_sub_link_type v.sub_link_type encoder;
  Pbrt.Encoder.key 2 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.sub_link_id encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  begin match v.testexpr with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 4 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 5 Pbrt.Bytes encoder; 
  ) v.oper_name encoder;
  begin match v.subselect with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 6 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.int32_as_varint v.location encoder;
  Pbrt.Encoder.key 7 Pbrt.Varint encoder; 
  ()

and encode_pb_sub_plan (v:sub_plan) encoder = 
  begin match v.xpr with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  encode_pb_sub_link_type v.sub_link_type encoder;
  Pbrt.Encoder.key 2 Pbrt.Varint encoder; 
  begin match v.testexpr with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 4 Pbrt.Bytes encoder; 
  ) v.param_ids encoder;
  Pbrt.Encoder.int32_as_varint v.plan_id encoder;
  Pbrt.Encoder.key 5 Pbrt.Varint encoder; 
  Pbrt.Encoder.string v.plan_name encoder;
  Pbrt.Encoder.key 6 Pbrt.Bytes encoder; 
  Pbrt.Encoder.int32_as_varint v.first_col_type encoder;
  Pbrt.Encoder.key 7 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.first_col_typmod encoder;
  Pbrt.Encoder.key 8 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.first_col_collation encoder;
  Pbrt.Encoder.key 9 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.use_hash_table encoder;
  Pbrt.Encoder.key 10 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.unknown_eq_false encoder;
  Pbrt.Encoder.key 11 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.parallel_safe encoder;
  Pbrt.Encoder.key 12 Pbrt.Varint encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 13 Pbrt.Bytes encoder; 
  ) v.set_param encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 14 Pbrt.Bytes encoder; 
  ) v.par_param encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 15 Pbrt.Bytes encoder; 
  ) v.args encoder;
  Pbrt.Encoder.float_as_bits64 v.startup_cost encoder;
  Pbrt.Encoder.key 16 Pbrt.Bits64 encoder; 
  Pbrt.Encoder.float_as_bits64 v.per_call_cost encoder;
  Pbrt.Encoder.key 17 Pbrt.Bits64 encoder; 
  ()

and encode_pb_alternative_sub_plan (v:alternative_sub_plan) encoder = 
  begin match v.xpr with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  ) v.subplans encoder;
  ()

and encode_pb_field_select (v:field_select) encoder = 
  begin match v.xpr with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  begin match v.arg with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.int32_as_varint v.fieldnum encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.resulttype encoder;
  Pbrt.Encoder.key 4 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.resulttypmod encoder;
  Pbrt.Encoder.key 5 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.resultcollid encoder;
  Pbrt.Encoder.key 6 Pbrt.Varint encoder; 
  ()

and encode_pb_field_store (v:field_store) encoder = 
  begin match v.xpr with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  begin match v.arg with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  ) v.newvals encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 4 Pbrt.Bytes encoder; 
  ) v.fieldnums encoder;
  Pbrt.Encoder.int32_as_varint v.resulttype encoder;
  Pbrt.Encoder.key 5 Pbrt.Varint encoder; 
  ()

and encode_pb_relabel_type (v:relabel_type) encoder = 
  begin match v.xpr with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  begin match v.arg with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.int32_as_varint v.resulttype encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.resulttypmod encoder;
  Pbrt.Encoder.key 4 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.resultcollid encoder;
  Pbrt.Encoder.key 5 Pbrt.Varint encoder; 
  encode_pb_coercion_form v.relabelformat encoder;
  Pbrt.Encoder.key 6 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.location encoder;
  Pbrt.Encoder.key 7 Pbrt.Varint encoder; 
  ()

and encode_pb_coerce_via_io (v:coerce_via_io) encoder = 
  begin match v.xpr with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  begin match v.arg with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.int32_as_varint v.resulttype encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.resultcollid encoder;
  Pbrt.Encoder.key 4 Pbrt.Varint encoder; 
  encode_pb_coercion_form v.coerceformat encoder;
  Pbrt.Encoder.key 5 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.location encoder;
  Pbrt.Encoder.key 6 Pbrt.Varint encoder; 
  ()

and encode_pb_array_coerce_expr (v:array_coerce_expr) encoder = 
  begin match v.xpr with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  begin match v.arg with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  begin match v.elemexpr with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.int32_as_varint v.resulttype encoder;
  Pbrt.Encoder.key 4 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.resulttypmod encoder;
  Pbrt.Encoder.key 5 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.resultcollid encoder;
  Pbrt.Encoder.key 6 Pbrt.Varint encoder; 
  encode_pb_coercion_form v.coerceformat encoder;
  Pbrt.Encoder.key 7 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.location encoder;
  Pbrt.Encoder.key 8 Pbrt.Varint encoder; 
  ()

and encode_pb_convert_rowtype_expr (v:convert_rowtype_expr) encoder = 
  begin match v.xpr with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  begin match v.arg with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.int32_as_varint v.resulttype encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  encode_pb_coercion_form v.convertformat encoder;
  Pbrt.Encoder.key 4 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.location encoder;
  Pbrt.Encoder.key 5 Pbrt.Varint encoder; 
  ()

and encode_pb_collate_expr (v:collate_expr) encoder = 
  begin match v.xpr with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  begin match v.arg with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.int32_as_varint v.coll_oid encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.location encoder;
  Pbrt.Encoder.key 4 Pbrt.Varint encoder; 
  ()

and encode_pb_case_expr (v:case_expr) encoder = 
  begin match v.xpr with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.int32_as_varint v.casetype encoder;
  Pbrt.Encoder.key 2 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.casecollid encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  begin match v.arg with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 4 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 5 Pbrt.Bytes encoder; 
  ) v.args encoder;
  begin match v.defresult with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 6 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.int32_as_varint v.location encoder;
  Pbrt.Encoder.key 7 Pbrt.Varint encoder; 
  ()

and encode_pb_case_when (v:case_when) encoder = 
  begin match v.xpr with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  begin match v.expr with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  begin match v.result with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.int32_as_varint v.location encoder;
  Pbrt.Encoder.key 4 Pbrt.Varint encoder; 
  ()

and encode_pb_case_test_expr (v:case_test_expr) encoder = 
  begin match v.xpr with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.int32_as_varint v.type_id encoder;
  Pbrt.Encoder.key 2 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.type_mod encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.collation encoder;
  Pbrt.Encoder.key 4 Pbrt.Varint encoder; 
  ()

and encode_pb_array_expr (v:array_expr) encoder = 
  begin match v.xpr with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.int32_as_varint v.array_typeid encoder;
  Pbrt.Encoder.key 2 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.array_collid encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.element_typeid encoder;
  Pbrt.Encoder.key 4 Pbrt.Varint encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 5 Pbrt.Bytes encoder; 
  ) v.elements encoder;
  Pbrt.Encoder.bool v.multidims encoder;
  Pbrt.Encoder.key 6 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.location encoder;
  Pbrt.Encoder.key 7 Pbrt.Varint encoder; 
  ()

and encode_pb_row_expr (v:row_expr) encoder = 
  begin match v.xpr with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  ) v.args encoder;
  Pbrt.Encoder.int32_as_varint v.row_typeid encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  encode_pb_coercion_form v.row_format encoder;
  Pbrt.Encoder.key 4 Pbrt.Varint encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 5 Pbrt.Bytes encoder; 
  ) v.colnames encoder;
  Pbrt.Encoder.int32_as_varint v.location encoder;
  Pbrt.Encoder.key 6 Pbrt.Varint encoder; 
  ()

and encode_pb_row_compare_expr (v:row_compare_expr) encoder = 
  begin match v.xpr with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  encode_pb_row_compare_type v.rctype encoder;
  Pbrt.Encoder.key 2 Pbrt.Varint encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  ) v.opnos encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 4 Pbrt.Bytes encoder; 
  ) v.opfamilies encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 5 Pbrt.Bytes encoder; 
  ) v.inputcollids encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 6 Pbrt.Bytes encoder; 
  ) v.largs encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 7 Pbrt.Bytes encoder; 
  ) v.rargs encoder;
  ()

and encode_pb_coalesce_expr (v:coalesce_expr) encoder = 
  begin match v.xpr with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.int32_as_varint v.coalescetype encoder;
  Pbrt.Encoder.key 2 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.coalescecollid encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 4 Pbrt.Bytes encoder; 
  ) v.args encoder;
  Pbrt.Encoder.int32_as_varint v.location encoder;
  Pbrt.Encoder.key 5 Pbrt.Varint encoder; 
  ()

and encode_pb_min_max_expr (v:min_max_expr) encoder = 
  begin match v.xpr with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.int32_as_varint v.minmaxtype encoder;
  Pbrt.Encoder.key 2 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.minmaxcollid encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.inputcollid encoder;
  Pbrt.Encoder.key 4 Pbrt.Varint encoder; 
  encode_pb_min_max_op v.op encoder;
  Pbrt.Encoder.key 5 Pbrt.Varint encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 6 Pbrt.Bytes encoder; 
  ) v.args encoder;
  Pbrt.Encoder.int32_as_varint v.location encoder;
  Pbrt.Encoder.key 7 Pbrt.Varint encoder; 
  ()

and encode_pb_sqlvalue_function (v:sqlvalue_function) encoder = 
  begin match v.xpr with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  encode_pb_sqlvalue_function_op v.op encoder;
  Pbrt.Encoder.key 2 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.type_ encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.typmod encoder;
  Pbrt.Encoder.key 4 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.location encoder;
  Pbrt.Encoder.key 5 Pbrt.Varint encoder; 
  ()

and encode_pb_xml_expr (v:xml_expr) encoder = 
  begin match v.xpr with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  encode_pb_xml_expr_op v.op encoder;
  Pbrt.Encoder.key 2 Pbrt.Varint encoder; 
  Pbrt.Encoder.string v.name encoder;
  Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 4 Pbrt.Bytes encoder; 
  ) v.named_args encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 5 Pbrt.Bytes encoder; 
  ) v.arg_names encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 6 Pbrt.Bytes encoder; 
  ) v.args encoder;
  encode_pb_xml_option_type v.xmloption encoder;
  Pbrt.Encoder.key 7 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.type_ encoder;
  Pbrt.Encoder.key 8 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.typmod encoder;
  Pbrt.Encoder.key 9 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.location encoder;
  Pbrt.Encoder.key 10 Pbrt.Varint encoder; 
  ()

and encode_pb_null_test (v:null_test) encoder = 
  begin match v.xpr with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  begin match v.arg with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  encode_pb_null_test_type v.nulltesttype encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.argisrow encoder;
  Pbrt.Encoder.key 4 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.location encoder;
  Pbrt.Encoder.key 5 Pbrt.Varint encoder; 
  ()

and encode_pb_boolean_test (v:boolean_test) encoder = 
  begin match v.xpr with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  begin match v.arg with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  encode_pb_bool_test_type v.booltesttype encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.location encoder;
  Pbrt.Encoder.key 4 Pbrt.Varint encoder; 
  ()

and encode_pb_coerce_to_domain (v:coerce_to_domain) encoder = 
  begin match v.xpr with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  begin match v.arg with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.int32_as_varint v.resulttype encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.resulttypmod encoder;
  Pbrt.Encoder.key 4 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.resultcollid encoder;
  Pbrt.Encoder.key 5 Pbrt.Varint encoder; 
  encode_pb_coercion_form v.coercionformat encoder;
  Pbrt.Encoder.key 6 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.location encoder;
  Pbrt.Encoder.key 7 Pbrt.Varint encoder; 
  ()

and encode_pb_coerce_to_domain_value (v:coerce_to_domain_value) encoder = 
  begin match v.xpr with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.int32_as_varint v.type_id encoder;
  Pbrt.Encoder.key 2 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.type_mod encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.collation encoder;
  Pbrt.Encoder.key 4 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.location encoder;
  Pbrt.Encoder.key 5 Pbrt.Varint encoder; 
  ()

and encode_pb_set_to_default (v:set_to_default) encoder = 
  begin match v.xpr with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.int32_as_varint v.type_id encoder;
  Pbrt.Encoder.key 2 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.type_mod encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.collation encoder;
  Pbrt.Encoder.key 4 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.location encoder;
  Pbrt.Encoder.key 5 Pbrt.Varint encoder; 
  ()

and encode_pb_current_of_expr (v:current_of_expr) encoder = 
  begin match v.xpr with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.int32_as_varint v.cvarno encoder;
  Pbrt.Encoder.key 2 Pbrt.Varint encoder; 
  Pbrt.Encoder.string v.cursor_name encoder;
  Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  Pbrt.Encoder.int32_as_varint v.cursor_param encoder;
  Pbrt.Encoder.key 4 Pbrt.Varint encoder; 
  ()

and encode_pb_next_value_expr (v:next_value_expr) encoder = 
  begin match v.xpr with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.int32_as_varint v.seqid encoder;
  Pbrt.Encoder.key 2 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.type_id encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  ()

and encode_pb_inference_elem (v:inference_elem) encoder = 
  begin match v.xpr with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  begin match v.expr with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.int32_as_varint v.infercollid encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.inferopclass encoder;
  Pbrt.Encoder.key 4 Pbrt.Varint encoder; 
  ()

and encode_pb_target_entry (v:target_entry) encoder = 
  begin match v.xpr with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  begin match v.expr with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.int32_as_varint v.resno encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  Pbrt.Encoder.string v.resname encoder;
  Pbrt.Encoder.key 4 Pbrt.Bytes encoder; 
  Pbrt.Encoder.int32_as_varint v.ressortgroupref encoder;
  Pbrt.Encoder.key 5 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.resorigtbl encoder;
  Pbrt.Encoder.key 6 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.resorigcol encoder;
  Pbrt.Encoder.key 7 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.resjunk encoder;
  Pbrt.Encoder.key 8 Pbrt.Varint encoder; 
  ()

and encode_pb_join_expr (v:join_expr) encoder = 
  encode_pb_join_type v.jointype encoder;
  Pbrt.Encoder.key 1 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.is_natural encoder;
  Pbrt.Encoder.key 2 Pbrt.Varint encoder; 
  begin match v.larg with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  begin match v.rarg with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 4 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 5 Pbrt.Bytes encoder; 
  ) v.using_clause encoder;
  begin match v.quals with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 6 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  begin match v.alias with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_alias x encoder;
    Pbrt.Encoder.key 7 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.int32_as_varint v.rtindex encoder;
  Pbrt.Encoder.key 8 Pbrt.Varint encoder; 
  ()

and encode_pb_from_expr (v:from_expr) encoder = 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  ) v.fromlist encoder;
  begin match v.quals with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  ()

and encode_pb_on_conflict_expr (v:on_conflict_expr) encoder = 
  encode_pb_on_conflict_action v.action encoder;
  Pbrt.Encoder.key 1 Pbrt.Varint encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  ) v.arbiter_elems encoder;
  begin match v.arbiter_where with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.int32_as_varint v.constraint_ encoder;
  Pbrt.Encoder.key 4 Pbrt.Varint encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 5 Pbrt.Bytes encoder; 
  ) v.on_conflict_set encoder;
  begin match v.on_conflict_where with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 6 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.int32_as_varint v.excl_rel_index encoder;
  Pbrt.Encoder.key 7 Pbrt.Varint encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 8 Pbrt.Bytes encoder; 
  ) v.excl_rel_tlist encoder;
  ()

and encode_pb_into_clause (v:into_clause) encoder = 
  begin match v.rel with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_range_var x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  ) v.col_names encoder;
  Pbrt.Encoder.string v.access_method encoder;
  Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 4 Pbrt.Bytes encoder; 
  ) v.options encoder;
  encode_pb_on_commit_action v.on_commit encoder;
  Pbrt.Encoder.key 5 Pbrt.Varint encoder; 
  Pbrt.Encoder.string v.table_space_name encoder;
  Pbrt.Encoder.key 6 Pbrt.Bytes encoder; 
  begin match v.view_query with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 7 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.bool v.skip_data encoder;
  Pbrt.Encoder.key 8 Pbrt.Varint encoder; 
  ()

and encode_pb_query (v:query) encoder = 
  encode_pb_cmd_type v.command_type encoder;
  Pbrt.Encoder.key 1 Pbrt.Varint encoder; 
  encode_pb_query_source v.query_source encoder;
  Pbrt.Encoder.key 2 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.can_set_tag encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  begin match v.utility_stmt with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 4 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.int32_as_varint v.result_relation encoder;
  Pbrt.Encoder.key 5 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.has_aggs encoder;
  Pbrt.Encoder.key 6 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.has_window_funcs encoder;
  Pbrt.Encoder.key 7 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.has_target_srfs encoder;
  Pbrt.Encoder.key 8 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.has_sub_links encoder;
  Pbrt.Encoder.key 9 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.has_distinct_on encoder;
  Pbrt.Encoder.key 10 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.has_recursive encoder;
  Pbrt.Encoder.key 11 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.has_modifying_cte encoder;
  Pbrt.Encoder.key 12 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.has_for_update encoder;
  Pbrt.Encoder.key 13 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.has_row_security encoder;
  Pbrt.Encoder.key 14 Pbrt.Varint encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 15 Pbrt.Bytes encoder; 
  ) v.cte_list encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 16 Pbrt.Bytes encoder; 
  ) v.rtable encoder;
  begin match v.jointree with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_from_expr x encoder;
    Pbrt.Encoder.key 17 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 18 Pbrt.Bytes encoder; 
  ) v.target_list encoder;
  encode_pb_overriding_kind v.override encoder;
  Pbrt.Encoder.key 19 Pbrt.Varint encoder; 
  begin match v.on_conflict with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_on_conflict_expr x encoder;
    Pbrt.Encoder.key 20 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 21 Pbrt.Bytes encoder; 
  ) v.returning_list encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 22 Pbrt.Bytes encoder; 
  ) v.group_clause encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 23 Pbrt.Bytes encoder; 
  ) v.grouping_sets encoder;
  begin match v.having_qual with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 24 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 25 Pbrt.Bytes encoder; 
  ) v.window_clause encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 26 Pbrt.Bytes encoder; 
  ) v.distinct_clause encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 27 Pbrt.Bytes encoder; 
  ) v.sort_clause encoder;
  begin match v.limit_offset with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 28 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  begin match v.limit_count with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 29 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  encode_pb_limit_option v.limit_option encoder;
  Pbrt.Encoder.key 30 Pbrt.Varint encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 31 Pbrt.Bytes encoder; 
  ) v.row_marks encoder;
  begin match v.set_operations with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 32 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 33 Pbrt.Bytes encoder; 
  ) v.constraint_deps encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 34 Pbrt.Bytes encoder; 
  ) v.with_check_options encoder;
  Pbrt.Encoder.int32_as_varint v.stmt_location encoder;
  Pbrt.Encoder.key 35 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.stmt_len encoder;
  Pbrt.Encoder.key 36 Pbrt.Varint encoder; 
  ()

and encode_pb_insert_stmt (v:insert_stmt) encoder = 
  begin match v.relation with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_range_var x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  ) v.cols encoder;
  begin match v.select_stmt with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  begin match v.on_conflict_clause with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_on_conflict_clause x encoder;
    Pbrt.Encoder.key 4 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 5 Pbrt.Bytes encoder; 
  ) v.returning_list encoder;
  begin match v.with_clause with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_with_clause x encoder;
    Pbrt.Encoder.key 6 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  encode_pb_overriding_kind v.override encoder;
  Pbrt.Encoder.key 7 Pbrt.Varint encoder; 
  ()

and encode_pb_on_conflict_clause (v:on_conflict_clause) encoder = 
  encode_pb_on_conflict_action v.action encoder;
  Pbrt.Encoder.key 1 Pbrt.Varint encoder; 
  begin match v.infer with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_infer_clause x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  ) v.target_list encoder;
  begin match v.where_clause with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 4 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.int32_as_varint v.location encoder;
  Pbrt.Encoder.key 5 Pbrt.Varint encoder; 
  ()

and encode_pb_infer_clause (v:infer_clause) encoder = 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  ) v.index_elems encoder;
  begin match v.where_clause with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.string v.conname encoder;
  Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  Pbrt.Encoder.int32_as_varint v.location encoder;
  Pbrt.Encoder.key 4 Pbrt.Varint encoder; 
  ()

and encode_pb_with_clause (v:with_clause) encoder = 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  ) v.ctes encoder;
  Pbrt.Encoder.bool v.recursive encoder;
  Pbrt.Encoder.key 2 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.location encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  ()

and encode_pb_delete_stmt (v:delete_stmt) encoder = 
  begin match v.relation with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_range_var x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  ) v.using_clause encoder;
  begin match v.where_clause with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 4 Pbrt.Bytes encoder; 
  ) v.returning_list encoder;
  begin match v.with_clause with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_with_clause x encoder;
    Pbrt.Encoder.key 5 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  ()

and encode_pb_update_stmt (v:update_stmt) encoder = 
  begin match v.relation with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_range_var x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  ) v.target_list encoder;
  begin match v.where_clause with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 4 Pbrt.Bytes encoder; 
  ) v.from_clause encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 5 Pbrt.Bytes encoder; 
  ) v.returning_list encoder;
  begin match v.with_clause with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_with_clause x encoder;
    Pbrt.Encoder.key 6 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  ()

and encode_pb_select_stmt (v:select_stmt) encoder = 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  ) v.distinct_clause encoder;
  begin match v.into_clause with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_into_clause x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  ) v.target_list encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 4 Pbrt.Bytes encoder; 
  ) v.from_clause encoder;
  begin match v.where_clause with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 5 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 6 Pbrt.Bytes encoder; 
  ) v.group_clause encoder;
  begin match v.having_clause with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 7 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 8 Pbrt.Bytes encoder; 
  ) v.window_clause encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 9 Pbrt.Bytes encoder; 
  ) v.values_lists encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 10 Pbrt.Bytes encoder; 
  ) v.sort_clause encoder;
  begin match v.limit_offset with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 11 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  begin match v.limit_count with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 12 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  encode_pb_limit_option v.limit_option encoder;
  Pbrt.Encoder.key 13 Pbrt.Varint encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 14 Pbrt.Bytes encoder; 
  ) v.locking_clause encoder;
  begin match v.with_clause with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_with_clause x encoder;
    Pbrt.Encoder.key 15 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  encode_pb_set_operation v.op encoder;
  Pbrt.Encoder.key 16 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.all encoder;
  Pbrt.Encoder.key 17 Pbrt.Varint encoder; 
  begin match v.larg with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_select_stmt x encoder;
    Pbrt.Encoder.key 18 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  begin match v.rarg with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_select_stmt x encoder;
    Pbrt.Encoder.key 19 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  ()

and encode_pb_alter_table_stmt (v:alter_table_stmt) encoder = 
  begin match v.relation with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_range_var x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  ) v.cmds encoder;
  encode_pb_object_type v.relkind encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.missing_ok encoder;
  Pbrt.Encoder.key 4 Pbrt.Varint encoder; 
  ()

and encode_pb_alter_table_cmd (v:alter_table_cmd) encoder = 
  encode_pb_alter_table_type v.subtype encoder;
  Pbrt.Encoder.key 1 Pbrt.Varint encoder; 
  Pbrt.Encoder.string v.name encoder;
  Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  Pbrt.Encoder.int32_as_varint v.num encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  begin match v.newowner with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_role_spec x encoder;
    Pbrt.Encoder.key 4 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  begin match v.def with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 5 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  encode_pb_drop_behavior v.behavior encoder;
  Pbrt.Encoder.key 6 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.missing_ok encoder;
  Pbrt.Encoder.key 7 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.recurse encoder;
  Pbrt.Encoder.key 8 Pbrt.Varint encoder; 
  ()

and encode_pb_alter_domain_stmt (v:alter_domain_stmt) encoder = 
  Pbrt.Encoder.string v.subtype encoder;
  Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  ) v.type_name encoder;
  Pbrt.Encoder.string v.name encoder;
  Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  begin match v.def with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 4 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  encode_pb_drop_behavior v.behavior encoder;
  Pbrt.Encoder.key 5 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.missing_ok encoder;
  Pbrt.Encoder.key 6 Pbrt.Varint encoder; 
  ()

and encode_pb_set_operation_stmt (v:set_operation_stmt) encoder = 
  encode_pb_set_operation v.op encoder;
  Pbrt.Encoder.key 1 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.all encoder;
  Pbrt.Encoder.key 2 Pbrt.Varint encoder; 
  begin match v.larg with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  begin match v.rarg with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 4 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 5 Pbrt.Bytes encoder; 
  ) v.col_types encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 6 Pbrt.Bytes encoder; 
  ) v.col_typmods encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 7 Pbrt.Bytes encoder; 
  ) v.col_collations encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 8 Pbrt.Bytes encoder; 
  ) v.group_clauses encoder;
  ()

and encode_pb_grant_stmt (v:grant_stmt) encoder = 
  Pbrt.Encoder.bool v.is_grant encoder;
  Pbrt.Encoder.key 1 Pbrt.Varint encoder; 
  encode_pb_grant_target_type v.targtype encoder;
  Pbrt.Encoder.key 2 Pbrt.Varint encoder; 
  encode_pb_object_type v.objtype encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 4 Pbrt.Bytes encoder; 
  ) v.objects encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 5 Pbrt.Bytes encoder; 
  ) v.privileges encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 6 Pbrt.Bytes encoder; 
  ) v.grantees encoder;
  Pbrt.Encoder.bool v.grant_option encoder;
  Pbrt.Encoder.key 7 Pbrt.Varint encoder; 
  encode_pb_drop_behavior v.behavior encoder;
  Pbrt.Encoder.key 8 Pbrt.Varint encoder; 
  ()

and encode_pb_grant_role_stmt (v:grant_role_stmt) encoder = 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  ) v.granted_roles encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  ) v.grantee_roles encoder;
  Pbrt.Encoder.bool v.is_grant encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.admin_opt encoder;
  Pbrt.Encoder.key 4 Pbrt.Varint encoder; 
  begin match v.grantor with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_role_spec x encoder;
    Pbrt.Encoder.key 5 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  encode_pb_drop_behavior v.behavior encoder;
  Pbrt.Encoder.key 6 Pbrt.Varint encoder; 
  ()

and encode_pb_alter_default_privileges_stmt (v:alter_default_privileges_stmt) encoder = 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  ) v.options encoder;
  begin match v.action with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_grant_stmt x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  ()

and encode_pb_cluster_stmt (v:cluster_stmt) encoder = 
  begin match v.relation with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_range_var x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.string v.indexname encoder;
  Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  Pbrt.Encoder.int32_as_varint v.options encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  ()

and encode_pb_copy_stmt (v:copy_stmt) encoder = 
  begin match v.relation with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_range_var x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  begin match v.query with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  ) v.attlist encoder;
  Pbrt.Encoder.bool v.is_from encoder;
  Pbrt.Encoder.key 4 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.is_program encoder;
  Pbrt.Encoder.key 5 Pbrt.Varint encoder; 
  Pbrt.Encoder.string v.filename encoder;
  Pbrt.Encoder.key 6 Pbrt.Bytes encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 7 Pbrt.Bytes encoder; 
  ) v.options encoder;
  begin match v.where_clause with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 8 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  ()

and encode_pb_create_stmt (v:create_stmt) encoder = 
  begin match v.relation with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_range_var x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  ) v.table_elts encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  ) v.inh_relations encoder;
  begin match v.partbound with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_partition_bound_spec x encoder;
    Pbrt.Encoder.key 4 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  begin match v.partspec with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_partition_spec x encoder;
    Pbrt.Encoder.key 5 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  begin match v.of_typename with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_type_name x encoder;
    Pbrt.Encoder.key 6 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 7 Pbrt.Bytes encoder; 
  ) v.constraints encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 8 Pbrt.Bytes encoder; 
  ) v.options encoder;
  encode_pb_on_commit_action v.oncommit encoder;
  Pbrt.Encoder.key 9 Pbrt.Varint encoder; 
  Pbrt.Encoder.string v.tablespacename encoder;
  Pbrt.Encoder.key 10 Pbrt.Bytes encoder; 
  Pbrt.Encoder.string v.access_method encoder;
  Pbrt.Encoder.key 11 Pbrt.Bytes encoder; 
  Pbrt.Encoder.bool v.if_not_exists encoder;
  Pbrt.Encoder.key 12 Pbrt.Varint encoder; 
  ()

and encode_pb_partition_bound_spec (v:partition_bound_spec) encoder = 
  Pbrt.Encoder.string v.strategy encoder;
  Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  Pbrt.Encoder.bool v.is_default encoder;
  Pbrt.Encoder.key 2 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.modulus encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.remainder encoder;
  Pbrt.Encoder.key 4 Pbrt.Varint encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 5 Pbrt.Bytes encoder; 
  ) v.listdatums encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 6 Pbrt.Bytes encoder; 
  ) v.lowerdatums encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 7 Pbrt.Bytes encoder; 
  ) v.upperdatums encoder;
  Pbrt.Encoder.int32_as_varint v.location encoder;
  Pbrt.Encoder.key 8 Pbrt.Varint encoder; 
  ()

and encode_pb_partition_spec (v:partition_spec) encoder = 
  Pbrt.Encoder.string v.strategy encoder;
  Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  ) v.part_params encoder;
  Pbrt.Encoder.int32_as_varint v.location encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  ()

and encode_pb_type_name (v:type_name) encoder = 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  ) v.names encoder;
  Pbrt.Encoder.int32_as_varint v.type_oid encoder;
  Pbrt.Encoder.key 2 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.setof encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.pct_type encoder;
  Pbrt.Encoder.key 4 Pbrt.Varint encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 5 Pbrt.Bytes encoder; 
  ) v.typmods encoder;
  Pbrt.Encoder.int32_as_varint v.typemod encoder;
  Pbrt.Encoder.key 6 Pbrt.Varint encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 7 Pbrt.Bytes encoder; 
  ) v.array_bounds encoder;
  Pbrt.Encoder.int32_as_varint v.location encoder;
  Pbrt.Encoder.key 8 Pbrt.Varint encoder; 
  ()

and encode_pb_define_stmt (v:define_stmt) encoder = 
  encode_pb_object_type v.kind encoder;
  Pbrt.Encoder.key 1 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.oldstyle encoder;
  Pbrt.Encoder.key 2 Pbrt.Varint encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  ) v.defnames encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 4 Pbrt.Bytes encoder; 
  ) v.args encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 5 Pbrt.Bytes encoder; 
  ) v.definition encoder;
  Pbrt.Encoder.bool v.if_not_exists encoder;
  Pbrt.Encoder.key 6 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.replace encoder;
  Pbrt.Encoder.key 7 Pbrt.Varint encoder; 
  ()

and encode_pb_drop_stmt (v:drop_stmt) encoder = 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  ) v.objects encoder;
  encode_pb_object_type v.remove_type encoder;
  Pbrt.Encoder.key 2 Pbrt.Varint encoder; 
  encode_pb_drop_behavior v.behavior encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.missing_ok encoder;
  Pbrt.Encoder.key 4 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.concurrent encoder;
  Pbrt.Encoder.key 5 Pbrt.Varint encoder; 
  ()

and encode_pb_truncate_stmt (v:truncate_stmt) encoder = 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  ) v.relations encoder;
  Pbrt.Encoder.bool v.restart_seqs encoder;
  Pbrt.Encoder.key 2 Pbrt.Varint encoder; 
  encode_pb_drop_behavior v.behavior encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  ()

and encode_pb_comment_stmt (v:comment_stmt) encoder = 
  encode_pb_object_type v.objtype encoder;
  Pbrt.Encoder.key 1 Pbrt.Varint encoder; 
  begin match v.object_ with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.string v.comment encoder;
  Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  ()

and encode_pb_index_stmt (v:index_stmt) encoder = 
  Pbrt.Encoder.string v.idxname encoder;
  Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  begin match v.relation with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_range_var x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.string v.access_method encoder;
  Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  Pbrt.Encoder.string v.table_space encoder;
  Pbrt.Encoder.key 4 Pbrt.Bytes encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 5 Pbrt.Bytes encoder; 
  ) v.index_params encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 6 Pbrt.Bytes encoder; 
  ) v.index_including_params encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 7 Pbrt.Bytes encoder; 
  ) v.options encoder;
  begin match v.where_clause with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 8 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 9 Pbrt.Bytes encoder; 
  ) v.exclude_op_names encoder;
  Pbrt.Encoder.string v.idxcomment encoder;
  Pbrt.Encoder.key 10 Pbrt.Bytes encoder; 
  Pbrt.Encoder.int32_as_varint v.index_oid encoder;
  Pbrt.Encoder.key 11 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.old_node encoder;
  Pbrt.Encoder.key 12 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.old_create_subid encoder;
  Pbrt.Encoder.key 13 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.old_first_relfilenode_subid encoder;
  Pbrt.Encoder.key 14 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.unique encoder;
  Pbrt.Encoder.key 15 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.primary encoder;
  Pbrt.Encoder.key 16 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.isconstraint encoder;
  Pbrt.Encoder.key 17 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.deferrable encoder;
  Pbrt.Encoder.key 18 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.initdeferred encoder;
  Pbrt.Encoder.key 19 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.transformed encoder;
  Pbrt.Encoder.key 20 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.concurrent encoder;
  Pbrt.Encoder.key 21 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.if_not_exists encoder;
  Pbrt.Encoder.key 22 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.reset_default_tblspc encoder;
  Pbrt.Encoder.key 23 Pbrt.Varint encoder; 
  ()

and encode_pb_create_function_stmt (v:create_function_stmt) encoder = 
  Pbrt.Encoder.bool v.is_procedure encoder;
  Pbrt.Encoder.key 1 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.replace encoder;
  Pbrt.Encoder.key 2 Pbrt.Varint encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  ) v.funcname encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 4 Pbrt.Bytes encoder; 
  ) v.parameters encoder;
  begin match v.return_type with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_type_name x encoder;
    Pbrt.Encoder.key 5 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 6 Pbrt.Bytes encoder; 
  ) v.options encoder;
  ()

and encode_pb_alter_function_stmt (v:alter_function_stmt) encoder = 
  encode_pb_object_type v.objtype encoder;
  Pbrt.Encoder.key 1 Pbrt.Varint encoder; 
  begin match v.func with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_object_with_args x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  ) v.actions encoder;
  ()

and encode_pb_object_with_args (v:object_with_args) encoder = 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  ) v.objname encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  ) v.objargs encoder;
  Pbrt.Encoder.bool v.args_unspecified encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  ()

and encode_pb_do_stmt (v:do_stmt) encoder = 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  ) v.args encoder;
  ()

and encode_pb_rename_stmt (v:rename_stmt) encoder = 
  encode_pb_object_type v.rename_type encoder;
  Pbrt.Encoder.key 1 Pbrt.Varint encoder; 
  encode_pb_object_type v.relation_type encoder;
  Pbrt.Encoder.key 2 Pbrt.Varint encoder; 
  begin match v.relation with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_range_var x encoder;
    Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  begin match v.object_ with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 4 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.string v.subname encoder;
  Pbrt.Encoder.key 5 Pbrt.Bytes encoder; 
  Pbrt.Encoder.string v.newname encoder;
  Pbrt.Encoder.key 6 Pbrt.Bytes encoder; 
  encode_pb_drop_behavior v.behavior encoder;
  Pbrt.Encoder.key 7 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.missing_ok encoder;
  Pbrt.Encoder.key 8 Pbrt.Varint encoder; 
  ()

and encode_pb_rule_stmt (v:rule_stmt) encoder = 
  begin match v.relation with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_range_var x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.string v.rulename encoder;
  Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  begin match v.where_clause with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  encode_pb_cmd_type v.event encoder;
  Pbrt.Encoder.key 4 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.instead encoder;
  Pbrt.Encoder.key 5 Pbrt.Varint encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 6 Pbrt.Bytes encoder; 
  ) v.actions encoder;
  Pbrt.Encoder.bool v.replace encoder;
  Pbrt.Encoder.key 7 Pbrt.Varint encoder; 
  ()

and encode_pb_transaction_stmt (v:transaction_stmt) encoder = 
  encode_pb_transaction_stmt_kind v.kind encoder;
  Pbrt.Encoder.key 1 Pbrt.Varint encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  ) v.options encoder;
  Pbrt.Encoder.string v.savepoint_name encoder;
  Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  Pbrt.Encoder.string v.gid encoder;
  Pbrt.Encoder.key 4 Pbrt.Bytes encoder; 
  Pbrt.Encoder.bool v.chain encoder;
  Pbrt.Encoder.key 5 Pbrt.Varint encoder; 
  ()

and encode_pb_view_stmt (v:view_stmt) encoder = 
  begin match v.view with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_range_var x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  ) v.aliases encoder;
  begin match v.query with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.bool v.replace encoder;
  Pbrt.Encoder.key 4 Pbrt.Varint encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 5 Pbrt.Bytes encoder; 
  ) v.options encoder;
  encode_pb_view_check_option v.with_check_option encoder;
  Pbrt.Encoder.key 6 Pbrt.Varint encoder; 
  ()

and encode_pb_create_domain_stmt (v:create_domain_stmt) encoder = 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  ) v.domainname encoder;
  begin match v.type_name with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_type_name x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  begin match v.coll_clause with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_collate_clause x encoder;
    Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 4 Pbrt.Bytes encoder; 
  ) v.constraints encoder;
  ()

and encode_pb_collate_clause (v:collate_clause) encoder = 
  begin match v.arg with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  ) v.collname encoder;
  Pbrt.Encoder.int32_as_varint v.location encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  ()

and encode_pb_createdb_stmt (v:createdb_stmt) encoder = 
  Pbrt.Encoder.string v.dbname encoder;
  Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  ) v.options encoder;
  ()

and encode_pb_dropdb_stmt (v:dropdb_stmt) encoder = 
  Pbrt.Encoder.string v.dbname encoder;
  Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  Pbrt.Encoder.bool v.missing_ok encoder;
  Pbrt.Encoder.key 2 Pbrt.Varint encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  ) v.options encoder;
  ()

and encode_pb_vacuum_stmt (v:vacuum_stmt) encoder = 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  ) v.options encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  ) v.rels encoder;
  Pbrt.Encoder.bool v.is_vacuumcmd encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  ()

and encode_pb_explain_stmt (v:explain_stmt) encoder = 
  begin match v.query with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  ) v.options encoder;
  ()

and encode_pb_create_table_as_stmt (v:create_table_as_stmt) encoder = 
  begin match v.query with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  begin match v.into with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_into_clause x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  encode_pb_object_type v.relkind encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.is_select_into encoder;
  Pbrt.Encoder.key 4 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.if_not_exists encoder;
  Pbrt.Encoder.key 5 Pbrt.Varint encoder; 
  ()

and encode_pb_create_seq_stmt (v:create_seq_stmt) encoder = 
  begin match v.sequence with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_range_var x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  ) v.options encoder;
  Pbrt.Encoder.int32_as_varint v.owner_id encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.for_identity encoder;
  Pbrt.Encoder.key 4 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.if_not_exists encoder;
  Pbrt.Encoder.key 5 Pbrt.Varint encoder; 
  ()

and encode_pb_alter_seq_stmt (v:alter_seq_stmt) encoder = 
  begin match v.sequence with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_range_var x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  ) v.options encoder;
  Pbrt.Encoder.bool v.for_identity encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.missing_ok encoder;
  Pbrt.Encoder.key 4 Pbrt.Varint encoder; 
  ()

and encode_pb_variable_set_stmt (v:variable_set_stmt) encoder = 
  encode_pb_variable_set_kind v.kind encoder;
  Pbrt.Encoder.key 1 Pbrt.Varint encoder; 
  Pbrt.Encoder.string v.name encoder;
  Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  ) v.args encoder;
  Pbrt.Encoder.bool v.is_local encoder;
  Pbrt.Encoder.key 4 Pbrt.Varint encoder; 
  ()

and encode_pb_create_trig_stmt (v:create_trig_stmt) encoder = 
  Pbrt.Encoder.string v.trigname encoder;
  Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  begin match v.relation with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_range_var x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  ) v.funcname encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 4 Pbrt.Bytes encoder; 
  ) v.args encoder;
  Pbrt.Encoder.bool v.row encoder;
  Pbrt.Encoder.key 5 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.timing encoder;
  Pbrt.Encoder.key 6 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.events encoder;
  Pbrt.Encoder.key 7 Pbrt.Varint encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 8 Pbrt.Bytes encoder; 
  ) v.columns encoder;
  begin match v.when_clause with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 9 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.bool v.isconstraint encoder;
  Pbrt.Encoder.key 10 Pbrt.Varint encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 11 Pbrt.Bytes encoder; 
  ) v.transition_rels encoder;
  Pbrt.Encoder.bool v.deferrable encoder;
  Pbrt.Encoder.key 12 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.initdeferred encoder;
  Pbrt.Encoder.key 13 Pbrt.Varint encoder; 
  begin match v.constrrel with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_range_var x encoder;
    Pbrt.Encoder.key 14 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  ()

and encode_pb_create_plang_stmt (v:create_plang_stmt) encoder = 
  Pbrt.Encoder.bool v.replace encoder;
  Pbrt.Encoder.key 1 Pbrt.Varint encoder; 
  Pbrt.Encoder.string v.plname encoder;
  Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  ) v.plhandler encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 4 Pbrt.Bytes encoder; 
  ) v.plinline encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 5 Pbrt.Bytes encoder; 
  ) v.plvalidator encoder;
  Pbrt.Encoder.bool v.pltrusted encoder;
  Pbrt.Encoder.key 6 Pbrt.Varint encoder; 
  ()

and encode_pb_create_role_stmt (v:create_role_stmt) encoder = 
  encode_pb_role_stmt_type v.stmt_type encoder;
  Pbrt.Encoder.key 1 Pbrt.Varint encoder; 
  Pbrt.Encoder.string v.role encoder;
  Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  ) v.options encoder;
  ()

and encode_pb_alter_role_stmt (v:alter_role_stmt) encoder = 
  begin match v.role with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_role_spec x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  ) v.options encoder;
  Pbrt.Encoder.int32_as_varint v.action encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  ()

and encode_pb_drop_role_stmt (v:drop_role_stmt) encoder = 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  ) v.roles encoder;
  Pbrt.Encoder.bool v.missing_ok encoder;
  Pbrt.Encoder.key 2 Pbrt.Varint encoder; 
  ()

and encode_pb_lock_stmt (v:lock_stmt) encoder = 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  ) v.relations encoder;
  Pbrt.Encoder.int32_as_varint v.mode encoder;
  Pbrt.Encoder.key 2 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.nowait encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  ()

and encode_pb_constraints_set_stmt (v:constraints_set_stmt) encoder = 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  ) v.constraints encoder;
  Pbrt.Encoder.bool v.deferred encoder;
  Pbrt.Encoder.key 2 Pbrt.Varint encoder; 
  ()

and encode_pb_reindex_stmt (v:reindex_stmt) encoder = 
  encode_pb_reindex_object_type v.kind encoder;
  Pbrt.Encoder.key 1 Pbrt.Varint encoder; 
  begin match v.relation with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_range_var x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.string v.name encoder;
  Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  Pbrt.Encoder.int32_as_varint v.options encoder;
  Pbrt.Encoder.key 4 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.concurrent encoder;
  Pbrt.Encoder.key 5 Pbrt.Varint encoder; 
  ()

and encode_pb_create_schema_stmt (v:create_schema_stmt) encoder = 
  Pbrt.Encoder.string v.schemaname encoder;
  Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  begin match v.authrole with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_role_spec x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  ) v.schema_elts encoder;
  Pbrt.Encoder.bool v.if_not_exists encoder;
  Pbrt.Encoder.key 4 Pbrt.Varint encoder; 
  ()

and encode_pb_alter_database_stmt (v:alter_database_stmt) encoder = 
  Pbrt.Encoder.string v.dbname encoder;
  Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  ) v.options encoder;
  ()

and encode_pb_alter_database_set_stmt (v:alter_database_set_stmt) encoder = 
  Pbrt.Encoder.string v.dbname encoder;
  Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  begin match v.setstmt with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_variable_set_stmt x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  ()

and encode_pb_alter_role_set_stmt (v:alter_role_set_stmt) encoder = 
  begin match v.role with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_role_spec x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.string v.database encoder;
  Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  begin match v.setstmt with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_variable_set_stmt x encoder;
    Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  ()

and encode_pb_create_conversion_stmt (v:create_conversion_stmt) encoder = 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  ) v.conversion_name encoder;
  Pbrt.Encoder.string v.for_encoding_name encoder;
  Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  Pbrt.Encoder.string v.to_encoding_name encoder;
  Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 4 Pbrt.Bytes encoder; 
  ) v.func_name encoder;
  Pbrt.Encoder.bool v.def encoder;
  Pbrt.Encoder.key 5 Pbrt.Varint encoder; 
  ()

and encode_pb_create_cast_stmt (v:create_cast_stmt) encoder = 
  begin match v.sourcetype with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_type_name x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  begin match v.targettype with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_type_name x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  begin match v.func with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_object_with_args x encoder;
    Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  encode_pb_coercion_context v.context encoder;
  Pbrt.Encoder.key 4 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.inout encoder;
  Pbrt.Encoder.key 5 Pbrt.Varint encoder; 
  ()

and encode_pb_create_op_class_stmt (v:create_op_class_stmt) encoder = 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  ) v.opclassname encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  ) v.opfamilyname encoder;
  Pbrt.Encoder.string v.amname encoder;
  Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  begin match v.datatype with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_type_name x encoder;
    Pbrt.Encoder.key 4 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 5 Pbrt.Bytes encoder; 
  ) v.items encoder;
  Pbrt.Encoder.bool v.is_default encoder;
  Pbrt.Encoder.key 6 Pbrt.Varint encoder; 
  ()

and encode_pb_create_op_family_stmt (v:create_op_family_stmt) encoder = 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  ) v.opfamilyname encoder;
  Pbrt.Encoder.string v.amname encoder;
  Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  ()

and encode_pb_alter_op_family_stmt (v:alter_op_family_stmt) encoder = 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  ) v.opfamilyname encoder;
  Pbrt.Encoder.string v.amname encoder;
  Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  Pbrt.Encoder.bool v.is_drop encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 4 Pbrt.Bytes encoder; 
  ) v.items encoder;
  ()

and encode_pb_prepare_stmt (v:prepare_stmt) encoder = 
  Pbrt.Encoder.string v.name encoder;
  Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  ) v.argtypes encoder;
  begin match v.query with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  ()

and encode_pb_execute_stmt (v:execute_stmt) encoder = 
  Pbrt.Encoder.string v.name encoder;
  Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  ) v.params encoder;
  ()

and encode_pb_declare_cursor_stmt (v:declare_cursor_stmt) encoder = 
  Pbrt.Encoder.string v.portalname encoder;
  Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  Pbrt.Encoder.int32_as_varint v.options encoder;
  Pbrt.Encoder.key 2 Pbrt.Varint encoder; 
  begin match v.query with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  ()

and encode_pb_create_table_space_stmt (v:create_table_space_stmt) encoder = 
  Pbrt.Encoder.string v.tablespacename encoder;
  Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  begin match v.owner with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_role_spec x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.string v.location encoder;
  Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 4 Pbrt.Bytes encoder; 
  ) v.options encoder;
  ()

and encode_pb_alter_object_depends_stmt (v:alter_object_depends_stmt) encoder = 
  encode_pb_object_type v.object_type encoder;
  Pbrt.Encoder.key 1 Pbrt.Varint encoder; 
  begin match v.relation with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_range_var x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  begin match v.object_ with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  begin match v.extname with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 4 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.bool v.remove encoder;
  Pbrt.Encoder.key 5 Pbrt.Varint encoder; 
  ()

and encode_pb_alter_object_schema_stmt (v:alter_object_schema_stmt) encoder = 
  encode_pb_object_type v.object_type encoder;
  Pbrt.Encoder.key 1 Pbrt.Varint encoder; 
  begin match v.relation with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_range_var x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  begin match v.object_ with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.string v.newschema encoder;
  Pbrt.Encoder.key 4 Pbrt.Bytes encoder; 
  Pbrt.Encoder.bool v.missing_ok encoder;
  Pbrt.Encoder.key 5 Pbrt.Varint encoder; 
  ()

and encode_pb_alter_owner_stmt (v:alter_owner_stmt) encoder = 
  encode_pb_object_type v.object_type encoder;
  Pbrt.Encoder.key 1 Pbrt.Varint encoder; 
  begin match v.relation with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_range_var x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  begin match v.object_ with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  begin match v.newowner with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_role_spec x encoder;
    Pbrt.Encoder.key 4 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  ()

and encode_pb_alter_operator_stmt (v:alter_operator_stmt) encoder = 
  begin match v.opername with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_object_with_args x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  ) v.options encoder;
  ()

and encode_pb_alter_type_stmt (v:alter_type_stmt) encoder = 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  ) v.type_name encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  ) v.options encoder;
  ()

and encode_pb_drop_owned_stmt (v:drop_owned_stmt) encoder = 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  ) v.roles encoder;
  encode_pb_drop_behavior v.behavior encoder;
  Pbrt.Encoder.key 2 Pbrt.Varint encoder; 
  ()

and encode_pb_reassign_owned_stmt (v:reassign_owned_stmt) encoder = 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  ) v.roles encoder;
  begin match v.newrole with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_role_spec x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  ()

and encode_pb_composite_type_stmt (v:composite_type_stmt) encoder = 
  begin match v.typevar with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_range_var x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  ) v.coldeflist encoder;
  ()

and encode_pb_create_enum_stmt (v:create_enum_stmt) encoder = 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  ) v.type_name encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  ) v.vals encoder;
  ()

and encode_pb_create_range_stmt (v:create_range_stmt) encoder = 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  ) v.type_name encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  ) v.params encoder;
  ()

and encode_pb_alter_enum_stmt (v:alter_enum_stmt) encoder = 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  ) v.type_name encoder;
  Pbrt.Encoder.string v.old_val encoder;
  Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  Pbrt.Encoder.string v.new_val encoder;
  Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  Pbrt.Encoder.string v.new_val_neighbor encoder;
  Pbrt.Encoder.key 4 Pbrt.Bytes encoder; 
  Pbrt.Encoder.bool v.new_val_is_after encoder;
  Pbrt.Encoder.key 5 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.skip_if_new_val_exists encoder;
  Pbrt.Encoder.key 6 Pbrt.Varint encoder; 
  ()

and encode_pb_alter_tsdictionary_stmt (v:alter_tsdictionary_stmt) encoder = 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  ) v.dictname encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  ) v.options encoder;
  ()

and encode_pb_alter_tsconfiguration_stmt (v:alter_tsconfiguration_stmt) encoder = 
  encode_pb_alter_tsconfig_type v.kind encoder;
  Pbrt.Encoder.key 1 Pbrt.Varint encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  ) v.cfgname encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  ) v.tokentype encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 4 Pbrt.Bytes encoder; 
  ) v.dicts encoder;
  Pbrt.Encoder.bool v.override encoder;
  Pbrt.Encoder.key 5 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.replace encoder;
  Pbrt.Encoder.key 6 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.missing_ok encoder;
  Pbrt.Encoder.key 7 Pbrt.Varint encoder; 
  ()

and encode_pb_create_fdw_stmt (v:create_fdw_stmt) encoder = 
  Pbrt.Encoder.string v.fdwname encoder;
  Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  ) v.func_options encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  ) v.options encoder;
  ()

and encode_pb_alter_fdw_stmt (v:alter_fdw_stmt) encoder = 
  Pbrt.Encoder.string v.fdwname encoder;
  Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  ) v.func_options encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  ) v.options encoder;
  ()

and encode_pb_create_foreign_server_stmt (v:create_foreign_server_stmt) encoder = 
  Pbrt.Encoder.string v.servername encoder;
  Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  Pbrt.Encoder.string v.servertype encoder;
  Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  Pbrt.Encoder.string v.version encoder;
  Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  Pbrt.Encoder.string v.fdwname encoder;
  Pbrt.Encoder.key 4 Pbrt.Bytes encoder; 
  Pbrt.Encoder.bool v.if_not_exists encoder;
  Pbrt.Encoder.key 5 Pbrt.Varint encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 6 Pbrt.Bytes encoder; 
  ) v.options encoder;
  ()

and encode_pb_alter_foreign_server_stmt (v:alter_foreign_server_stmt) encoder = 
  Pbrt.Encoder.string v.servername encoder;
  Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  Pbrt.Encoder.string v.version encoder;
  Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  ) v.options encoder;
  Pbrt.Encoder.bool v.has_version encoder;
  Pbrt.Encoder.key 4 Pbrt.Varint encoder; 
  ()

and encode_pb_create_user_mapping_stmt (v:create_user_mapping_stmt) encoder = 
  begin match v.user with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_role_spec x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.string v.servername encoder;
  Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  Pbrt.Encoder.bool v.if_not_exists encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 4 Pbrt.Bytes encoder; 
  ) v.options encoder;
  ()

and encode_pb_alter_user_mapping_stmt (v:alter_user_mapping_stmt) encoder = 
  begin match v.user with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_role_spec x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.string v.servername encoder;
  Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  ) v.options encoder;
  ()

and encode_pb_alter_table_space_options_stmt (v:alter_table_space_options_stmt) encoder = 
  Pbrt.Encoder.string v.tablespacename encoder;
  Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  ) v.options encoder;
  Pbrt.Encoder.bool v.is_reset encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  ()

and encode_pb_alter_table_move_all_stmt (v:alter_table_move_all_stmt) encoder = 
  Pbrt.Encoder.string v.orig_tablespacename encoder;
  Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  encode_pb_object_type v.objtype encoder;
  Pbrt.Encoder.key 2 Pbrt.Varint encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  ) v.roles encoder;
  Pbrt.Encoder.string v.new_tablespacename encoder;
  Pbrt.Encoder.key 4 Pbrt.Bytes encoder; 
  Pbrt.Encoder.bool v.nowait encoder;
  Pbrt.Encoder.key 5 Pbrt.Varint encoder; 
  ()

and encode_pb_sec_label_stmt (v:sec_label_stmt) encoder = 
  encode_pb_object_type v.objtype encoder;
  Pbrt.Encoder.key 1 Pbrt.Varint encoder; 
  begin match v.object_ with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.string v.provider encoder;
  Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  Pbrt.Encoder.string v.label encoder;
  Pbrt.Encoder.key 4 Pbrt.Bytes encoder; 
  ()

and encode_pb_create_foreign_table_stmt (v:create_foreign_table_stmt) encoder = 
  begin match v.base_stmt with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_create_stmt x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.string v.servername encoder;
  Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  ) v.options encoder;
  ()

and encode_pb_import_foreign_schema_stmt (v:import_foreign_schema_stmt) encoder = 
  Pbrt.Encoder.string v.server_name encoder;
  Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  Pbrt.Encoder.string v.remote_schema encoder;
  Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  Pbrt.Encoder.string v.local_schema encoder;
  Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  encode_pb_import_foreign_schema_type v.list_type encoder;
  Pbrt.Encoder.key 4 Pbrt.Varint encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 5 Pbrt.Bytes encoder; 
  ) v.table_list encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 6 Pbrt.Bytes encoder; 
  ) v.options encoder;
  ()

and encode_pb_create_extension_stmt (v:create_extension_stmt) encoder = 
  Pbrt.Encoder.string v.extname encoder;
  Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  Pbrt.Encoder.bool v.if_not_exists encoder;
  Pbrt.Encoder.key 2 Pbrt.Varint encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  ) v.options encoder;
  ()

and encode_pb_alter_extension_stmt (v:alter_extension_stmt) encoder = 
  Pbrt.Encoder.string v.extname encoder;
  Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  ) v.options encoder;
  ()

and encode_pb_alter_extension_contents_stmt (v:alter_extension_contents_stmt) encoder = 
  Pbrt.Encoder.string v.extname encoder;
  Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  Pbrt.Encoder.int32_as_varint v.action encoder;
  Pbrt.Encoder.key 2 Pbrt.Varint encoder; 
  encode_pb_object_type v.objtype encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  begin match v.object_ with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 4 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  ()

and encode_pb_create_event_trig_stmt (v:create_event_trig_stmt) encoder = 
  Pbrt.Encoder.string v.trigname encoder;
  Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  Pbrt.Encoder.string v.eventname encoder;
  Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  ) v.whenclause encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 4 Pbrt.Bytes encoder; 
  ) v.funcname encoder;
  ()

and encode_pb_refresh_mat_view_stmt (v:refresh_mat_view_stmt) encoder = 
  Pbrt.Encoder.bool v.concurrent encoder;
  Pbrt.Encoder.key 1 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.skip_data encoder;
  Pbrt.Encoder.key 2 Pbrt.Varint encoder; 
  begin match v.relation with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_range_var x encoder;
    Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  ()

and encode_pb_alter_system_stmt (v:alter_system_stmt) encoder = 
  begin match v.setstmt with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_variable_set_stmt x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  ()

and encode_pb_create_policy_stmt (v:create_policy_stmt) encoder = 
  Pbrt.Encoder.string v.policy_name encoder;
  Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  begin match v.table with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_range_var x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.string v.cmd_name encoder;
  Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  Pbrt.Encoder.bool v.permissive encoder;
  Pbrt.Encoder.key 4 Pbrt.Varint encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 5 Pbrt.Bytes encoder; 
  ) v.roles encoder;
  begin match v.qual with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 6 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  begin match v.with_check with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 7 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  ()

and encode_pb_alter_policy_stmt (v:alter_policy_stmt) encoder = 
  Pbrt.Encoder.string v.policy_name encoder;
  Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  begin match v.table with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_range_var x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  ) v.roles encoder;
  begin match v.qual with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 4 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  begin match v.with_check with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 5 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  ()

and encode_pb_create_transform_stmt (v:create_transform_stmt) encoder = 
  Pbrt.Encoder.bool v.replace encoder;
  Pbrt.Encoder.key 1 Pbrt.Varint encoder; 
  begin match v.type_name with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_type_name x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.string v.lang encoder;
  Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  begin match v.fromsql with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_object_with_args x encoder;
    Pbrt.Encoder.key 4 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  begin match v.tosql with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_object_with_args x encoder;
    Pbrt.Encoder.key 5 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  ()

and encode_pb_create_am_stmt (v:create_am_stmt) encoder = 
  Pbrt.Encoder.string v.amname encoder;
  Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  ) v.handler_name encoder;
  Pbrt.Encoder.string v.amtype encoder;
  Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  ()

and encode_pb_create_publication_stmt (v:create_publication_stmt) encoder = 
  Pbrt.Encoder.string v.pubname encoder;
  Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  ) v.options encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  ) v.tables encoder;
  Pbrt.Encoder.bool v.for_all_tables encoder;
  Pbrt.Encoder.key 4 Pbrt.Varint encoder; 
  ()

and encode_pb_alter_publication_stmt (v:alter_publication_stmt) encoder = 
  Pbrt.Encoder.string v.pubname encoder;
  Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  ) v.options encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  ) v.tables encoder;
  Pbrt.Encoder.bool v.for_all_tables encoder;
  Pbrt.Encoder.key 4 Pbrt.Varint encoder; 
  encode_pb_def_elem_action v.table_action encoder;
  Pbrt.Encoder.key 5 Pbrt.Varint encoder; 
  ()

and encode_pb_create_subscription_stmt (v:create_subscription_stmt) encoder = 
  Pbrt.Encoder.string v.subname encoder;
  Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  Pbrt.Encoder.string v.conninfo encoder;
  Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  ) v.publication encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 4 Pbrt.Bytes encoder; 
  ) v.options encoder;
  ()

and encode_pb_alter_subscription_stmt (v:alter_subscription_stmt) encoder = 
  encode_pb_alter_subscription_type v.kind encoder;
  Pbrt.Encoder.key 1 Pbrt.Varint encoder; 
  Pbrt.Encoder.string v.subname encoder;
  Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  Pbrt.Encoder.string v.conninfo encoder;
  Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 4 Pbrt.Bytes encoder; 
  ) v.publication encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 5 Pbrt.Bytes encoder; 
  ) v.options encoder;
  ()

and encode_pb_create_stats_stmt (v:create_stats_stmt) encoder = 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  ) v.defnames encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  ) v.stat_types encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  ) v.exprs encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 4 Pbrt.Bytes encoder; 
  ) v.relations encoder;
  Pbrt.Encoder.string v.stxcomment encoder;
  Pbrt.Encoder.key 5 Pbrt.Bytes encoder; 
  Pbrt.Encoder.bool v.if_not_exists encoder;
  Pbrt.Encoder.key 6 Pbrt.Varint encoder; 
  ()

and encode_pb_alter_collation_stmt (v:alter_collation_stmt) encoder = 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  ) v.collname encoder;
  ()

and encode_pb_call_stmt (v:call_stmt) encoder = 
  begin match v.funccall with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_func_call x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  begin match v.funcexpr with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_func_expr x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  ()

and encode_pb_func_call (v:func_call) encoder = 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  ) v.funcname encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  ) v.args encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  ) v.agg_order encoder;
  begin match v.agg_filter with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 4 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.bool v.agg_within_group encoder;
  Pbrt.Encoder.key 5 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.agg_star encoder;
  Pbrt.Encoder.key 6 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.agg_distinct encoder;
  Pbrt.Encoder.key 7 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.func_variadic encoder;
  Pbrt.Encoder.key 8 Pbrt.Varint encoder; 
  begin match v.over with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_window_def x encoder;
    Pbrt.Encoder.key 9 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.int32_as_varint v.location encoder;
  Pbrt.Encoder.key 10 Pbrt.Varint encoder; 
  ()

and encode_pb_window_def (v:window_def) encoder = 
  Pbrt.Encoder.string v.name encoder;
  Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  Pbrt.Encoder.string v.refname encoder;
  Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  ) v.partition_clause encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 4 Pbrt.Bytes encoder; 
  ) v.order_clause encoder;
  Pbrt.Encoder.int32_as_varint v.frame_options encoder;
  Pbrt.Encoder.key 5 Pbrt.Varint encoder; 
  begin match v.start_offset with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 6 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  begin match v.end_offset with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 7 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.int32_as_varint v.location encoder;
  Pbrt.Encoder.key 8 Pbrt.Varint encoder; 
  ()

and encode_pb_alter_stats_stmt (v:alter_stats_stmt) encoder = 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  ) v.defnames encoder;
  Pbrt.Encoder.int32_as_varint v.stxstattarget encoder;
  Pbrt.Encoder.key 2 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.missing_ok encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  ()

and encode_pb_a_expr (v:a_expr) encoder = 
  encode_pb_a_expr_kind v.kind encoder;
  Pbrt.Encoder.key 1 Pbrt.Varint encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  ) v.name encoder;
  begin match v.lexpr with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  begin match v.rexpr with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 4 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.int32_as_varint v.location encoder;
  Pbrt.Encoder.key 5 Pbrt.Varint encoder; 
  ()

and encode_pb_column_ref (v:column_ref) encoder = 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  ) v.fields encoder;
  Pbrt.Encoder.int32_as_varint v.location encoder;
  Pbrt.Encoder.key 2 Pbrt.Varint encoder; 
  ()

and encode_pb_a_const (v:a_const) encoder = 
  begin match v.val_ with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.int32_as_varint v.location encoder;
  Pbrt.Encoder.key 2 Pbrt.Varint encoder; 
  ()

and encode_pb_a_indices (v:a_indices) encoder = 
  Pbrt.Encoder.bool v.is_slice encoder;
  Pbrt.Encoder.key 1 Pbrt.Varint encoder; 
  begin match v.lidx with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  begin match v.uidx with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  ()

and encode_pb_a_indirection (v:a_indirection) encoder = 
  begin match v.arg with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  ) v.indirection encoder;
  ()

and encode_pb_a_array_expr (v:a_array_expr) encoder = 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  ) v.elements encoder;
  Pbrt.Encoder.int32_as_varint v.location encoder;
  Pbrt.Encoder.key 2 Pbrt.Varint encoder; 
  ()

and encode_pb_res_target (v:res_target) encoder = 
  Pbrt.Encoder.string v.name encoder;
  Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  ) v.indirection encoder;
  begin match v.val_ with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.int32_as_varint v.location encoder;
  Pbrt.Encoder.key 4 Pbrt.Varint encoder; 
  ()

and encode_pb_multi_assign_ref (v:multi_assign_ref) encoder = 
  begin match v.source with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.int32_as_varint v.colno encoder;
  Pbrt.Encoder.key 2 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.ncolumns encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  ()

and encode_pb_type_cast (v:type_cast) encoder = 
  begin match v.arg with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  begin match v.type_name with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_type_name x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.int32_as_varint v.location encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  ()

and encode_pb_sort_by (v:sort_by) encoder = 
  begin match v.node with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  encode_pb_sort_by_dir v.sortby_dir encoder;
  Pbrt.Encoder.key 2 Pbrt.Varint encoder; 
  encode_pb_sort_by_nulls v.sortby_nulls encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 4 Pbrt.Bytes encoder; 
  ) v.use_op encoder;
  Pbrt.Encoder.int32_as_varint v.location encoder;
  Pbrt.Encoder.key 5 Pbrt.Varint encoder; 
  ()

and encode_pb_range_subselect (v:range_subselect) encoder = 
  Pbrt.Encoder.bool v.lateral encoder;
  Pbrt.Encoder.key 1 Pbrt.Varint encoder; 
  begin match v.subquery with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  begin match v.alias with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_alias x encoder;
    Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  ()

and encode_pb_range_function (v:range_function) encoder = 
  Pbrt.Encoder.bool v.lateral encoder;
  Pbrt.Encoder.key 1 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.ordinality encoder;
  Pbrt.Encoder.key 2 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.is_rowsfrom encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 4 Pbrt.Bytes encoder; 
  ) v.functions encoder;
  begin match v.alias with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_alias x encoder;
    Pbrt.Encoder.key 5 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 6 Pbrt.Bytes encoder; 
  ) v.coldeflist encoder;
  ()

and encode_pb_range_table_sample (v:range_table_sample) encoder = 
  begin match v.relation with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  ) v.method_ encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  ) v.args encoder;
  begin match v.repeatable with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 4 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.int32_as_varint v.location encoder;
  Pbrt.Encoder.key 5 Pbrt.Varint encoder; 
  ()

and encode_pb_range_table_func (v:range_table_func) encoder = 
  Pbrt.Encoder.bool v.lateral encoder;
  Pbrt.Encoder.key 1 Pbrt.Varint encoder; 
  begin match v.docexpr with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  begin match v.rowexpr with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 4 Pbrt.Bytes encoder; 
  ) v.namespaces encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 5 Pbrt.Bytes encoder; 
  ) v.columns encoder;
  begin match v.alias with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_alias x encoder;
    Pbrt.Encoder.key 6 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.int32_as_varint v.location encoder;
  Pbrt.Encoder.key 7 Pbrt.Varint encoder; 
  ()

and encode_pb_range_table_func_col (v:range_table_func_col) encoder = 
  Pbrt.Encoder.string v.colname encoder;
  Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  begin match v.type_name with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_type_name x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.bool v.for_ordinality encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.is_not_null encoder;
  Pbrt.Encoder.key 4 Pbrt.Varint encoder; 
  begin match v.colexpr with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 5 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  begin match v.coldefexpr with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 6 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.int32_as_varint v.location encoder;
  Pbrt.Encoder.key 7 Pbrt.Varint encoder; 
  ()

and encode_pb_column_def (v:column_def) encoder = 
  Pbrt.Encoder.string v.colname encoder;
  Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  begin match v.type_name with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_type_name x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.int32_as_varint v.inhcount encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.is_local encoder;
  Pbrt.Encoder.key 4 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.is_not_null encoder;
  Pbrt.Encoder.key 5 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.is_from_type encoder;
  Pbrt.Encoder.key 6 Pbrt.Varint encoder; 
  Pbrt.Encoder.string v.storage encoder;
  Pbrt.Encoder.key 7 Pbrt.Bytes encoder; 
  begin match v.raw_default with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 8 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  begin match v.cooked_default with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 9 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.string v.identity encoder;
  Pbrt.Encoder.key 10 Pbrt.Bytes encoder; 
  begin match v.identity_sequence with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_range_var x encoder;
    Pbrt.Encoder.key 11 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.string v.generated encoder;
  Pbrt.Encoder.key 12 Pbrt.Bytes encoder; 
  begin match v.coll_clause with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_collate_clause x encoder;
    Pbrt.Encoder.key 13 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.int32_as_varint v.coll_oid encoder;
  Pbrt.Encoder.key 14 Pbrt.Varint encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 15 Pbrt.Bytes encoder; 
  ) v.constraints encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 16 Pbrt.Bytes encoder; 
  ) v.fdwoptions encoder;
  Pbrt.Encoder.int32_as_varint v.location encoder;
  Pbrt.Encoder.key 17 Pbrt.Varint encoder; 
  ()

and encode_pb_index_elem (v:index_elem) encoder = 
  Pbrt.Encoder.string v.name encoder;
  Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  begin match v.expr with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.string v.indexcolname encoder;
  Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 4 Pbrt.Bytes encoder; 
  ) v.collation encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 5 Pbrt.Bytes encoder; 
  ) v.opclass encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 6 Pbrt.Bytes encoder; 
  ) v.opclassopts encoder;
  encode_pb_sort_by_dir v.ordering encoder;
  Pbrt.Encoder.key 7 Pbrt.Varint encoder; 
  encode_pb_sort_by_nulls v.nulls_ordering encoder;
  Pbrt.Encoder.key 8 Pbrt.Varint encoder; 
  ()

and encode_pb_constraint_ (v:constraint_) encoder = 
  encode_pb_constr_type v.contype encoder;
  Pbrt.Encoder.key 1 Pbrt.Varint encoder; 
  Pbrt.Encoder.string v.conname encoder;
  Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  Pbrt.Encoder.bool v.deferrable encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.initdeferred encoder;
  Pbrt.Encoder.key 4 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.location encoder;
  Pbrt.Encoder.key 5 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.is_no_inherit encoder;
  Pbrt.Encoder.key 6 Pbrt.Varint encoder; 
  begin match v.raw_expr with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 7 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.string v.cooked_expr encoder;
  Pbrt.Encoder.key 8 Pbrt.Bytes encoder; 
  Pbrt.Encoder.string v.generated_when encoder;
  Pbrt.Encoder.key 9 Pbrt.Bytes encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 10 Pbrt.Bytes encoder; 
  ) v.keys encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 11 Pbrt.Bytes encoder; 
  ) v.including encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 12 Pbrt.Bytes encoder; 
  ) v.exclusions encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 13 Pbrt.Bytes encoder; 
  ) v.options encoder;
  Pbrt.Encoder.string v.indexname encoder;
  Pbrt.Encoder.key 14 Pbrt.Bytes encoder; 
  Pbrt.Encoder.string v.indexspace encoder;
  Pbrt.Encoder.key 15 Pbrt.Bytes encoder; 
  Pbrt.Encoder.bool v.reset_default_tblspc encoder;
  Pbrt.Encoder.key 16 Pbrt.Varint encoder; 
  Pbrt.Encoder.string v.access_method encoder;
  Pbrt.Encoder.key 17 Pbrt.Bytes encoder; 
  begin match v.where_clause with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 18 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  begin match v.pktable with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_range_var x encoder;
    Pbrt.Encoder.key 19 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 20 Pbrt.Bytes encoder; 
  ) v.fk_attrs encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 21 Pbrt.Bytes encoder; 
  ) v.pk_attrs encoder;
  Pbrt.Encoder.string v.fk_matchtype encoder;
  Pbrt.Encoder.key 22 Pbrt.Bytes encoder; 
  Pbrt.Encoder.string v.fk_upd_action encoder;
  Pbrt.Encoder.key 23 Pbrt.Bytes encoder; 
  Pbrt.Encoder.string v.fk_del_action encoder;
  Pbrt.Encoder.key 24 Pbrt.Bytes encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 25 Pbrt.Bytes encoder; 
  ) v.old_conpfeqop encoder;
  Pbrt.Encoder.int32_as_varint v.old_pktable_oid encoder;
  Pbrt.Encoder.key 26 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.skip_validation encoder;
  Pbrt.Encoder.key 27 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.initially_valid encoder;
  Pbrt.Encoder.key 28 Pbrt.Varint encoder; 
  ()

and encode_pb_def_elem (v:def_elem) encoder = 
  Pbrt.Encoder.string v.defnamespace encoder;
  Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  Pbrt.Encoder.string v.defname encoder;
  Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  begin match v.arg with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  encode_pb_def_elem_action v.defaction encoder;
  Pbrt.Encoder.key 4 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.location encoder;
  Pbrt.Encoder.key 5 Pbrt.Varint encoder; 
  ()

and encode_pb_range_tbl_entry (v:range_tbl_entry) encoder = 
  encode_pb_rtekind v.rtekind encoder;
  Pbrt.Encoder.key 1 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.relid encoder;
  Pbrt.Encoder.key 2 Pbrt.Varint encoder; 
  Pbrt.Encoder.string v.relkind encoder;
  Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  Pbrt.Encoder.int32_as_varint v.rellockmode encoder;
  Pbrt.Encoder.key 4 Pbrt.Varint encoder; 
  begin match v.tablesample with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_table_sample_clause x encoder;
    Pbrt.Encoder.key 5 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  begin match v.subquery with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_query x encoder;
    Pbrt.Encoder.key 6 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.bool v.security_barrier encoder;
  Pbrt.Encoder.key 7 Pbrt.Varint encoder; 
  encode_pb_join_type v.jointype encoder;
  Pbrt.Encoder.key 8 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.joinmergedcols encoder;
  Pbrt.Encoder.key 9 Pbrt.Varint encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 10 Pbrt.Bytes encoder; 
  ) v.joinaliasvars encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 11 Pbrt.Bytes encoder; 
  ) v.joinleftcols encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 12 Pbrt.Bytes encoder; 
  ) v.joinrightcols encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 13 Pbrt.Bytes encoder; 
  ) v.functions encoder;
  Pbrt.Encoder.bool v.funcordinality encoder;
  Pbrt.Encoder.key 14 Pbrt.Varint encoder; 
  begin match v.tablefunc with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_table_func x encoder;
    Pbrt.Encoder.key 15 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 16 Pbrt.Bytes encoder; 
  ) v.values_lists encoder;
  Pbrt.Encoder.string v.ctename encoder;
  Pbrt.Encoder.key 17 Pbrt.Bytes encoder; 
  Pbrt.Encoder.int32_as_varint v.ctelevelsup encoder;
  Pbrt.Encoder.key 18 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.self_reference encoder;
  Pbrt.Encoder.key 19 Pbrt.Varint encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 20 Pbrt.Bytes encoder; 
  ) v.coltypes encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 21 Pbrt.Bytes encoder; 
  ) v.coltypmods encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 22 Pbrt.Bytes encoder; 
  ) v.colcollations encoder;
  Pbrt.Encoder.string v.enrname encoder;
  Pbrt.Encoder.key 23 Pbrt.Bytes encoder; 
  Pbrt.Encoder.float_as_bits64 v.enrtuples encoder;
  Pbrt.Encoder.key 24 Pbrt.Bits64 encoder; 
  begin match v.alias with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_alias x encoder;
    Pbrt.Encoder.key 25 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  begin match v.eref with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_alias x encoder;
    Pbrt.Encoder.key 26 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.bool v.lateral encoder;
  Pbrt.Encoder.key 27 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.inh encoder;
  Pbrt.Encoder.key 28 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.in_from_cl encoder;
  Pbrt.Encoder.key 29 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.required_perms encoder;
  Pbrt.Encoder.key 30 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.check_as_user encoder;
  Pbrt.Encoder.key 31 Pbrt.Varint encoder; 
  Pbrt.Encoder.nested (fun lst encoder ->
    Pbrt.List_util.rev_iter_with (fun x encoder -> 
      Pbrt.Encoder.int64_as_varint x encoder;
    ) lst encoder;
  ) v.selected_cols encoder;
  Pbrt.Encoder.key 32 Pbrt.Bytes encoder; 
  Pbrt.Encoder.nested (fun lst encoder ->
    Pbrt.List_util.rev_iter_with (fun x encoder -> 
      Pbrt.Encoder.int64_as_varint x encoder;
    ) lst encoder;
  ) v.inserted_cols encoder;
  Pbrt.Encoder.key 33 Pbrt.Bytes encoder; 
  Pbrt.Encoder.nested (fun lst encoder ->
    Pbrt.List_util.rev_iter_with (fun x encoder -> 
      Pbrt.Encoder.int64_as_varint x encoder;
    ) lst encoder;
  ) v.updated_cols encoder;
  Pbrt.Encoder.key 34 Pbrt.Bytes encoder; 
  Pbrt.Encoder.nested (fun lst encoder ->
    Pbrt.List_util.rev_iter_with (fun x encoder -> 
      Pbrt.Encoder.int64_as_varint x encoder;
    ) lst encoder;
  ) v.extra_updated_cols encoder;
  Pbrt.Encoder.key 35 Pbrt.Bytes encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 36 Pbrt.Bytes encoder; 
  ) v.security_quals encoder;
  ()

and encode_pb_table_sample_clause (v:table_sample_clause) encoder = 
  Pbrt.Encoder.int32_as_varint v.tsmhandler encoder;
  Pbrt.Encoder.key 1 Pbrt.Varint encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  ) v.args encoder;
  begin match v.repeatable with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  ()

and encode_pb_range_tbl_function (v:range_tbl_function) encoder = 
  begin match v.funcexpr with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.int32_as_varint v.funccolcount encoder;
  Pbrt.Encoder.key 2 Pbrt.Varint encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  ) v.funccolnames encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 4 Pbrt.Bytes encoder; 
  ) v.funccoltypes encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 5 Pbrt.Bytes encoder; 
  ) v.funccoltypmods encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 6 Pbrt.Bytes encoder; 
  ) v.funccolcollations encoder;
  Pbrt.Encoder.nested (fun lst encoder ->
    Pbrt.List_util.rev_iter_with (fun x encoder -> 
      Pbrt.Encoder.int64_as_varint x encoder;
    ) lst encoder;
  ) v.funcparams encoder;
  Pbrt.Encoder.key 7 Pbrt.Bytes encoder; 
  ()

and encode_pb_with_check_option (v:with_check_option) encoder = 
  encode_pb_wcokind v.kind encoder;
  Pbrt.Encoder.key 1 Pbrt.Varint encoder; 
  Pbrt.Encoder.string v.relname encoder;
  Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  Pbrt.Encoder.string v.polname encoder;
  Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  begin match v.qual with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 4 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.bool v.cascaded encoder;
  Pbrt.Encoder.key 5 Pbrt.Varint encoder; 
  ()

and encode_pb_grouping_set (v:grouping_set) encoder = 
  encode_pb_grouping_set_kind v.kind encoder;
  Pbrt.Encoder.key 1 Pbrt.Varint encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  ) v.content encoder;
  Pbrt.Encoder.int32_as_varint v.location encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  ()

and encode_pb_window_clause (v:window_clause) encoder = 
  Pbrt.Encoder.string v.name encoder;
  Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  Pbrt.Encoder.string v.refname encoder;
  Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  ) v.partition_clause encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 4 Pbrt.Bytes encoder; 
  ) v.order_clause encoder;
  Pbrt.Encoder.int32_as_varint v.frame_options encoder;
  Pbrt.Encoder.key 5 Pbrt.Varint encoder; 
  begin match v.start_offset with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 6 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  begin match v.end_offset with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 7 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.int32_as_varint v.start_in_range_func encoder;
  Pbrt.Encoder.key 8 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.end_in_range_func encoder;
  Pbrt.Encoder.key 9 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.in_range_coll encoder;
  Pbrt.Encoder.key 10 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.in_range_asc encoder;
  Pbrt.Encoder.key 11 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.in_range_nulls_first encoder;
  Pbrt.Encoder.key 12 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.winref encoder;
  Pbrt.Encoder.key 13 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.copied_order encoder;
  Pbrt.Encoder.key 14 Pbrt.Varint encoder; 
  ()

and encode_pb_access_priv (v:access_priv) encoder = 
  Pbrt.Encoder.string v.priv_name encoder;
  Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  ) v.cols encoder;
  ()

and encode_pb_create_op_class_item (v:create_op_class_item) encoder = 
  Pbrt.Encoder.int32_as_varint v.itemtype encoder;
  Pbrt.Encoder.key 1 Pbrt.Varint encoder; 
  begin match v.name with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_object_with_args x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.int32_as_varint v.number encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 4 Pbrt.Bytes encoder; 
  ) v.order_family encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 5 Pbrt.Bytes encoder; 
  ) v.class_args encoder;
  begin match v.storedtype with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_type_name x encoder;
    Pbrt.Encoder.key 6 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  ()

and encode_pb_table_like_clause (v:table_like_clause) encoder = 
  begin match v.relation with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_range_var x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.int32_as_varint v.options encoder;
  Pbrt.Encoder.key 2 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.relation_oid encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  ()

and encode_pb_function_parameter (v:function_parameter) encoder = 
  Pbrt.Encoder.string v.name encoder;
  Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  begin match v.arg_type with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_type_name x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  encode_pb_function_parameter_mode v.mode encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  begin match v.defexpr with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 4 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  ()

and encode_pb_locking_clause (v:locking_clause) encoder = 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  ) v.locked_rels encoder;
  encode_pb_lock_clause_strength v.strength encoder;
  Pbrt.Encoder.key 2 Pbrt.Varint encoder; 
  encode_pb_lock_wait_policy v.wait_policy encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  ()

and encode_pb_xml_serialize (v:xml_serialize) encoder = 
  encode_pb_xml_option_type v.xmloption encoder;
  Pbrt.Encoder.key 1 Pbrt.Varint encoder; 
  begin match v.expr with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  begin match v.type_name with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_type_name x encoder;
    Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.int32_as_varint v.location encoder;
  Pbrt.Encoder.key 4 Pbrt.Varint encoder; 
  ()

and encode_pb_common_table_expr (v:common_table_expr) encoder = 
  Pbrt.Encoder.string v.ctename encoder;
  Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  ) v.aliascolnames encoder;
  encode_pb_ctematerialize v.ctematerialized encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  begin match v.ctequery with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 4 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.int32_as_varint v.location encoder;
  Pbrt.Encoder.key 5 Pbrt.Varint encoder; 
  Pbrt.Encoder.bool v.cterecursive encoder;
  Pbrt.Encoder.key 6 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.cterefcount encoder;
  Pbrt.Encoder.key 7 Pbrt.Varint encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 8 Pbrt.Bytes encoder; 
  ) v.ctecolnames encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 9 Pbrt.Bytes encoder; 
  ) v.ctecoltypes encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 10 Pbrt.Bytes encoder; 
  ) v.ctecoltypmods encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 11 Pbrt.Bytes encoder; 
  ) v.ctecolcollations encoder;
  ()

and encode_pb_partition_elem (v:partition_elem) encoder = 
  Pbrt.Encoder.string v.name encoder;
  Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  begin match v.expr with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  ) v.collation encoder;
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 4 Pbrt.Bytes encoder; 
  ) v.opclass encoder;
  Pbrt.Encoder.int32_as_varint v.location encoder;
  Pbrt.Encoder.key 5 Pbrt.Varint encoder; 
  ()

and encode_pb_partition_range_datum (v:partition_range_datum) encoder = 
  encode_pb_partition_range_datum_kind v.kind encoder;
  Pbrt.Encoder.key 1 Pbrt.Varint encoder; 
  begin match v.value with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.int32_as_varint v.location encoder;
  Pbrt.Encoder.key 3 Pbrt.Varint encoder; 
  ()

and encode_pb_partition_cmd (v:partition_cmd) encoder = 
  begin match v.name with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_range_var x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  begin match v.bound with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_partition_bound_spec x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  ()

and encode_pb_vacuum_relation (v:vacuum_relation) encoder = 
  begin match v.relation with
  | Some x -> 
    Pbrt.Encoder.nested encode_pb_range_var x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  | None -> ();
  end;
  Pbrt.Encoder.int32_as_varint v.oid encoder;
  Pbrt.Encoder.key 2 Pbrt.Varint encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 3 Pbrt.Bytes encoder; 
  ) v.va_cols encoder;
  ()

and encode_pb_pglist (v:pglist) encoder = 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  ) v.items encoder;
  ()

and encode_pb_int_list (v:int_list) encoder = 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  ) v.items encoder;
  ()

and encode_pb_oid_list (v:oid_list) encoder = 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_node x encoder;
    Pbrt.Encoder.key 1 Pbrt.Bytes encoder; 
  ) v.items encoder;
  ()

let rec encode_pb_parse_result (v:parse_result) encoder = 
  Pbrt.Encoder.int32_as_varint v.version encoder;
  Pbrt.Encoder.key 1 Pbrt.Varint encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_raw_stmt x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  ) v.stmts encoder;
  ()

let rec encode_pb_token (v:token) encoder =
  match v with
  | Nul -> Pbrt.Encoder.int_as_varint (0) encoder
  | Ascii_37 -> Pbrt.Encoder.int_as_varint 37 encoder
  | Ascii_40 -> Pbrt.Encoder.int_as_varint 40 encoder
  | Ascii_41 -> Pbrt.Encoder.int_as_varint 41 encoder
  | Ascii_42 -> Pbrt.Encoder.int_as_varint 42 encoder
  | Ascii_43 -> Pbrt.Encoder.int_as_varint 43 encoder
  | Ascii_44 -> Pbrt.Encoder.int_as_varint 44 encoder
  | Ascii_45 -> Pbrt.Encoder.int_as_varint 45 encoder
  | Ascii_46 -> Pbrt.Encoder.int_as_varint 46 encoder
  | Ascii_47 -> Pbrt.Encoder.int_as_varint 47 encoder
  | Ascii_58 -> Pbrt.Encoder.int_as_varint 58 encoder
  | Ascii_59 -> Pbrt.Encoder.int_as_varint 59 encoder
  | Ascii_60 -> Pbrt.Encoder.int_as_varint 60 encoder
  | Ascii_61 -> Pbrt.Encoder.int_as_varint 61 encoder
  | Ascii_62 -> Pbrt.Encoder.int_as_varint 62 encoder
  | Ascii_63 -> Pbrt.Encoder.int_as_varint 63 encoder
  | Ascii_91 -> Pbrt.Encoder.int_as_varint 91 encoder
  | Ascii_92 -> Pbrt.Encoder.int_as_varint 92 encoder
  | Ascii_93 -> Pbrt.Encoder.int_as_varint 93 encoder
  | Ascii_94 -> Pbrt.Encoder.int_as_varint 94 encoder
  | Ident -> Pbrt.Encoder.int_as_varint 258 encoder
  | Uident -> Pbrt.Encoder.int_as_varint 259 encoder
  | Fconst -> Pbrt.Encoder.int_as_varint 260 encoder
  | Sconst -> Pbrt.Encoder.int_as_varint 261 encoder
  | Usconst -> Pbrt.Encoder.int_as_varint 262 encoder
  | Bconst -> Pbrt.Encoder.int_as_varint 263 encoder
  | Xconst -> Pbrt.Encoder.int_as_varint 264 encoder
  | Op -> Pbrt.Encoder.int_as_varint 265 encoder
  | Iconst -> Pbrt.Encoder.int_as_varint 266 encoder
  | Param -> Pbrt.Encoder.int_as_varint 267 encoder
  | Typecast -> Pbrt.Encoder.int_as_varint 268 encoder
  | Dot_dot -> Pbrt.Encoder.int_as_varint 269 encoder
  | Colon_equals -> Pbrt.Encoder.int_as_varint 270 encoder
  | Equals_greater -> Pbrt.Encoder.int_as_varint 271 encoder
  | Less_equals -> Pbrt.Encoder.int_as_varint 272 encoder
  | Greater_equals -> Pbrt.Encoder.int_as_varint 273 encoder
  | Not_equals -> Pbrt.Encoder.int_as_varint 274 encoder
  | Sql_comment -> Pbrt.Encoder.int_as_varint 275 encoder
  | C_comment -> Pbrt.Encoder.int_as_varint 276 encoder
  | Abort_p -> Pbrt.Encoder.int_as_varint 277 encoder
  | Absolute_p -> Pbrt.Encoder.int_as_varint 278 encoder
  | Access -> Pbrt.Encoder.int_as_varint 279 encoder
  | Action -> Pbrt.Encoder.int_as_varint 280 encoder
  | Add_p -> Pbrt.Encoder.int_as_varint 281 encoder
  | Admin -> Pbrt.Encoder.int_as_varint 282 encoder
  | After -> Pbrt.Encoder.int_as_varint 283 encoder
  | Aggregate -> Pbrt.Encoder.int_as_varint 284 encoder
  | All -> Pbrt.Encoder.int_as_varint 285 encoder
  | Also -> Pbrt.Encoder.int_as_varint 286 encoder
  | Alter -> Pbrt.Encoder.int_as_varint 287 encoder
  | Always -> Pbrt.Encoder.int_as_varint 288 encoder
  | Analyse -> Pbrt.Encoder.int_as_varint 289 encoder
  | Analyze -> Pbrt.Encoder.int_as_varint 290 encoder
  | And -> Pbrt.Encoder.int_as_varint 291 encoder
  | Any -> Pbrt.Encoder.int_as_varint 292 encoder
  | Array -> Pbrt.Encoder.int_as_varint 293 encoder
  | As -> Pbrt.Encoder.int_as_varint 294 encoder
  | Asc -> Pbrt.Encoder.int_as_varint 295 encoder
  | Assertion -> Pbrt.Encoder.int_as_varint 296 encoder
  | Assignment -> Pbrt.Encoder.int_as_varint 297 encoder
  | Asymmetric -> Pbrt.Encoder.int_as_varint 298 encoder
  | At -> Pbrt.Encoder.int_as_varint 299 encoder
  | Attach -> Pbrt.Encoder.int_as_varint 300 encoder
  | Attribute -> Pbrt.Encoder.int_as_varint 301 encoder
  | Authorization -> Pbrt.Encoder.int_as_varint 302 encoder
  | Backward -> Pbrt.Encoder.int_as_varint 303 encoder
  | Before -> Pbrt.Encoder.int_as_varint 304 encoder
  | Begin_p -> Pbrt.Encoder.int_as_varint 305 encoder
  | Between -> Pbrt.Encoder.int_as_varint 306 encoder
  | Bigint -> Pbrt.Encoder.int_as_varint 307 encoder
  | Binary -> Pbrt.Encoder.int_as_varint 308 encoder
  | Bit -> Pbrt.Encoder.int_as_varint 309 encoder
  | Boolean_p -> Pbrt.Encoder.int_as_varint 310 encoder
  | Both -> Pbrt.Encoder.int_as_varint 311 encoder
  | By -> Pbrt.Encoder.int_as_varint 312 encoder
  | Cache -> Pbrt.Encoder.int_as_varint 313 encoder
  | Call -> Pbrt.Encoder.int_as_varint 314 encoder
  | Called -> Pbrt.Encoder.int_as_varint 315 encoder
  | Cascade -> Pbrt.Encoder.int_as_varint 316 encoder
  | Cascaded -> Pbrt.Encoder.int_as_varint 317 encoder
  | Case -> Pbrt.Encoder.int_as_varint 318 encoder
  | Cast -> Pbrt.Encoder.int_as_varint 319 encoder
  | Catalog_p -> Pbrt.Encoder.int_as_varint 320 encoder
  | Chain -> Pbrt.Encoder.int_as_varint 321 encoder
  | Char_p -> Pbrt.Encoder.int_as_varint 322 encoder
  | Character -> Pbrt.Encoder.int_as_varint 323 encoder
  | Characteristics -> Pbrt.Encoder.int_as_varint 324 encoder
  | Check -> Pbrt.Encoder.int_as_varint 325 encoder
  | Checkpoint -> Pbrt.Encoder.int_as_varint 326 encoder
  | Class -> Pbrt.Encoder.int_as_varint 327 encoder
  | Close -> Pbrt.Encoder.int_as_varint 328 encoder
  | Cluster -> Pbrt.Encoder.int_as_varint 329 encoder
  | Coalesce -> Pbrt.Encoder.int_as_varint 330 encoder
  | Collate -> Pbrt.Encoder.int_as_varint 331 encoder
  | Collation -> Pbrt.Encoder.int_as_varint 332 encoder
  | Column -> Pbrt.Encoder.int_as_varint 333 encoder
  | Columns -> Pbrt.Encoder.int_as_varint 334 encoder
  | Comment -> Pbrt.Encoder.int_as_varint 335 encoder
  | Comments -> Pbrt.Encoder.int_as_varint 336 encoder
  | Commit -> Pbrt.Encoder.int_as_varint 337 encoder
  | Committed -> Pbrt.Encoder.int_as_varint 338 encoder
  | Concurrently -> Pbrt.Encoder.int_as_varint 339 encoder
  | Configuration -> Pbrt.Encoder.int_as_varint 340 encoder
  | Conflict -> Pbrt.Encoder.int_as_varint 341 encoder
  | Connection -> Pbrt.Encoder.int_as_varint 342 encoder
  | Constraint -> Pbrt.Encoder.int_as_varint 343 encoder
  | Constraints -> Pbrt.Encoder.int_as_varint 344 encoder
  | Content_p -> Pbrt.Encoder.int_as_varint 345 encoder
  | Continue_p -> Pbrt.Encoder.int_as_varint 346 encoder
  | Conversion_p -> Pbrt.Encoder.int_as_varint 347 encoder
  | Copy -> Pbrt.Encoder.int_as_varint 348 encoder
  | Cost -> Pbrt.Encoder.int_as_varint 349 encoder
  | Create -> Pbrt.Encoder.int_as_varint 350 encoder
  | Cross -> Pbrt.Encoder.int_as_varint 351 encoder
  | Csv -> Pbrt.Encoder.int_as_varint 352 encoder
  | Cube -> Pbrt.Encoder.int_as_varint 353 encoder
  | Current_p -> Pbrt.Encoder.int_as_varint 354 encoder
  | Current_catalog -> Pbrt.Encoder.int_as_varint 355 encoder
  | Current_date -> Pbrt.Encoder.int_as_varint 356 encoder
  | Current_role -> Pbrt.Encoder.int_as_varint 357 encoder
  | Current_schema -> Pbrt.Encoder.int_as_varint 358 encoder
  | Current_time -> Pbrt.Encoder.int_as_varint 359 encoder
  | Current_timestamp -> Pbrt.Encoder.int_as_varint 360 encoder
  | Current_user -> Pbrt.Encoder.int_as_varint 361 encoder
  | Cursor -> Pbrt.Encoder.int_as_varint 362 encoder
  | Cycle -> Pbrt.Encoder.int_as_varint 363 encoder
  | Data_p -> Pbrt.Encoder.int_as_varint 364 encoder
  | Database -> Pbrt.Encoder.int_as_varint 365 encoder
  | Day_p -> Pbrt.Encoder.int_as_varint 366 encoder
  | Deallocate -> Pbrt.Encoder.int_as_varint 367 encoder
  | Dec -> Pbrt.Encoder.int_as_varint 368 encoder
  | Decimal_p -> Pbrt.Encoder.int_as_varint 369 encoder
  | Declare -> Pbrt.Encoder.int_as_varint 370 encoder
  | Default -> Pbrt.Encoder.int_as_varint 371 encoder
  | Defaults -> Pbrt.Encoder.int_as_varint 372 encoder
  | Deferrable -> Pbrt.Encoder.int_as_varint 373 encoder
  | Deferred -> Pbrt.Encoder.int_as_varint 374 encoder
  | Definer -> Pbrt.Encoder.int_as_varint 375 encoder
  | Delete_p -> Pbrt.Encoder.int_as_varint 376 encoder
  | Delimiter -> Pbrt.Encoder.int_as_varint 377 encoder
  | Delimiters -> Pbrt.Encoder.int_as_varint 378 encoder
  | Depends -> Pbrt.Encoder.int_as_varint 379 encoder
  | Desc -> Pbrt.Encoder.int_as_varint 380 encoder
  | Detach -> Pbrt.Encoder.int_as_varint 381 encoder
  | Dictionary -> Pbrt.Encoder.int_as_varint 382 encoder
  | Disable_p -> Pbrt.Encoder.int_as_varint 383 encoder
  | Discard -> Pbrt.Encoder.int_as_varint 384 encoder
  | Distinct -> Pbrt.Encoder.int_as_varint 385 encoder
  | Do -> Pbrt.Encoder.int_as_varint 386 encoder
  | Document_p -> Pbrt.Encoder.int_as_varint 387 encoder
  | Domain_p -> Pbrt.Encoder.int_as_varint 388 encoder
  | Double_p -> Pbrt.Encoder.int_as_varint 389 encoder
  | Drop -> Pbrt.Encoder.int_as_varint 390 encoder
  | Each -> Pbrt.Encoder.int_as_varint 391 encoder
  | Else -> Pbrt.Encoder.int_as_varint 392 encoder
  | Enable_p -> Pbrt.Encoder.int_as_varint 393 encoder
  | Encoding -> Pbrt.Encoder.int_as_varint 394 encoder
  | Encrypted -> Pbrt.Encoder.int_as_varint 395 encoder
  | End_p -> Pbrt.Encoder.int_as_varint 396 encoder
  | Enum_p -> Pbrt.Encoder.int_as_varint 397 encoder
  | Escape -> Pbrt.Encoder.int_as_varint 398 encoder
  | Event -> Pbrt.Encoder.int_as_varint 399 encoder
  | Except -> Pbrt.Encoder.int_as_varint 400 encoder
  | Exclude -> Pbrt.Encoder.int_as_varint 401 encoder
  | Excluding -> Pbrt.Encoder.int_as_varint 402 encoder
  | Exclusive -> Pbrt.Encoder.int_as_varint 403 encoder
  | Execute -> Pbrt.Encoder.int_as_varint 404 encoder
  | Exists -> Pbrt.Encoder.int_as_varint 405 encoder
  | Explain -> Pbrt.Encoder.int_as_varint 406 encoder
  | Expression -> Pbrt.Encoder.int_as_varint 407 encoder
  | Extension -> Pbrt.Encoder.int_as_varint 408 encoder
  | External -> Pbrt.Encoder.int_as_varint 409 encoder
  | Extract -> Pbrt.Encoder.int_as_varint 410 encoder
  | False_p -> Pbrt.Encoder.int_as_varint 411 encoder
  | Family -> Pbrt.Encoder.int_as_varint 412 encoder
  | Fetch -> Pbrt.Encoder.int_as_varint 413 encoder
  | Filter -> Pbrt.Encoder.int_as_varint 414 encoder
  | First_p -> Pbrt.Encoder.int_as_varint 415 encoder
  | Float_p -> Pbrt.Encoder.int_as_varint 416 encoder
  | Following -> Pbrt.Encoder.int_as_varint 417 encoder
  | For -> Pbrt.Encoder.int_as_varint 418 encoder
  | Force -> Pbrt.Encoder.int_as_varint 419 encoder
  | Foreign -> Pbrt.Encoder.int_as_varint 420 encoder
  | Forward -> Pbrt.Encoder.int_as_varint 421 encoder
  | Freeze -> Pbrt.Encoder.int_as_varint 422 encoder
  | From -> Pbrt.Encoder.int_as_varint 423 encoder
  | Full -> Pbrt.Encoder.int_as_varint 424 encoder
  | Function -> Pbrt.Encoder.int_as_varint 425 encoder
  | Functions -> Pbrt.Encoder.int_as_varint 426 encoder
  | Generated -> Pbrt.Encoder.int_as_varint 427 encoder
  | Global -> Pbrt.Encoder.int_as_varint 428 encoder
  | Grant -> Pbrt.Encoder.int_as_varint 429 encoder
  | Granted -> Pbrt.Encoder.int_as_varint 430 encoder
  | Greatest -> Pbrt.Encoder.int_as_varint 431 encoder
  | Group_p -> Pbrt.Encoder.int_as_varint 432 encoder
  | Grouping -> Pbrt.Encoder.int_as_varint 433 encoder
  | Groups -> Pbrt.Encoder.int_as_varint 434 encoder
  | Handler -> Pbrt.Encoder.int_as_varint 435 encoder
  | Having -> Pbrt.Encoder.int_as_varint 436 encoder
  | Header_p -> Pbrt.Encoder.int_as_varint 437 encoder
  | Hold -> Pbrt.Encoder.int_as_varint 438 encoder
  | Hour_p -> Pbrt.Encoder.int_as_varint 439 encoder
  | Identity_p -> Pbrt.Encoder.int_as_varint 440 encoder
  | If_p -> Pbrt.Encoder.int_as_varint 441 encoder
  | Ilike -> Pbrt.Encoder.int_as_varint 442 encoder
  | Immediate -> Pbrt.Encoder.int_as_varint 443 encoder
  | Immutable -> Pbrt.Encoder.int_as_varint 444 encoder
  | Implicit_p -> Pbrt.Encoder.int_as_varint 445 encoder
  | Import_p -> Pbrt.Encoder.int_as_varint 446 encoder
  | In_p -> Pbrt.Encoder.int_as_varint 447 encoder
  | Include -> Pbrt.Encoder.int_as_varint 448 encoder
  | Including -> Pbrt.Encoder.int_as_varint 449 encoder
  | Increment -> Pbrt.Encoder.int_as_varint 450 encoder
  | Index -> Pbrt.Encoder.int_as_varint 451 encoder
  | Indexes -> Pbrt.Encoder.int_as_varint 452 encoder
  | Inherit -> Pbrt.Encoder.int_as_varint 453 encoder
  | Inherits -> Pbrt.Encoder.int_as_varint 454 encoder
  | Initially -> Pbrt.Encoder.int_as_varint 455 encoder
  | Inline_p -> Pbrt.Encoder.int_as_varint 456 encoder
  | Inner_p -> Pbrt.Encoder.int_as_varint 457 encoder
  | Inout -> Pbrt.Encoder.int_as_varint 458 encoder
  | Input_p -> Pbrt.Encoder.int_as_varint 459 encoder
  | Insensitive -> Pbrt.Encoder.int_as_varint 460 encoder
  | Insert -> Pbrt.Encoder.int_as_varint 461 encoder
  | Instead -> Pbrt.Encoder.int_as_varint 462 encoder
  | Int_p -> Pbrt.Encoder.int_as_varint 463 encoder
  | Integer -> Pbrt.Encoder.int_as_varint 464 encoder
  | Intersect -> Pbrt.Encoder.int_as_varint 465 encoder
  | Interval -> Pbrt.Encoder.int_as_varint 466 encoder
  | Into -> Pbrt.Encoder.int_as_varint 467 encoder
  | Invoker -> Pbrt.Encoder.int_as_varint 468 encoder
  | Is -> Pbrt.Encoder.int_as_varint 469 encoder
  | Isnull -> Pbrt.Encoder.int_as_varint 470 encoder
  | Isolation -> Pbrt.Encoder.int_as_varint 471 encoder
  | Join -> Pbrt.Encoder.int_as_varint 472 encoder
  | Key -> Pbrt.Encoder.int_as_varint 473 encoder
  | Label -> Pbrt.Encoder.int_as_varint 474 encoder
  | Language -> Pbrt.Encoder.int_as_varint 475 encoder
  | Large_p -> Pbrt.Encoder.int_as_varint 476 encoder
  | Last_p -> Pbrt.Encoder.int_as_varint 477 encoder
  | Lateral_p -> Pbrt.Encoder.int_as_varint 478 encoder
  | Leading -> Pbrt.Encoder.int_as_varint 479 encoder
  | Leakproof -> Pbrt.Encoder.int_as_varint 480 encoder
  | Least -> Pbrt.Encoder.int_as_varint 481 encoder
  | Left -> Pbrt.Encoder.int_as_varint 482 encoder
  | Level -> Pbrt.Encoder.int_as_varint 483 encoder
  | Like -> Pbrt.Encoder.int_as_varint 484 encoder
  | Limit -> Pbrt.Encoder.int_as_varint 485 encoder
  | Listen -> Pbrt.Encoder.int_as_varint 486 encoder
  | Load -> Pbrt.Encoder.int_as_varint 487 encoder
  | Local -> Pbrt.Encoder.int_as_varint 488 encoder
  | Localtime -> Pbrt.Encoder.int_as_varint 489 encoder
  | Localtimestamp -> Pbrt.Encoder.int_as_varint 490 encoder
  | Location -> Pbrt.Encoder.int_as_varint 491 encoder
  | Lock_p -> Pbrt.Encoder.int_as_varint 492 encoder
  | Locked -> Pbrt.Encoder.int_as_varint 493 encoder
  | Logged -> Pbrt.Encoder.int_as_varint 494 encoder
  | Mapping -> Pbrt.Encoder.int_as_varint 495 encoder
  | Match -> Pbrt.Encoder.int_as_varint 496 encoder
  | Materialized -> Pbrt.Encoder.int_as_varint 497 encoder
  | Maxvalue -> Pbrt.Encoder.int_as_varint 498 encoder
  | Method -> Pbrt.Encoder.int_as_varint 499 encoder
  | Minute_p -> Pbrt.Encoder.int_as_varint 500 encoder
  | Minvalue -> Pbrt.Encoder.int_as_varint 501 encoder
  | Mode -> Pbrt.Encoder.int_as_varint 502 encoder
  | Month_p -> Pbrt.Encoder.int_as_varint 503 encoder
  | Move -> Pbrt.Encoder.int_as_varint 504 encoder
  | Name_p -> Pbrt.Encoder.int_as_varint 505 encoder
  | Names -> Pbrt.Encoder.int_as_varint 506 encoder
  | National -> Pbrt.Encoder.int_as_varint 507 encoder
  | Natural -> Pbrt.Encoder.int_as_varint 508 encoder
  | Nchar -> Pbrt.Encoder.int_as_varint 509 encoder
  | New -> Pbrt.Encoder.int_as_varint 510 encoder
  | Next -> Pbrt.Encoder.int_as_varint 511 encoder
  | Nfc -> Pbrt.Encoder.int_as_varint 512 encoder
  | Nfd -> Pbrt.Encoder.int_as_varint 513 encoder
  | Nfkc -> Pbrt.Encoder.int_as_varint 514 encoder
  | Nfkd -> Pbrt.Encoder.int_as_varint 515 encoder
  | No -> Pbrt.Encoder.int_as_varint 516 encoder
  | None -> Pbrt.Encoder.int_as_varint 517 encoder
  | Normalize -> Pbrt.Encoder.int_as_varint 518 encoder
  | Normalized -> Pbrt.Encoder.int_as_varint 519 encoder
  | Not -> Pbrt.Encoder.int_as_varint 520 encoder
  | Nothing -> Pbrt.Encoder.int_as_varint 521 encoder
  | Notify -> Pbrt.Encoder.int_as_varint 522 encoder
  | Notnull -> Pbrt.Encoder.int_as_varint 523 encoder
  | Nowait -> Pbrt.Encoder.int_as_varint 524 encoder
  | Null_p -> Pbrt.Encoder.int_as_varint 525 encoder
  | Nullif -> Pbrt.Encoder.int_as_varint 526 encoder
  | Nulls_p -> Pbrt.Encoder.int_as_varint 527 encoder
  | Numeric -> Pbrt.Encoder.int_as_varint 528 encoder
  | Object_p -> Pbrt.Encoder.int_as_varint 529 encoder
  | Of -> Pbrt.Encoder.int_as_varint 530 encoder
  | Off -> Pbrt.Encoder.int_as_varint 531 encoder
  | Offset -> Pbrt.Encoder.int_as_varint 532 encoder
  | Oids -> Pbrt.Encoder.int_as_varint 533 encoder
  | Old -> Pbrt.Encoder.int_as_varint 534 encoder
  | On -> Pbrt.Encoder.int_as_varint 535 encoder
  | Only -> Pbrt.Encoder.int_as_varint 536 encoder
  | Operator -> Pbrt.Encoder.int_as_varint 537 encoder
  | Option -> Pbrt.Encoder.int_as_varint 538 encoder
  | Options -> Pbrt.Encoder.int_as_varint 539 encoder
  | Or -> Pbrt.Encoder.int_as_varint 540 encoder
  | Order -> Pbrt.Encoder.int_as_varint 541 encoder
  | Ordinality -> Pbrt.Encoder.int_as_varint 542 encoder
  | Others -> Pbrt.Encoder.int_as_varint 543 encoder
  | Out_p -> Pbrt.Encoder.int_as_varint 544 encoder
  | Outer_p -> Pbrt.Encoder.int_as_varint 545 encoder
  | Over -> Pbrt.Encoder.int_as_varint 546 encoder
  | Overlaps -> Pbrt.Encoder.int_as_varint 547 encoder
  | Overlay -> Pbrt.Encoder.int_as_varint 548 encoder
  | Overriding -> Pbrt.Encoder.int_as_varint 549 encoder
  | Owned -> Pbrt.Encoder.int_as_varint 550 encoder
  | Owner -> Pbrt.Encoder.int_as_varint 551 encoder
  | Parallel -> Pbrt.Encoder.int_as_varint 552 encoder
  | Parser -> Pbrt.Encoder.int_as_varint 553 encoder
  | Partial -> Pbrt.Encoder.int_as_varint 554 encoder
  | Partition -> Pbrt.Encoder.int_as_varint 555 encoder
  | Passing -> Pbrt.Encoder.int_as_varint 556 encoder
  | Password -> Pbrt.Encoder.int_as_varint 557 encoder
  | Placing -> Pbrt.Encoder.int_as_varint 558 encoder
  | Plans -> Pbrt.Encoder.int_as_varint 559 encoder
  | Policy -> Pbrt.Encoder.int_as_varint 560 encoder
  | Position -> Pbrt.Encoder.int_as_varint 561 encoder
  | Preceding -> Pbrt.Encoder.int_as_varint 562 encoder
  | Precision -> Pbrt.Encoder.int_as_varint 563 encoder
  | Preserve -> Pbrt.Encoder.int_as_varint 564 encoder
  | Prepare -> Pbrt.Encoder.int_as_varint 565 encoder
  | Prepared -> Pbrt.Encoder.int_as_varint 566 encoder
  | Primary -> Pbrt.Encoder.int_as_varint 567 encoder
  | Prior -> Pbrt.Encoder.int_as_varint 568 encoder
  | Privileges -> Pbrt.Encoder.int_as_varint 569 encoder
  | Procedural -> Pbrt.Encoder.int_as_varint 570 encoder
  | Procedure -> Pbrt.Encoder.int_as_varint 571 encoder
  | Procedures -> Pbrt.Encoder.int_as_varint 572 encoder
  | Program -> Pbrt.Encoder.int_as_varint 573 encoder
  | Publication -> Pbrt.Encoder.int_as_varint 574 encoder
  | Quote -> Pbrt.Encoder.int_as_varint 575 encoder
  | Range -> Pbrt.Encoder.int_as_varint 576 encoder
  | Read -> Pbrt.Encoder.int_as_varint 577 encoder
  | Real -> Pbrt.Encoder.int_as_varint 578 encoder
  | Reassign -> Pbrt.Encoder.int_as_varint 579 encoder
  | Recheck -> Pbrt.Encoder.int_as_varint 580 encoder
  | Recursive -> Pbrt.Encoder.int_as_varint 581 encoder
  | Ref_p -> Pbrt.Encoder.int_as_varint 582 encoder
  | References -> Pbrt.Encoder.int_as_varint 583 encoder
  | Referencing -> Pbrt.Encoder.int_as_varint 584 encoder
  | Refresh -> Pbrt.Encoder.int_as_varint 585 encoder
  | Reindex -> Pbrt.Encoder.int_as_varint 586 encoder
  | Relative_p -> Pbrt.Encoder.int_as_varint 587 encoder
  | Release -> Pbrt.Encoder.int_as_varint 588 encoder
  | Rename -> Pbrt.Encoder.int_as_varint 589 encoder
  | Repeatable -> Pbrt.Encoder.int_as_varint 590 encoder
  | Replace -> Pbrt.Encoder.int_as_varint 591 encoder
  | Replica -> Pbrt.Encoder.int_as_varint 592 encoder
  | Reset -> Pbrt.Encoder.int_as_varint 593 encoder
  | Restart -> Pbrt.Encoder.int_as_varint 594 encoder
  | Restrict -> Pbrt.Encoder.int_as_varint 595 encoder
  | Returning -> Pbrt.Encoder.int_as_varint 596 encoder
  | Returns -> Pbrt.Encoder.int_as_varint 597 encoder
  | Revoke -> Pbrt.Encoder.int_as_varint 598 encoder
  | Right -> Pbrt.Encoder.int_as_varint 599 encoder
  | Role -> Pbrt.Encoder.int_as_varint 600 encoder
  | Rollback -> Pbrt.Encoder.int_as_varint 601 encoder
  | Rollup -> Pbrt.Encoder.int_as_varint 602 encoder
  | Routine -> Pbrt.Encoder.int_as_varint 603 encoder
  | Routines -> Pbrt.Encoder.int_as_varint 604 encoder
  | Row -> Pbrt.Encoder.int_as_varint 605 encoder
  | Rows -> Pbrt.Encoder.int_as_varint 606 encoder
  | Rule -> Pbrt.Encoder.int_as_varint 607 encoder
  | Savepoint -> Pbrt.Encoder.int_as_varint 608 encoder
  | Schema -> Pbrt.Encoder.int_as_varint 609 encoder
  | Schemas -> Pbrt.Encoder.int_as_varint 610 encoder
  | Scroll -> Pbrt.Encoder.int_as_varint 611 encoder
  | Search -> Pbrt.Encoder.int_as_varint 612 encoder
  | Second_p -> Pbrt.Encoder.int_as_varint 613 encoder
  | Security -> Pbrt.Encoder.int_as_varint 614 encoder
  | Select -> Pbrt.Encoder.int_as_varint 615 encoder
  | Sequence -> Pbrt.Encoder.int_as_varint 616 encoder
  | Sequences -> Pbrt.Encoder.int_as_varint 617 encoder
  | Serializable -> Pbrt.Encoder.int_as_varint 618 encoder
  | Server -> Pbrt.Encoder.int_as_varint 619 encoder
  | Session -> Pbrt.Encoder.int_as_varint 620 encoder
  | Session_user -> Pbrt.Encoder.int_as_varint 621 encoder
  | Set -> Pbrt.Encoder.int_as_varint 622 encoder
  | Sets -> Pbrt.Encoder.int_as_varint 623 encoder
  | Setof -> Pbrt.Encoder.int_as_varint 624 encoder
  | Share -> Pbrt.Encoder.int_as_varint 625 encoder
  | Show -> Pbrt.Encoder.int_as_varint 626 encoder
  | Similar -> Pbrt.Encoder.int_as_varint 627 encoder
  | Simple -> Pbrt.Encoder.int_as_varint 628 encoder
  | Skip -> Pbrt.Encoder.int_as_varint 629 encoder
  | Smallint -> Pbrt.Encoder.int_as_varint 630 encoder
  | Snapshot -> Pbrt.Encoder.int_as_varint 631 encoder
  | Some -> Pbrt.Encoder.int_as_varint 632 encoder
  | Sql_p -> Pbrt.Encoder.int_as_varint 633 encoder
  | Stable -> Pbrt.Encoder.int_as_varint 634 encoder
  | Standalone_p -> Pbrt.Encoder.int_as_varint 635 encoder
  | Start -> Pbrt.Encoder.int_as_varint 636 encoder
  | Statement -> Pbrt.Encoder.int_as_varint 637 encoder
  | Statistics -> Pbrt.Encoder.int_as_varint 638 encoder
  | Stdin -> Pbrt.Encoder.int_as_varint 639 encoder
  | Stdout -> Pbrt.Encoder.int_as_varint 640 encoder
  | Storage -> Pbrt.Encoder.int_as_varint 641 encoder
  | Stored -> Pbrt.Encoder.int_as_varint 642 encoder
  | Strict_p -> Pbrt.Encoder.int_as_varint 643 encoder
  | Strip_p -> Pbrt.Encoder.int_as_varint 644 encoder
  | Subscription -> Pbrt.Encoder.int_as_varint 645 encoder
  | Substring -> Pbrt.Encoder.int_as_varint 646 encoder
  | Support -> Pbrt.Encoder.int_as_varint 647 encoder
  | Symmetric -> Pbrt.Encoder.int_as_varint 648 encoder
  | Sysid -> Pbrt.Encoder.int_as_varint 649 encoder
  | System_p -> Pbrt.Encoder.int_as_varint 650 encoder
  | Table -> Pbrt.Encoder.int_as_varint 651 encoder
  | Tables -> Pbrt.Encoder.int_as_varint 652 encoder
  | Tablesample -> Pbrt.Encoder.int_as_varint 653 encoder
  | Tablespace -> Pbrt.Encoder.int_as_varint 654 encoder
  | Temp -> Pbrt.Encoder.int_as_varint 655 encoder
  | Template -> Pbrt.Encoder.int_as_varint 656 encoder
  | Temporary -> Pbrt.Encoder.int_as_varint 657 encoder
  | Text_p -> Pbrt.Encoder.int_as_varint 658 encoder
  | Then -> Pbrt.Encoder.int_as_varint 659 encoder
  | Ties -> Pbrt.Encoder.int_as_varint 660 encoder
  | Time -> Pbrt.Encoder.int_as_varint 661 encoder
  | Timestamp -> Pbrt.Encoder.int_as_varint 662 encoder
  | To -> Pbrt.Encoder.int_as_varint 663 encoder
  | Trailing -> Pbrt.Encoder.int_as_varint 664 encoder
  | Transaction -> Pbrt.Encoder.int_as_varint 665 encoder
  | Transform -> Pbrt.Encoder.int_as_varint 666 encoder
  | Treat -> Pbrt.Encoder.int_as_varint 667 encoder
  | Trigger -> Pbrt.Encoder.int_as_varint 668 encoder
  | Trim -> Pbrt.Encoder.int_as_varint 669 encoder
  | True_p -> Pbrt.Encoder.int_as_varint 670 encoder
  | Truncate -> Pbrt.Encoder.int_as_varint 671 encoder
  | Trusted -> Pbrt.Encoder.int_as_varint 672 encoder
  | Type_p -> Pbrt.Encoder.int_as_varint 673 encoder
  | Types_p -> Pbrt.Encoder.int_as_varint 674 encoder
  | Uescape -> Pbrt.Encoder.int_as_varint 675 encoder
  | Unbounded -> Pbrt.Encoder.int_as_varint 676 encoder
  | Uncommitted -> Pbrt.Encoder.int_as_varint 677 encoder
  | Unencrypted -> Pbrt.Encoder.int_as_varint 678 encoder
  | Union -> Pbrt.Encoder.int_as_varint 679 encoder
  | Unique -> Pbrt.Encoder.int_as_varint 680 encoder
  | Unknown -> Pbrt.Encoder.int_as_varint 681 encoder
  | Unlisten -> Pbrt.Encoder.int_as_varint 682 encoder
  | Unlogged -> Pbrt.Encoder.int_as_varint 683 encoder
  | Until -> Pbrt.Encoder.int_as_varint 684 encoder
  | Update -> Pbrt.Encoder.int_as_varint 685 encoder
  | User -> Pbrt.Encoder.int_as_varint 686 encoder
  | Using -> Pbrt.Encoder.int_as_varint 687 encoder
  | Vacuum -> Pbrt.Encoder.int_as_varint 688 encoder
  | Valid -> Pbrt.Encoder.int_as_varint 689 encoder
  | Validate -> Pbrt.Encoder.int_as_varint 690 encoder
  | Validator -> Pbrt.Encoder.int_as_varint 691 encoder
  | Value_p -> Pbrt.Encoder.int_as_varint 692 encoder
  | Values -> Pbrt.Encoder.int_as_varint 693 encoder
  | Varchar -> Pbrt.Encoder.int_as_varint 694 encoder
  | Variadic -> Pbrt.Encoder.int_as_varint 695 encoder
  | Varying -> Pbrt.Encoder.int_as_varint 696 encoder
  | Verbose -> Pbrt.Encoder.int_as_varint 697 encoder
  | Version_p -> Pbrt.Encoder.int_as_varint 698 encoder
  | View -> Pbrt.Encoder.int_as_varint 699 encoder
  | Views -> Pbrt.Encoder.int_as_varint 700 encoder
  | Volatile -> Pbrt.Encoder.int_as_varint 701 encoder
  | When -> Pbrt.Encoder.int_as_varint 702 encoder
  | Where -> Pbrt.Encoder.int_as_varint 703 encoder
  | Whitespace_p -> Pbrt.Encoder.int_as_varint 704 encoder
  | Window -> Pbrt.Encoder.int_as_varint 705 encoder
  | With -> Pbrt.Encoder.int_as_varint 706 encoder
  | Within -> Pbrt.Encoder.int_as_varint 707 encoder
  | Without -> Pbrt.Encoder.int_as_varint 708 encoder
  | Work -> Pbrt.Encoder.int_as_varint 709 encoder
  | Wrapper -> Pbrt.Encoder.int_as_varint 710 encoder
  | Write -> Pbrt.Encoder.int_as_varint 711 encoder
  | Xml_p -> Pbrt.Encoder.int_as_varint 712 encoder
  | Xmlattributes -> Pbrt.Encoder.int_as_varint 713 encoder
  | Xmlconcat -> Pbrt.Encoder.int_as_varint 714 encoder
  | Xmlelement -> Pbrt.Encoder.int_as_varint 715 encoder
  | Xmlexists -> Pbrt.Encoder.int_as_varint 716 encoder
  | Xmlforest -> Pbrt.Encoder.int_as_varint 717 encoder
  | Xmlnamespaces -> Pbrt.Encoder.int_as_varint 718 encoder
  | Xmlparse -> Pbrt.Encoder.int_as_varint 719 encoder
  | Xmlpi -> Pbrt.Encoder.int_as_varint 720 encoder
  | Xmlroot -> Pbrt.Encoder.int_as_varint 721 encoder
  | Xmlserialize -> Pbrt.Encoder.int_as_varint 722 encoder
  | Xmltable -> Pbrt.Encoder.int_as_varint 723 encoder
  | Year_p -> Pbrt.Encoder.int_as_varint 724 encoder
  | Yes_p -> Pbrt.Encoder.int_as_varint 725 encoder
  | Zone -> Pbrt.Encoder.int_as_varint 726 encoder
  | Not_la -> Pbrt.Encoder.int_as_varint 727 encoder
  | Nulls_la -> Pbrt.Encoder.int_as_varint 728 encoder
  | With_la -> Pbrt.Encoder.int_as_varint 729 encoder
  | Postfixop -> Pbrt.Encoder.int_as_varint 730 encoder
  | Uminus -> Pbrt.Encoder.int_as_varint 731 encoder

let rec encode_pb_keyword_kind (v:keyword_kind) encoder =
  match v with
  | No_keyword -> Pbrt.Encoder.int_as_varint (0) encoder
  | Unreserved_keyword -> Pbrt.Encoder.int_as_varint 1 encoder
  | Col_name_keyword -> Pbrt.Encoder.int_as_varint 2 encoder
  | Type_func_name_keyword -> Pbrt.Encoder.int_as_varint 3 encoder
  | Reserved_keyword -> Pbrt.Encoder.int_as_varint 4 encoder

let rec encode_pb_scan_token (v:scan_token) encoder = 
  Pbrt.Encoder.int32_as_varint v.start encoder;
  Pbrt.Encoder.key 1 Pbrt.Varint encoder; 
  Pbrt.Encoder.int32_as_varint v.end_ encoder;
  Pbrt.Encoder.key 2 Pbrt.Varint encoder; 
  encode_pb_token v.token encoder;
  Pbrt.Encoder.key 4 Pbrt.Varint encoder; 
  encode_pb_keyword_kind v.keyword_kind encoder;
  Pbrt.Encoder.key 5 Pbrt.Varint encoder; 
  ()

let rec encode_pb_scan_result (v:scan_result) encoder = 
  Pbrt.Encoder.int32_as_varint v.version encoder;
  Pbrt.Encoder.key 1 Pbrt.Varint encoder; 
  Pbrt.List_util.rev_iter_with (fun x encoder -> 
    Pbrt.Encoder.nested encode_pb_scan_token x encoder;
    Pbrt.Encoder.key 2 Pbrt.Bytes encoder; 
  ) v.tokens encoder;
  ()

let rec encode_pb_table_like_option (v:table_like_option) encoder =
  match v with
  | Table_like_option_undefined -> Pbrt.Encoder.int_as_varint (0) encoder
  | Create_table_like_comments -> Pbrt.Encoder.int_as_varint 1 encoder
  | Create_table_like_constraints -> Pbrt.Encoder.int_as_varint 2 encoder
  | Create_table_like_defaults -> Pbrt.Encoder.int_as_varint 3 encoder
  | Create_table_like_generated -> Pbrt.Encoder.int_as_varint 4 encoder
  | Create_table_like_identity -> Pbrt.Encoder.int_as_varint 5 encoder
  | Create_table_like_indexes -> Pbrt.Encoder.int_as_varint 6 encoder
  | Create_table_like_statistics -> Pbrt.Encoder.int_as_varint 7 encoder
  | Create_table_like_storage -> Pbrt.Encoder.int_as_varint 8 encoder
  | Create_table_like_all -> Pbrt.Encoder.int_as_varint 9 encoder

let rec encode_pb_cluster_option (v:cluster_option) encoder =
  match v with
  | Cluster_option_undefined -> Pbrt.Encoder.int_as_varint (0) encoder
  | Cluopt_recheck -> Pbrt.Encoder.int_as_varint 1 encoder
  | Cluopt_verbose -> Pbrt.Encoder.int_as_varint 2 encoder

let rec encode_pb_agg_strategy (v:agg_strategy) encoder =
  match v with
  | Agg_strategy_undefined -> Pbrt.Encoder.int_as_varint (0) encoder
  | Agg_plain -> Pbrt.Encoder.int_as_varint 1 encoder
  | Agg_sorted -> Pbrt.Encoder.int_as_varint 2 encoder
  | Agg_hashed -> Pbrt.Encoder.int_as_varint 3 encoder
  | Agg_mixed -> Pbrt.Encoder.int_as_varint 4 encoder

let rec encode_pb_set_op_cmd (v:set_op_cmd) encoder =
  match v with
  | Set_op_cmd_undefined -> Pbrt.Encoder.int_as_varint (0) encoder
  | Setopcmd_intersect -> Pbrt.Encoder.int_as_varint 1 encoder
  | Setopcmd_intersect_all -> Pbrt.Encoder.int_as_varint 2 encoder
  | Setopcmd_except -> Pbrt.Encoder.int_as_varint 3 encoder
  | Setopcmd_except_all -> Pbrt.Encoder.int_as_varint 4 encoder

let rec encode_pb_set_op_strategy (v:set_op_strategy) encoder =
  match v with
  | Set_op_strategy_undefined -> Pbrt.Encoder.int_as_varint (0) encoder
  | Setop_sorted -> Pbrt.Encoder.int_as_varint 1 encoder
  | Setop_hashed -> Pbrt.Encoder.int_as_varint 2 encoder

let rec encode_pb_lock_tuple_mode (v:lock_tuple_mode) encoder =
  match v with
  | Lock_tuple_mode_undefined -> Pbrt.Encoder.int_as_varint (0) encoder
  | Lock_tuple_key_share -> Pbrt.Encoder.int_as_varint 1 encoder
  | Lock_tuple_share -> Pbrt.Encoder.int_as_varint 2 encoder
  | Lock_tuple_no_key_exclusive -> Pbrt.Encoder.int_as_varint 3 encoder
  | Lock_tuple_exclusive -> Pbrt.Encoder.int_as_varint 4 encoder

[@@@ocaml.warning "-27-30-39"]

(** {2 Protobuf Decoding} *)

let rec decode_pb_expr d =
  match Pbrt.Decoder.key d with
  | None -> ();
  | Some (_, pk) -> 
    Pbrt.Decoder.unexpected_payload "Unexpected fields in empty message(expr)" pk

let rec decode_pb_param_kind d = 
  match Pbrt.Decoder.int_as_varint d with
  | 0 -> (Param_kind_undefined:param_kind)
  | 1 -> (Param_extern:param_kind)
  | 2 -> (Param_exec:param_kind)
  | 3 -> (Param_sublink:param_kind)
  | 4 -> (Param_multiexpr:param_kind)
  | _ -> Pbrt.Decoder.malformed_variant "param_kind"

let rec decode_pb_agg_split d = 
  match Pbrt.Decoder.int_as_varint d with
  | 0 -> (Agg_split_undefined:agg_split)
  | 1 -> (Aggsplit_simple:agg_split)
  | 2 -> (Aggsplit_initial_serial:agg_split)
  | 3 -> (Aggsplit_final_deserial:agg_split)
  | _ -> Pbrt.Decoder.malformed_variant "agg_split"

let rec decode_pb_coercion_form d = 
  match Pbrt.Decoder.int_as_varint d with
  | 0 -> (Coercion_form_undefined:coercion_form)
  | 1 -> (Coerce_explicit_call:coercion_form)
  | 2 -> (Coerce_explicit_cast:coercion_form)
  | 3 -> (Coerce_implicit_cast:coercion_form)
  | _ -> Pbrt.Decoder.malformed_variant "coercion_form"

let rec decode_pb_bool_expr_type d = 
  match Pbrt.Decoder.int_as_varint d with
  | 0 -> (Bool_expr_type_undefined:bool_expr_type)
  | 1 -> (And_expr:bool_expr_type)
  | 2 -> (Or_expr:bool_expr_type)
  | 3 -> (Not_expr:bool_expr_type)
  | _ -> Pbrt.Decoder.malformed_variant "bool_expr_type"

let rec decode_pb_sub_link_type d = 
  match Pbrt.Decoder.int_as_varint d with
  | 0 -> (Sub_link_type_undefined:sub_link_type)
  | 1 -> (Exists_sublink:sub_link_type)
  | 2 -> (All_sublink:sub_link_type)
  | 3 -> (Any_sublink:sub_link_type)
  | 4 -> (Rowcompare_sublink:sub_link_type)
  | 5 -> (Expr_sublink:sub_link_type)
  | 6 -> (Multiexpr_sublink:sub_link_type)
  | 7 -> (Array_sublink:sub_link_type)
  | 8 -> (Cte_sublink:sub_link_type)
  | _ -> Pbrt.Decoder.malformed_variant "sub_link_type"

let rec decode_pb_row_compare_type d = 
  match Pbrt.Decoder.int_as_varint d with
  | 0 -> (Row_compare_type_undefined:row_compare_type)
  | 1 -> (Rowcompare_lt:row_compare_type)
  | 2 -> (Rowcompare_le:row_compare_type)
  | 3 -> (Rowcompare_eq:row_compare_type)
  | 4 -> (Rowcompare_ge:row_compare_type)
  | 5 -> (Rowcompare_gt:row_compare_type)
  | 6 -> (Rowcompare_ne:row_compare_type)
  | _ -> Pbrt.Decoder.malformed_variant "row_compare_type"

let rec decode_pb_min_max_op d = 
  match Pbrt.Decoder.int_as_varint d with
  | 0 -> (Min_max_op_undefined:min_max_op)
  | 1 -> (Is_greatest:min_max_op)
  | 2 -> (Is_least:min_max_op)
  | _ -> Pbrt.Decoder.malformed_variant "min_max_op"

let rec decode_pb_sqlvalue_function_op d = 
  match Pbrt.Decoder.int_as_varint d with
  | 0 -> (Sqlvalue_function_op_undefined:sqlvalue_function_op)
  | 1 -> (Svfop_current_date:sqlvalue_function_op)
  | 2 -> (Svfop_current_time:sqlvalue_function_op)
  | 3 -> (Svfop_current_time_n:sqlvalue_function_op)
  | 4 -> (Svfop_current_timestamp:sqlvalue_function_op)
  | 5 -> (Svfop_current_timestamp_n:sqlvalue_function_op)
  | 6 -> (Svfop_localtime:sqlvalue_function_op)
  | 7 -> (Svfop_localtime_n:sqlvalue_function_op)
  | 8 -> (Svfop_localtimestamp:sqlvalue_function_op)
  | 9 -> (Svfop_localtimestamp_n:sqlvalue_function_op)
  | 10 -> (Svfop_current_role:sqlvalue_function_op)
  | 11 -> (Svfop_current_user:sqlvalue_function_op)
  | 12 -> (Svfop_user:sqlvalue_function_op)
  | 13 -> (Svfop_session_user:sqlvalue_function_op)
  | 14 -> (Svfop_current_catalog:sqlvalue_function_op)
  | 15 -> (Svfop_current_schema:sqlvalue_function_op)
  | _ -> Pbrt.Decoder.malformed_variant "sqlvalue_function_op"

let rec decode_pb_xml_expr_op d = 
  match Pbrt.Decoder.int_as_varint d with
  | 0 -> (Xml_expr_op_undefined:xml_expr_op)
  | 1 -> (Is_xmlconcat:xml_expr_op)
  | 2 -> (Is_xmlelement:xml_expr_op)
  | 3 -> (Is_xmlforest:xml_expr_op)
  | 4 -> (Is_xmlparse:xml_expr_op)
  | 5 -> (Is_xmlpi:xml_expr_op)
  | 6 -> (Is_xmlroot:xml_expr_op)
  | 7 -> (Is_xmlserialize:xml_expr_op)
  | 8 -> (Is_document:xml_expr_op)
  | _ -> Pbrt.Decoder.malformed_variant "xml_expr_op"

let rec decode_pb_xml_option_type d = 
  match Pbrt.Decoder.int_as_varint d with
  | 0 -> (Xml_option_type_undefined:xml_option_type)
  | 1 -> (Xmloption_document:xml_option_type)
  | 2 -> (Xmloption_content:xml_option_type)
  | _ -> Pbrt.Decoder.malformed_variant "xml_option_type"

let rec decode_pb_null_test_type d = 
  match Pbrt.Decoder.int_as_varint d with
  | 0 -> (Null_test_type_undefined:null_test_type)
  | 1 -> (Is_null:null_test_type)
  | 2 -> (Is_not_null:null_test_type)
  | _ -> Pbrt.Decoder.malformed_variant "null_test_type"

let rec decode_pb_bool_test_type d = 
  match Pbrt.Decoder.int_as_varint d with
  | 0 -> (Bool_test_type_undefined:bool_test_type)
  | 1 -> (Is_true:bool_test_type)
  | 2 -> (Is_not_true:bool_test_type)
  | 3 -> (Is_false:bool_test_type)
  | 4 -> (Is_not_false:bool_test_type)
  | 5 -> (Is_unknown:bool_test_type)
  | 6 -> (Is_not_unknown:bool_test_type)
  | _ -> Pbrt.Decoder.malformed_variant "bool_test_type"

let rec decode_pb_range_tbl_ref d =
  let v = default_range_tbl_ref_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Varint) -> begin
      v.rtindex <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_tbl_ref), field(1)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    rtindex = v.rtindex;
  } : range_tbl_ref)

let rec decode_pb_join_type d = 
  match Pbrt.Decoder.int_as_varint d with
  | 0 -> (Join_type_undefined:join_type)
  | 1 -> (Join_inner:join_type)
  | 2 -> (Join_left:join_type)
  | 3 -> (Join_full:join_type)
  | 4 -> (Join_right:join_type)
  | 5 -> (Join_semi:join_type)
  | 6 -> (Join_anti:join_type)
  | 7 -> (Join_unique_outer:join_type)
  | 8 -> (Join_unique_inner:join_type)
  | _ -> Pbrt.Decoder.malformed_variant "join_type"

let rec decode_pb_on_conflict_action d = 
  match Pbrt.Decoder.int_as_varint d with
  | 0 -> (On_conflict_action_undefined:on_conflict_action)
  | 1 -> (Onconflict_none:on_conflict_action)
  | 2 -> (Onconflict_nothing:on_conflict_action)
  | 3 -> (Onconflict_update:on_conflict_action)
  | _ -> Pbrt.Decoder.malformed_variant "on_conflict_action"

let rec decode_pb_on_commit_action d = 
  match Pbrt.Decoder.int_as_varint d with
  | 0 -> (On_commit_action_undefined:on_commit_action)
  | 1 -> (Oncommit_noop:on_commit_action)
  | 2 -> (Oncommit_preserve_rows:on_commit_action)
  | 3 -> (Oncommit_delete_rows:on_commit_action)
  | 4 -> (Oncommit_drop:on_commit_action)
  | _ -> Pbrt.Decoder.malformed_variant "on_commit_action"

let rec decode_pb_cmd_type d = 
  match Pbrt.Decoder.int_as_varint d with
  | 0 -> (Cmd_type_undefined:cmd_type)
  | 1 -> (Cmd_unknown:cmd_type)
  | 2 -> (Cmd_select:cmd_type)
  | 3 -> (Cmd_update:cmd_type)
  | 4 -> (Cmd_insert:cmd_type)
  | 5 -> (Cmd_delete:cmd_type)
  | 6 -> (Cmd_utility:cmd_type)
  | 7 -> (Cmd_nothing:cmd_type)
  | _ -> Pbrt.Decoder.malformed_variant "cmd_type"

let rec decode_pb_query_source d = 
  match Pbrt.Decoder.int_as_varint d with
  | 0 -> (Query_source_undefined:query_source)
  | 1 -> (Qsrc_original:query_source)
  | 2 -> (Qsrc_parser:query_source)
  | 3 -> (Qsrc_instead_rule:query_source)
  | 4 -> (Qsrc_qual_instead_rule:query_source)
  | 5 -> (Qsrc_non_instead_rule:query_source)
  | _ -> Pbrt.Decoder.malformed_variant "query_source"

let rec decode_pb_overriding_kind d = 
  match Pbrt.Decoder.int_as_varint d with
  | 0 -> (Overriding_kind_undefined:overriding_kind)
  | 1 -> (Overriding_not_set:overriding_kind)
  | 2 -> (Overriding_user_value:overriding_kind)
  | 3 -> (Overriding_system_value:overriding_kind)
  | _ -> Pbrt.Decoder.malformed_variant "overriding_kind"

let rec decode_pb_limit_option d = 
  match Pbrt.Decoder.int_as_varint d with
  | 0 -> (Limit_option_undefined:limit_option)
  | 1 -> (Limit_option_default:limit_option)
  | 2 -> (Limit_option_count:limit_option)
  | 3 -> (Limit_option_with_ties:limit_option)
  | _ -> Pbrt.Decoder.malformed_variant "limit_option"

let rec decode_pb_set_operation d = 
  match Pbrt.Decoder.int_as_varint d with
  | 0 -> (Set_operation_undefined:set_operation)
  | 1 -> (Setop_none:set_operation)
  | 2 -> (Setop_union:set_operation)
  | 3 -> (Setop_intersect:set_operation)
  | 4 -> (Setop_except:set_operation)
  | _ -> Pbrt.Decoder.malformed_variant "set_operation"

let rec decode_pb_object_type d = 
  match Pbrt.Decoder.int_as_varint d with
  | 0 -> (Object_type_undefined:object_type)
  | 1 -> (Object_access_method:object_type)
  | 2 -> (Object_aggregate:object_type)
  | 3 -> (Object_amop:object_type)
  | 4 -> (Object_amproc:object_type)
  | 5 -> (Object_attribute:object_type)
  | 6 -> (Object_cast:object_type)
  | 7 -> (Object_column:object_type)
  | 8 -> (Object_collation:object_type)
  | 9 -> (Object_conversion:object_type)
  | 10 -> (Object_database:object_type)
  | 11 -> (Object_default:object_type)
  | 12 -> (Object_defacl:object_type)
  | 13 -> (Object_domain:object_type)
  | 14 -> (Object_domconstraint:object_type)
  | 15 -> (Object_event_trigger:object_type)
  | 16 -> (Object_extension:object_type)
  | 17 -> (Object_fdw:object_type)
  | 18 -> (Object_foreign_server:object_type)
  | 19 -> (Object_foreign_table:object_type)
  | 20 -> (Object_function:object_type)
  | 21 -> (Object_index:object_type)
  | 22 -> (Object_language:object_type)
  | 23 -> (Object_largeobject:object_type)
  | 24 -> (Object_matview:object_type)
  | 25 -> (Object_opclass:object_type)
  | 26 -> (Object_operator:object_type)
  | 27 -> (Object_opfamily:object_type)
  | 28 -> (Object_policy:object_type)
  | 29 -> (Object_procedure:object_type)
  | 30 -> (Object_publication:object_type)
  | 31 -> (Object_publication_rel:object_type)
  | 32 -> (Object_role:object_type)
  | 33 -> (Object_routine:object_type)
  | 34 -> (Object_rule:object_type)
  | 35 -> (Object_schema:object_type)
  | 36 -> (Object_sequence:object_type)
  | 37 -> (Object_subscription:object_type)
  | 38 -> (Object_statistic_ext:object_type)
  | 39 -> (Object_tabconstraint:object_type)
  | 40 -> (Object_table:object_type)
  | 41 -> (Object_tablespace:object_type)
  | 42 -> (Object_transform:object_type)
  | 43 -> (Object_trigger:object_type)
  | 44 -> (Object_tsconfiguration:object_type)
  | 45 -> (Object_tsdictionary:object_type)
  | 46 -> (Object_tsparser:object_type)
  | 47 -> (Object_tstemplate:object_type)
  | 48 -> (Object_type:object_type)
  | 49 -> (Object_user_mapping:object_type)
  | 50 -> (Object_view:object_type)
  | _ -> Pbrt.Decoder.malformed_variant "object_type"

let rec decode_pb_alter_table_type d = 
  match Pbrt.Decoder.int_as_varint d with
  | 0 -> (Alter_table_type_undefined:alter_table_type)
  | 1 -> (At_add_column:alter_table_type)
  | 2 -> (At_add_column_recurse:alter_table_type)
  | 3 -> (At_add_column_to_view:alter_table_type)
  | 4 -> (At_column_default:alter_table_type)
  | 5 -> (At_cooked_column_default:alter_table_type)
  | 6 -> (At_drop_not_null:alter_table_type)
  | 7 -> (At_set_not_null:alter_table_type)
  | 8 -> (At_drop_expression:alter_table_type)
  | 9 -> (At_check_not_null:alter_table_type)
  | 10 -> (At_set_statistics:alter_table_type)
  | 11 -> (At_set_options:alter_table_type)
  | 12 -> (At_reset_options:alter_table_type)
  | 13 -> (At_set_storage:alter_table_type)
  | 14 -> (At_drop_column:alter_table_type)
  | 15 -> (At_drop_column_recurse:alter_table_type)
  | 16 -> (At_add_index:alter_table_type)
  | 17 -> (At_re_add_index:alter_table_type)
  | 18 -> (At_add_constraint:alter_table_type)
  | 19 -> (At_add_constraint_recurse:alter_table_type)
  | 20 -> (At_re_add_constraint:alter_table_type)
  | 21 -> (At_re_add_domain_constraint:alter_table_type)
  | 22 -> (At_alter_constraint:alter_table_type)
  | 23 -> (At_validate_constraint:alter_table_type)
  | 24 -> (At_validate_constraint_recurse:alter_table_type)
  | 25 -> (At_add_index_constraint:alter_table_type)
  | 26 -> (At_drop_constraint:alter_table_type)
  | 27 -> (At_drop_constraint_recurse:alter_table_type)
  | 28 -> (At_re_add_comment:alter_table_type)
  | 29 -> (At_alter_column_type:alter_table_type)
  | 30 -> (At_alter_column_generic_options:alter_table_type)
  | 31 -> (At_change_owner:alter_table_type)
  | 32 -> (At_cluster_on:alter_table_type)
  | 33 -> (At_drop_cluster:alter_table_type)
  | 34 -> (At_set_logged:alter_table_type)
  | 35 -> (At_set_un_logged:alter_table_type)
  | 36 -> (At_drop_oids:alter_table_type)
  | 37 -> (At_set_table_space:alter_table_type)
  | 38 -> (At_set_rel_options:alter_table_type)
  | 39 -> (At_reset_rel_options:alter_table_type)
  | 40 -> (At_replace_rel_options:alter_table_type)
  | 41 -> (At_enable_trig:alter_table_type)
  | 42 -> (At_enable_always_trig:alter_table_type)
  | 43 -> (At_enable_replica_trig:alter_table_type)
  | 44 -> (At_disable_trig:alter_table_type)
  | 45 -> (At_enable_trig_all:alter_table_type)
  | 46 -> (At_disable_trig_all:alter_table_type)
  | 47 -> (At_enable_trig_user:alter_table_type)
  | 48 -> (At_disable_trig_user:alter_table_type)
  | 49 -> (At_enable_rule:alter_table_type)
  | 50 -> (At_enable_always_rule:alter_table_type)
  | 51 -> (At_enable_replica_rule:alter_table_type)
  | 52 -> (At_disable_rule:alter_table_type)
  | 53 -> (At_add_inherit:alter_table_type)
  | 54 -> (At_drop_inherit:alter_table_type)
  | 55 -> (At_add_of:alter_table_type)
  | 56 -> (At_drop_of:alter_table_type)
  | 57 -> (At_replica_identity:alter_table_type)
  | 58 -> (At_enable_row_security:alter_table_type)
  | 59 -> (At_disable_row_security:alter_table_type)
  | 60 -> (At_force_row_security:alter_table_type)
  | 61 -> (At_no_force_row_security:alter_table_type)
  | 62 -> (At_generic_options:alter_table_type)
  | 63 -> (At_attach_partition:alter_table_type)
  | 64 -> (At_detach_partition:alter_table_type)
  | 65 -> (At_add_identity:alter_table_type)
  | 66 -> (At_set_identity:alter_table_type)
  | 67 -> (At_drop_identity:alter_table_type)
  | _ -> Pbrt.Decoder.malformed_variant "alter_table_type"

let rec decode_pb_role_spec_type d = 
  match Pbrt.Decoder.int_as_varint d with
  | 0 -> (Role_spec_type_undefined:role_spec_type)
  | 1 -> (Rolespec_cstring:role_spec_type)
  | 2 -> (Rolespec_current_user:role_spec_type)
  | 3 -> (Rolespec_session_user:role_spec_type)
  | 4 -> (Rolespec_public:role_spec_type)
  | _ -> Pbrt.Decoder.malformed_variant "role_spec_type"

let rec decode_pb_role_spec d =
  let v = default_role_spec_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Varint) -> begin
      v.roletype <- decode_pb_role_spec_type d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(role_spec), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.rolename <- Pbrt.Decoder.string d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(role_spec), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.location <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(role_spec), field(3)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    roletype = v.roletype;
    rolename = v.rolename;
    location = v.location;
  } : role_spec)

let rec decode_pb_drop_behavior d = 
  match Pbrt.Decoder.int_as_varint d with
  | 0 -> (Drop_behavior_undefined:drop_behavior)
  | 1 -> (Drop_restrict:drop_behavior)
  | 2 -> (Drop_cascade:drop_behavior)
  | _ -> Pbrt.Decoder.malformed_variant "drop_behavior"

let rec decode_pb_grant_target_type d = 
  match Pbrt.Decoder.int_as_varint d with
  | 0 -> (Grant_target_type_undefined:grant_target_type)
  | 1 -> (Acl_target_object:grant_target_type)
  | 2 -> (Acl_target_all_in_schema:grant_target_type)
  | 3 -> (Acl_target_defaults:grant_target_type)
  | _ -> Pbrt.Decoder.malformed_variant "grant_target_type"

let rec decode_pb_close_portal_stmt d =
  let v = default_close_portal_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.portalname <- Pbrt.Decoder.string d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(close_portal_stmt), field(1)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    portalname = v.portalname;
  } : close_portal_stmt)

let rec decode_pb_fetch_direction d = 
  match Pbrt.Decoder.int_as_varint d with
  | 0 -> (Fetch_direction_undefined:fetch_direction)
  | 1 -> (Fetch_forward:fetch_direction)
  | 2 -> (Fetch_backward:fetch_direction)
  | 3 -> (Fetch_absolute:fetch_direction)
  | 4 -> (Fetch_relative:fetch_direction)
  | _ -> Pbrt.Decoder.malformed_variant "fetch_direction"

let rec decode_pb_fetch_stmt d =
  let v = default_fetch_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Varint) -> begin
      v.direction <- decode_pb_fetch_direction d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(fetch_stmt), field(1)" pk
    | Some (2, Pbrt.Varint) -> begin
      v.how_many <- Pbrt.Decoder.int64_as_varint d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(fetch_stmt), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.portalname <- Pbrt.Decoder.string d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(fetch_stmt), field(3)" pk
    | Some (4, Pbrt.Varint) -> begin
      v.ismove <- Pbrt.Decoder.bool d;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(fetch_stmt), field(4)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    direction = v.direction;
    how_many = v.how_many;
    portalname = v.portalname;
    ismove = v.ismove;
  } : fetch_stmt)

let rec decode_pb_notify_stmt d =
  let v = default_notify_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.conditionname <- Pbrt.Decoder.string d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(notify_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.payload <- Pbrt.Decoder.string d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(notify_stmt), field(2)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    conditionname = v.conditionname;
    payload = v.payload;
  } : notify_stmt)

let rec decode_pb_listen_stmt d =
  let v = default_listen_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.conditionname <- Pbrt.Decoder.string d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(listen_stmt), field(1)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    conditionname = v.conditionname;
  } : listen_stmt)

let rec decode_pb_unlisten_stmt d =
  let v = default_unlisten_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.conditionname <- Pbrt.Decoder.string d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(unlisten_stmt), field(1)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    conditionname = v.conditionname;
  } : unlisten_stmt)

let rec decode_pb_transaction_stmt_kind d = 
  match Pbrt.Decoder.int_as_varint d with
  | 0 -> (Transaction_stmt_kind_undefined:transaction_stmt_kind)
  | 1 -> (Trans_stmt_begin:transaction_stmt_kind)
  | 2 -> (Trans_stmt_start:transaction_stmt_kind)
  | 3 -> (Trans_stmt_commit:transaction_stmt_kind)
  | 4 -> (Trans_stmt_rollback:transaction_stmt_kind)
  | 5 -> (Trans_stmt_savepoint:transaction_stmt_kind)
  | 6 -> (Trans_stmt_release:transaction_stmt_kind)
  | 7 -> (Trans_stmt_rollback_to:transaction_stmt_kind)
  | 8 -> (Trans_stmt_prepare:transaction_stmt_kind)
  | 9 -> (Trans_stmt_commit_prepared:transaction_stmt_kind)
  | 10 -> (Trans_stmt_rollback_prepared:transaction_stmt_kind)
  | _ -> Pbrt.Decoder.malformed_variant "transaction_stmt_kind"

let rec decode_pb_view_check_option d = 
  match Pbrt.Decoder.int_as_varint d with
  | 0 -> (View_check_option_undefined:view_check_option)
  | 1 -> (No_check_option:view_check_option)
  | 2 -> (Local_check_option:view_check_option)
  | 3 -> (Cascaded_check_option:view_check_option)
  | _ -> Pbrt.Decoder.malformed_variant "view_check_option"

let rec decode_pb_load_stmt d =
  let v = default_load_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.filename <- Pbrt.Decoder.string d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(load_stmt), field(1)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    filename = v.filename;
  } : load_stmt)

let rec decode_pb_variable_set_kind d = 
  match Pbrt.Decoder.int_as_varint d with
  | 0 -> (Variable_set_kind_undefined:variable_set_kind)
  | 1 -> (Var_set_value:variable_set_kind)
  | 2 -> (Var_set_default:variable_set_kind)
  | 3 -> (Var_set_current:variable_set_kind)
  | 4 -> (Var_set_multi:variable_set_kind)
  | 5 -> (Var_reset:variable_set_kind)
  | 6 -> (Var_reset_all:variable_set_kind)
  | _ -> Pbrt.Decoder.malformed_variant "variable_set_kind"

let rec decode_pb_variable_show_stmt d =
  let v = default_variable_show_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.name <- Pbrt.Decoder.string d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(variable_show_stmt), field(1)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    name = v.name;
  } : variable_show_stmt)

let rec decode_pb_discard_mode d = 
  match Pbrt.Decoder.int_as_varint d with
  | 0 -> (Discard_mode_undefined:discard_mode)
  | 1 -> (Discard_all:discard_mode)
  | 2 -> (Discard_plans:discard_mode)
  | 3 -> (Discard_sequences:discard_mode)
  | 4 -> (Discard_temp:discard_mode)
  | _ -> Pbrt.Decoder.malformed_variant "discard_mode"

let rec decode_pb_discard_stmt d =
  let v = default_discard_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Varint) -> begin
      v.target <- decode_pb_discard_mode d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(discard_stmt), field(1)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    target = v.target;
  } : discard_stmt)

let rec decode_pb_role_stmt_type d = 
  match Pbrt.Decoder.int_as_varint d with
  | 0 -> (Role_stmt_type_undefined:role_stmt_type)
  | 1 -> (Rolestmt_role:role_stmt_type)
  | 2 -> (Rolestmt_user:role_stmt_type)
  | 3 -> (Rolestmt_group:role_stmt_type)
  | _ -> Pbrt.Decoder.malformed_variant "role_stmt_type"

let rec decode_pb_reindex_object_type d = 
  match Pbrt.Decoder.int_as_varint d with
  | 0 -> (Reindex_object_type_undefined:reindex_object_type)
  | 1 -> (Reindex_object_index:reindex_object_type)
  | 2 -> (Reindex_object_table:reindex_object_type)
  | 3 -> (Reindex_object_schema:reindex_object_type)
  | 4 -> (Reindex_object_system:reindex_object_type)
  | 5 -> (Reindex_object_database:reindex_object_type)
  | _ -> Pbrt.Decoder.malformed_variant "reindex_object_type"

let rec decode_pb_check_point_stmt d =
  match Pbrt.Decoder.key d with
  | None -> ();
  | Some (_, pk) -> 
    Pbrt.Decoder.unexpected_payload "Unexpected fields in empty message(check_point_stmt)" pk

let rec decode_pb_coercion_context d = 
  match Pbrt.Decoder.int_as_varint d with
  | 0 -> (Coercion_context_undefined:coercion_context)
  | 1 -> (Coercion_implicit:coercion_context)
  | 2 -> (Coercion_assignment:coercion_context)
  | 3 -> (Coercion_explicit:coercion_context)
  | _ -> Pbrt.Decoder.malformed_variant "coercion_context"

let rec decode_pb_deallocate_stmt d =
  let v = default_deallocate_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.name <- Pbrt.Decoder.string d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(deallocate_stmt), field(1)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    name = v.name;
  } : deallocate_stmt)

let rec decode_pb_drop_table_space_stmt d =
  let v = default_drop_table_space_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.tablespacename <- Pbrt.Decoder.string d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(drop_table_space_stmt), field(1)" pk
    | Some (2, Pbrt.Varint) -> begin
      v.missing_ok <- Pbrt.Decoder.bool d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(drop_table_space_stmt), field(2)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    tablespacename = v.tablespacename;
    missing_ok = v.missing_ok;
  } : drop_table_space_stmt)

let rec decode_pb_alter_tsconfig_type d = 
  match Pbrt.Decoder.int_as_varint d with
  | 0 -> (Alter_tsconfig_type_undefined:alter_tsconfig_type)
  | 1 -> (Alter_tsconfig_add_mapping:alter_tsconfig_type)
  | 2 -> (Alter_tsconfig_alter_mapping_for_token:alter_tsconfig_type)
  | 3 -> (Alter_tsconfig_replace_dict:alter_tsconfig_type)
  | 4 -> (Alter_tsconfig_replace_dict_for_token:alter_tsconfig_type)
  | 5 -> (Alter_tsconfig_drop_mapping:alter_tsconfig_type)
  | _ -> Pbrt.Decoder.malformed_variant "alter_tsconfig_type"

let rec decode_pb_drop_user_mapping_stmt d =
  let v = default_drop_user_mapping_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.user <- Some (decode_pb_role_spec (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(drop_user_mapping_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.servername <- Pbrt.Decoder.string d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(drop_user_mapping_stmt), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.missing_ok <- Pbrt.Decoder.bool d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(drop_user_mapping_stmt), field(3)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    user = v.user;
    servername = v.servername;
    missing_ok = v.missing_ok;
  } : drop_user_mapping_stmt)

let rec decode_pb_import_foreign_schema_type d = 
  match Pbrt.Decoder.int_as_varint d with
  | 0 -> (Import_foreign_schema_type_undefined:import_foreign_schema_type)
  | 1 -> (Fdw_import_schema_all:import_foreign_schema_type)
  | 2 -> (Fdw_import_schema_limit_to:import_foreign_schema_type)
  | 3 -> (Fdw_import_schema_except:import_foreign_schema_type)
  | _ -> Pbrt.Decoder.malformed_variant "import_foreign_schema_type"

let rec decode_pb_alter_event_trig_stmt d =
  let v = default_alter_event_trig_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.trigname <- Pbrt.Decoder.string d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_event_trig_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.tgenabled <- Pbrt.Decoder.string d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_event_trig_stmt), field(2)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    trigname = v.trigname;
    tgenabled = v.tgenabled;
  } : alter_event_trig_stmt)

let rec decode_pb_replica_identity_stmt d =
  let v = default_replica_identity_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.identity_type <- Pbrt.Decoder.string d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(replica_identity_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.name <- Pbrt.Decoder.string d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(replica_identity_stmt), field(2)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    identity_type = v.identity_type;
    name = v.name;
  } : replica_identity_stmt)

let rec decode_pb_def_elem_action d = 
  match Pbrt.Decoder.int_as_varint d with
  | 0 -> (Def_elem_action_undefined:def_elem_action)
  | 1 -> (Defelem_unspec:def_elem_action)
  | 2 -> (Defelem_set:def_elem_action)
  | 3 -> (Defelem_add:def_elem_action)
  | 4 -> (Defelem_drop:def_elem_action)
  | _ -> Pbrt.Decoder.malformed_variant "def_elem_action"

let rec decode_pb_alter_subscription_type d = 
  match Pbrt.Decoder.int_as_varint d with
  | 0 -> (Alter_subscription_type_undefined:alter_subscription_type)
  | 1 -> (Alter_subscription_options:alter_subscription_type)
  | 2 -> (Alter_subscription_connection:alter_subscription_type)
  | 3 -> (Alter_subscription_publication:alter_subscription_type)
  | 4 -> (Alter_subscription_refresh:alter_subscription_type)
  | 5 -> (Alter_subscription_enabled:alter_subscription_type)
  | _ -> Pbrt.Decoder.malformed_variant "alter_subscription_type"

let rec decode_pb_drop_subscription_stmt d =
  let v = default_drop_subscription_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.subname <- Pbrt.Decoder.string d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(drop_subscription_stmt), field(1)" pk
    | Some (2, Pbrt.Varint) -> begin
      v.missing_ok <- Pbrt.Decoder.bool d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(drop_subscription_stmt), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.behavior <- decode_pb_drop_behavior d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(drop_subscription_stmt), field(3)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    subname = v.subname;
    missing_ok = v.missing_ok;
    behavior = v.behavior;
  } : drop_subscription_stmt)

let rec decode_pb_a_expr_kind d = 
  match Pbrt.Decoder.int_as_varint d with
  | 0 -> (A_expr_kind_undefined:a_expr_kind)
  | 1 -> (Aexpr_op:a_expr_kind)
  | 2 -> (Aexpr_op_any:a_expr_kind)
  | 3 -> (Aexpr_op_all:a_expr_kind)
  | 4 -> (Aexpr_distinct:a_expr_kind)
  | 5 -> (Aexpr_not_distinct:a_expr_kind)
  | 6 -> (Aexpr_nullif:a_expr_kind)
  | 7 -> (Aexpr_of:a_expr_kind)
  | 8 -> (Aexpr_in:a_expr_kind)
  | 9 -> (Aexpr_like:a_expr_kind)
  | 10 -> (Aexpr_ilike:a_expr_kind)
  | 11 -> (Aexpr_similar:a_expr_kind)
  | 12 -> (Aexpr_between:a_expr_kind)
  | 13 -> (Aexpr_not_between:a_expr_kind)
  | 14 -> (Aexpr_between_sym:a_expr_kind)
  | 15 -> (Aexpr_not_between_sym:a_expr_kind)
  | 16 -> (Aexpr_paren:a_expr_kind)
  | _ -> Pbrt.Decoder.malformed_variant "a_expr_kind"

let rec decode_pb_param_ref d =
  let v = default_param_ref_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Varint) -> begin
      v.number <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(param_ref), field(1)" pk
    | Some (2, Pbrt.Varint) -> begin
      v.location <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(param_ref), field(2)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    number = v.number;
    location = v.location;
  } : param_ref)

let rec decode_pb_a_star d =
  match Pbrt.Decoder.key d with
  | None -> ();
  | Some (_, pk) -> 
    Pbrt.Decoder.unexpected_payload "Unexpected fields in empty message(a_star)" pk

let rec decode_pb_sort_by_dir d = 
  match Pbrt.Decoder.int_as_varint d with
  | 0 -> (Sort_by_dir_undefined:sort_by_dir)
  | 1 -> (Sortby_default:sort_by_dir)
  | 2 -> (Sortby_asc:sort_by_dir)
  | 3 -> (Sortby_desc:sort_by_dir)
  | 4 -> (Sortby_using:sort_by_dir)
  | _ -> Pbrt.Decoder.malformed_variant "sort_by_dir"

let rec decode_pb_sort_by_nulls d = 
  match Pbrt.Decoder.int_as_varint d with
  | 0 -> (Sort_by_nulls_undefined:sort_by_nulls)
  | 1 -> (Sortby_nulls_default:sort_by_nulls)
  | 2 -> (Sortby_nulls_first:sort_by_nulls)
  | 3 -> (Sortby_nulls_last:sort_by_nulls)
  | _ -> Pbrt.Decoder.malformed_variant "sort_by_nulls"

let rec decode_pb_constr_type d = 
  match Pbrt.Decoder.int_as_varint d with
  | 0 -> (Constr_type_undefined:constr_type)
  | 1 -> (Constr_null:constr_type)
  | 2 -> (Constr_notnull:constr_type)
  | 3 -> (Constr_default:constr_type)
  | 4 -> (Constr_identity:constr_type)
  | 5 -> (Constr_generated:constr_type)
  | 6 -> (Constr_check:constr_type)
  | 7 -> (Constr_primary:constr_type)
  | 8 -> (Constr_unique:constr_type)
  | 9 -> (Constr_exclusion:constr_type)
  | 10 -> (Constr_foreign:constr_type)
  | 11 -> (Constr_attr_deferrable:constr_type)
  | 12 -> (Constr_attr_not_deferrable:constr_type)
  | 13 -> (Constr_attr_deferred:constr_type)
  | 14 -> (Constr_attr_immediate:constr_type)
  | _ -> Pbrt.Decoder.malformed_variant "constr_type"

let rec decode_pb_rtekind d = 
  match Pbrt.Decoder.int_as_varint d with
  | 0 -> (Rtekind_undefined:rtekind)
  | 1 -> (Rte_relation:rtekind)
  | 2 -> (Rte_subquery:rtekind)
  | 3 -> (Rte_join:rtekind)
  | 4 -> (Rte_function:rtekind)
  | 5 -> (Rte_tablefunc:rtekind)
  | 6 -> (Rte_values:rtekind)
  | 7 -> (Rte_cte:rtekind)
  | 8 -> (Rte_namedtuplestore:rtekind)
  | 9 -> (Rte_result:rtekind)
  | _ -> Pbrt.Decoder.malformed_variant "rtekind"

let rec decode_pb_wcokind d = 
  match Pbrt.Decoder.int_as_varint d with
  | 0 -> (Wcokind_undefined:wcokind)
  | 1 -> (Wco_view_check:wcokind)
  | 2 -> (Wco_rls_insert_check:wcokind)
  | 3 -> (Wco_rls_update_check:wcokind)
  | 4 -> (Wco_rls_conflict_check:wcokind)
  | _ -> Pbrt.Decoder.malformed_variant "wcokind"

let rec decode_pb_sort_group_clause d =
  let v = default_sort_group_clause_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Varint) -> begin
      v.tle_sort_group_ref <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(sort_group_clause), field(1)" pk
    | Some (2, Pbrt.Varint) -> begin
      v.eqop <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(sort_group_clause), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.sortop <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(sort_group_clause), field(3)" pk
    | Some (4, Pbrt.Varint) -> begin
      v.nulls_first <- Pbrt.Decoder.bool d;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(sort_group_clause), field(4)" pk
    | Some (5, Pbrt.Varint) -> begin
      v.hashable <- Pbrt.Decoder.bool d;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(sort_group_clause), field(5)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    tle_sort_group_ref = v.tle_sort_group_ref;
    eqop = v.eqop;
    sortop = v.sortop;
    nulls_first = v.nulls_first;
    hashable = v.hashable;
  } : sort_group_clause)

let rec decode_pb_grouping_set_kind d = 
  match Pbrt.Decoder.int_as_varint d with
  | 0 -> (Grouping_set_kind_undefined:grouping_set_kind)
  | 1 -> (Grouping_set_empty:grouping_set_kind)
  | 2 -> (Grouping_set_simple:grouping_set_kind)
  | 3 -> (Grouping_set_rollup:grouping_set_kind)
  | 4 -> (Grouping_set_cube:grouping_set_kind)
  | 5 -> (Grouping_set_sets:grouping_set_kind)
  | _ -> Pbrt.Decoder.malformed_variant "grouping_set_kind"

let rec decode_pb_function_parameter_mode d = 
  match Pbrt.Decoder.int_as_varint d with
  | 0 -> (Function_parameter_mode_undefined:function_parameter_mode)
  | 1 -> (Func_param_in:function_parameter_mode)
  | 2 -> (Func_param_out:function_parameter_mode)
  | 3 -> (Func_param_inout:function_parameter_mode)
  | 4 -> (Func_param_variadic:function_parameter_mode)
  | 5 -> (Func_param_table:function_parameter_mode)
  | _ -> Pbrt.Decoder.malformed_variant "function_parameter_mode"

let rec decode_pb_lock_clause_strength d = 
  match Pbrt.Decoder.int_as_varint d with
  | 0 -> (Lock_clause_strength_undefined:lock_clause_strength)
  | 1 -> (Lcs_none:lock_clause_strength)
  | 2 -> (Lcs_forkeyshare:lock_clause_strength)
  | 3 -> (Lcs_forshare:lock_clause_strength)
  | 4 -> (Lcs_fornokeyupdate:lock_clause_strength)
  | 5 -> (Lcs_forupdate:lock_clause_strength)
  | _ -> Pbrt.Decoder.malformed_variant "lock_clause_strength"

let rec decode_pb_lock_wait_policy d = 
  match Pbrt.Decoder.int_as_varint d with
  | 0 -> (Lock_wait_policy_undefined:lock_wait_policy)
  | 1 -> (Lock_wait_block:lock_wait_policy)
  | 2 -> (Lock_wait_skip:lock_wait_policy)
  | 3 -> (Lock_wait_error:lock_wait_policy)
  | _ -> Pbrt.Decoder.malformed_variant "lock_wait_policy"

let rec decode_pb_row_mark_clause d =
  let v = default_row_mark_clause_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Varint) -> begin
      v.rti <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(row_mark_clause), field(1)" pk
    | Some (2, Pbrt.Varint) -> begin
      v.strength <- decode_pb_lock_clause_strength d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(row_mark_clause), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.wait_policy <- decode_pb_lock_wait_policy d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(row_mark_clause), field(3)" pk
    | Some (4, Pbrt.Varint) -> begin
      v.pushed_down <- Pbrt.Decoder.bool d;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(row_mark_clause), field(4)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    rti = v.rti;
    strength = v.strength;
    wait_policy = v.wait_policy;
    pushed_down = v.pushed_down;
  } : row_mark_clause)

let rec decode_pb_ctematerialize d = 
  match Pbrt.Decoder.int_as_varint d with
  | 0 -> (Ctematerialize_undefined:ctematerialize)
  | 1 -> (Ctematerialize_default:ctematerialize)
  | 2 -> (Ctematerialize_always:ctematerialize)
  | 3 -> (Ctematerialize_never:ctematerialize)
  | _ -> Pbrt.Decoder.malformed_variant "ctematerialize"

let rec decode_pb_trigger_transition d =
  let v = default_trigger_transition_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.name <- Pbrt.Decoder.string d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(trigger_transition), field(1)" pk
    | Some (2, Pbrt.Varint) -> begin
      v.is_new <- Pbrt.Decoder.bool d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(trigger_transition), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.is_table <- Pbrt.Decoder.bool d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(trigger_transition), field(3)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    name = v.name;
    is_new = v.is_new;
    is_table = v.is_table;
  } : trigger_transition)

let rec decode_pb_partition_range_datum_kind d = 
  match Pbrt.Decoder.int_as_varint d with
  | 0 -> (Partition_range_datum_kind_undefined:partition_range_datum_kind)
  | 1 -> (Partition_range_datum_minvalue:partition_range_datum_kind)
  | 2 -> (Partition_range_datum_value:partition_range_datum_kind)
  | 3 -> (Partition_range_datum_maxvalue:partition_range_datum_kind)
  | _ -> Pbrt.Decoder.malformed_variant "partition_range_datum_kind"

let rec decode_pb_inline_code_block d =
  let v = default_inline_code_block_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.source_text <- Pbrt.Decoder.string d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(inline_code_block), field(1)" pk
    | Some (2, Pbrt.Varint) -> begin
      v.lang_oid <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(inline_code_block), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.lang_is_trusted <- Pbrt.Decoder.bool d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(inline_code_block), field(3)" pk
    | Some (4, Pbrt.Varint) -> begin
      v.atomic <- Pbrt.Decoder.bool d;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(inline_code_block), field(4)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    source_text = v.source_text;
    lang_oid = v.lang_oid;
    lang_is_trusted = v.lang_is_trusted;
    atomic = v.atomic;
  } : inline_code_block)

let rec decode_pb_call_context d =
  let v = default_call_context_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Varint) -> begin
      v.atomic <- Pbrt.Decoder.bool d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(call_context), field(1)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    atomic = v.atomic;
  } : call_context)

let rec decode_pb_integer d =
  let v = default_integer_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Varint) -> begin
      v.ival <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(integer), field(1)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    ival = v.ival;
  } : integer)

let rec decode_pb_pgfloat d =
  let v = default_pgfloat_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.str <- Pbrt.Decoder.string d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(pgfloat), field(1)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    str = v.str;
  } : pgfloat)

let rec decode_pb_pgstring d =
  let v = default_pgstring_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.str <- Pbrt.Decoder.string d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(pgstring), field(1)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    str = v.str;
  } : pgstring)

let rec decode_pb_bit_string d =
  let v = default_bit_string_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.str <- Pbrt.Decoder.string d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(bit_string), field(1)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    str = v.str;
  } : bit_string)

let rec decode_pb_null d =
  match Pbrt.Decoder.key d with
  | None -> ();
  | Some (_, pk) -> 
    Pbrt.Decoder.unexpected_payload "Unexpected fields in empty message(null)" pk

let rec decode_pb_raw_stmt d =
  let v = default_raw_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.stmt <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(raw_stmt), field(1)" pk
    | Some (2, Pbrt.Varint) -> begin
      v.stmt_location <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(raw_stmt), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.stmt_len <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(raw_stmt), field(3)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    stmt = v.stmt;
    stmt_location = v.stmt_location;
    stmt_len = v.stmt_len;
  } : raw_stmt)

and decode_pb_node d = 
  let rec loop () = 
    let ret:node = match Pbrt.Decoder.key d with
      | None -> Pbrt.Decoder.malformed_variant "node"
      | Some (1, _) -> (Alias (decode_pb_alias (Pbrt.Decoder.nested d)) : node) 
      | Some (2, _) -> (Range_var (decode_pb_range_var (Pbrt.Decoder.nested d)) : node) 
      | Some (3, _) -> (Table_func (decode_pb_table_func (Pbrt.Decoder.nested d)) : node) 
      | Some (4, _) -> begin 
        Pbrt.Decoder.empty_nested d ;
        (Expr : node)
      end
      | Some (5, _) -> (Var (decode_pb_var (Pbrt.Decoder.nested d)) : node) 
      | Some (6, _) -> (Param (decode_pb_param (Pbrt.Decoder.nested d)) : node) 
      | Some (7, _) -> (Aggref (decode_pb_aggref (Pbrt.Decoder.nested d)) : node) 
      | Some (8, _) -> (Grouping_func (decode_pb_grouping_func (Pbrt.Decoder.nested d)) : node) 
      | Some (9, _) -> (Window_func (decode_pb_window_func (Pbrt.Decoder.nested d)) : node) 
      | Some (10, _) -> (Subscripting_ref (decode_pb_subscripting_ref (Pbrt.Decoder.nested d)) : node) 
      | Some (11, _) -> (Func_expr (decode_pb_func_expr (Pbrt.Decoder.nested d)) : node) 
      | Some (12, _) -> (Named_arg_expr (decode_pb_named_arg_expr (Pbrt.Decoder.nested d)) : node) 
      | Some (13, _) -> (Op_expr (decode_pb_op_expr (Pbrt.Decoder.nested d)) : node) 
      | Some (14, _) -> (Distinct_expr (decode_pb_distinct_expr (Pbrt.Decoder.nested d)) : node) 
      | Some (15, _) -> (Null_if_expr (decode_pb_null_if_expr (Pbrt.Decoder.nested d)) : node) 
      | Some (16, _) -> (Scalar_array_op_expr (decode_pb_scalar_array_op_expr (Pbrt.Decoder.nested d)) : node) 
      | Some (17, _) -> (Bool_expr (decode_pb_bool_expr (Pbrt.Decoder.nested d)) : node) 
      | Some (18, _) -> (Sub_link (decode_pb_sub_link (Pbrt.Decoder.nested d)) : node) 
      | Some (19, _) -> (Sub_plan (decode_pb_sub_plan (Pbrt.Decoder.nested d)) : node) 
      | Some (20, _) -> (Alternative_sub_plan (decode_pb_alternative_sub_plan (Pbrt.Decoder.nested d)) : node) 
      | Some (21, _) -> (Field_select (decode_pb_field_select (Pbrt.Decoder.nested d)) : node) 
      | Some (22, _) -> (Field_store (decode_pb_field_store (Pbrt.Decoder.nested d)) : node) 
      | Some (23, _) -> (Relabel_type (decode_pb_relabel_type (Pbrt.Decoder.nested d)) : node) 
      | Some (24, _) -> (Coerce_via_io (decode_pb_coerce_via_io (Pbrt.Decoder.nested d)) : node) 
      | Some (25, _) -> (Array_coerce_expr (decode_pb_array_coerce_expr (Pbrt.Decoder.nested d)) : node) 
      | Some (26, _) -> (Convert_rowtype_expr (decode_pb_convert_rowtype_expr (Pbrt.Decoder.nested d)) : node) 
      | Some (27, _) -> (Collate_expr (decode_pb_collate_expr (Pbrt.Decoder.nested d)) : node) 
      | Some (28, _) -> (Case_expr (decode_pb_case_expr (Pbrt.Decoder.nested d)) : node) 
      | Some (29, _) -> (Case_when (decode_pb_case_when (Pbrt.Decoder.nested d)) : node) 
      | Some (30, _) -> (Case_test_expr (decode_pb_case_test_expr (Pbrt.Decoder.nested d)) : node) 
      | Some (31, _) -> (Array_expr (decode_pb_array_expr (Pbrt.Decoder.nested d)) : node) 
      | Some (32, _) -> (Row_expr (decode_pb_row_expr (Pbrt.Decoder.nested d)) : node) 
      | Some (33, _) -> (Row_compare_expr (decode_pb_row_compare_expr (Pbrt.Decoder.nested d)) : node) 
      | Some (34, _) -> (Coalesce_expr (decode_pb_coalesce_expr (Pbrt.Decoder.nested d)) : node) 
      | Some (35, _) -> (Min_max_expr (decode_pb_min_max_expr (Pbrt.Decoder.nested d)) : node) 
      | Some (36, _) -> (Sqlvalue_function (decode_pb_sqlvalue_function (Pbrt.Decoder.nested d)) : node) 
      | Some (37, _) -> (Xml_expr (decode_pb_xml_expr (Pbrt.Decoder.nested d)) : node) 
      | Some (38, _) -> (Null_test (decode_pb_null_test (Pbrt.Decoder.nested d)) : node) 
      | Some (39, _) -> (Boolean_test (decode_pb_boolean_test (Pbrt.Decoder.nested d)) : node) 
      | Some (40, _) -> (Coerce_to_domain (decode_pb_coerce_to_domain (Pbrt.Decoder.nested d)) : node) 
      | Some (41, _) -> (Coerce_to_domain_value (decode_pb_coerce_to_domain_value (Pbrt.Decoder.nested d)) : node) 
      | Some (42, _) -> (Set_to_default (decode_pb_set_to_default (Pbrt.Decoder.nested d)) : node) 
      | Some (43, _) -> (Current_of_expr (decode_pb_current_of_expr (Pbrt.Decoder.nested d)) : node) 
      | Some (44, _) -> (Next_value_expr (decode_pb_next_value_expr (Pbrt.Decoder.nested d)) : node) 
      | Some (45, _) -> (Inference_elem (decode_pb_inference_elem (Pbrt.Decoder.nested d)) : node) 
      | Some (46, _) -> (Target_entry (decode_pb_target_entry (Pbrt.Decoder.nested d)) : node) 
      | Some (47, _) -> (Range_tbl_ref (decode_pb_range_tbl_ref (Pbrt.Decoder.nested d)) : node) 
      | Some (48, _) -> (Join_expr (decode_pb_join_expr (Pbrt.Decoder.nested d)) : node) 
      | Some (49, _) -> (From_expr (decode_pb_from_expr (Pbrt.Decoder.nested d)) : node) 
      | Some (50, _) -> (On_conflict_expr (decode_pb_on_conflict_expr (Pbrt.Decoder.nested d)) : node) 
      | Some (51, _) -> (Into_clause (decode_pb_into_clause (Pbrt.Decoder.nested d)) : node) 
      | Some (52, _) -> (Raw_stmt (decode_pb_raw_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (53, _) -> (Query (decode_pb_query (Pbrt.Decoder.nested d)) : node) 
      | Some (54, _) -> (Insert_stmt (decode_pb_insert_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (55, _) -> (Delete_stmt (decode_pb_delete_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (56, _) -> (Update_stmt (decode_pb_update_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (57, _) -> (Select_stmt (decode_pb_select_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (58, _) -> (Alter_table_stmt (decode_pb_alter_table_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (59, _) -> (Alter_table_cmd (decode_pb_alter_table_cmd (Pbrt.Decoder.nested d)) : node) 
      | Some (60, _) -> (Alter_domain_stmt (decode_pb_alter_domain_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (61, _) -> (Set_operation_stmt (decode_pb_set_operation_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (62, _) -> (Grant_stmt (decode_pb_grant_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (63, _) -> (Grant_role_stmt (decode_pb_grant_role_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (64, _) -> (Alter_default_privileges_stmt (decode_pb_alter_default_privileges_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (65, _) -> (Close_portal_stmt (decode_pb_close_portal_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (66, _) -> (Cluster_stmt (decode_pb_cluster_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (67, _) -> (Copy_stmt (decode_pb_copy_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (68, _) -> (Create_stmt (decode_pb_create_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (69, _) -> (Define_stmt (decode_pb_define_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (70, _) -> (Drop_stmt (decode_pb_drop_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (71, _) -> (Truncate_stmt (decode_pb_truncate_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (72, _) -> (Comment_stmt (decode_pb_comment_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (73, _) -> (Fetch_stmt (decode_pb_fetch_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (74, _) -> (Index_stmt (decode_pb_index_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (75, _) -> (Create_function_stmt (decode_pb_create_function_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (76, _) -> (Alter_function_stmt (decode_pb_alter_function_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (77, _) -> (Do_stmt (decode_pb_do_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (78, _) -> (Rename_stmt (decode_pb_rename_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (79, _) -> (Rule_stmt (decode_pb_rule_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (80, _) -> (Notify_stmt (decode_pb_notify_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (81, _) -> (Listen_stmt (decode_pb_listen_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (82, _) -> (Unlisten_stmt (decode_pb_unlisten_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (83, _) -> (Transaction_stmt (decode_pb_transaction_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (84, _) -> (View_stmt (decode_pb_view_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (85, _) -> (Load_stmt (decode_pb_load_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (86, _) -> (Create_domain_stmt (decode_pb_create_domain_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (87, _) -> (Createdb_stmt (decode_pb_createdb_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (88, _) -> (Dropdb_stmt (decode_pb_dropdb_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (89, _) -> (Vacuum_stmt (decode_pb_vacuum_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (90, _) -> (Explain_stmt (decode_pb_explain_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (91, _) -> (Create_table_as_stmt (decode_pb_create_table_as_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (92, _) -> (Create_seq_stmt (decode_pb_create_seq_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (93, _) -> (Alter_seq_stmt (decode_pb_alter_seq_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (94, _) -> (Variable_set_stmt (decode_pb_variable_set_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (95, _) -> (Variable_show_stmt (decode_pb_variable_show_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (96, _) -> (Discard_stmt (decode_pb_discard_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (97, _) -> (Create_trig_stmt (decode_pb_create_trig_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (98, _) -> (Create_plang_stmt (decode_pb_create_plang_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (99, _) -> (Create_role_stmt (decode_pb_create_role_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (100, _) -> (Alter_role_stmt (decode_pb_alter_role_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (101, _) -> (Drop_role_stmt (decode_pb_drop_role_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (102, _) -> (Lock_stmt (decode_pb_lock_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (103, _) -> (Constraints_set_stmt (decode_pb_constraints_set_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (104, _) -> (Reindex_stmt (decode_pb_reindex_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (105, _) -> begin 
        Pbrt.Decoder.empty_nested d ;
        (Check_point_stmt : node)
      end
      | Some (106, _) -> (Create_schema_stmt (decode_pb_create_schema_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (107, _) -> (Alter_database_stmt (decode_pb_alter_database_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (108, _) -> (Alter_database_set_stmt (decode_pb_alter_database_set_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (109, _) -> (Alter_role_set_stmt (decode_pb_alter_role_set_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (110, _) -> (Create_conversion_stmt (decode_pb_create_conversion_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (111, _) -> (Create_cast_stmt (decode_pb_create_cast_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (112, _) -> (Create_op_class_stmt (decode_pb_create_op_class_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (113, _) -> (Create_op_family_stmt (decode_pb_create_op_family_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (114, _) -> (Alter_op_family_stmt (decode_pb_alter_op_family_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (115, _) -> (Prepare_stmt (decode_pb_prepare_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (116, _) -> (Execute_stmt (decode_pb_execute_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (117, _) -> (Deallocate_stmt (decode_pb_deallocate_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (118, _) -> (Declare_cursor_stmt (decode_pb_declare_cursor_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (119, _) -> (Create_table_space_stmt (decode_pb_create_table_space_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (120, _) -> (Drop_table_space_stmt (decode_pb_drop_table_space_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (121, _) -> (Alter_object_depends_stmt (decode_pb_alter_object_depends_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (122, _) -> (Alter_object_schema_stmt (decode_pb_alter_object_schema_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (123, _) -> (Alter_owner_stmt (decode_pb_alter_owner_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (124, _) -> (Alter_operator_stmt (decode_pb_alter_operator_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (125, _) -> (Alter_type_stmt (decode_pb_alter_type_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (126, _) -> (Drop_owned_stmt (decode_pb_drop_owned_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (127, _) -> (Reassign_owned_stmt (decode_pb_reassign_owned_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (128, _) -> (Composite_type_stmt (decode_pb_composite_type_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (129, _) -> (Create_enum_stmt (decode_pb_create_enum_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (130, _) -> (Create_range_stmt (decode_pb_create_range_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (131, _) -> (Alter_enum_stmt (decode_pb_alter_enum_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (132, _) -> (Alter_tsdictionary_stmt (decode_pb_alter_tsdictionary_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (133, _) -> (Alter_tsconfiguration_stmt (decode_pb_alter_tsconfiguration_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (134, _) -> (Create_fdw_stmt (decode_pb_create_fdw_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (135, _) -> (Alter_fdw_stmt (decode_pb_alter_fdw_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (136, _) -> (Create_foreign_server_stmt (decode_pb_create_foreign_server_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (137, _) -> (Alter_foreign_server_stmt (decode_pb_alter_foreign_server_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (138, _) -> (Create_user_mapping_stmt (decode_pb_create_user_mapping_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (139, _) -> (Alter_user_mapping_stmt (decode_pb_alter_user_mapping_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (140, _) -> (Drop_user_mapping_stmt (decode_pb_drop_user_mapping_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (141, _) -> (Alter_table_space_options_stmt (decode_pb_alter_table_space_options_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (142, _) -> (Alter_table_move_all_stmt (decode_pb_alter_table_move_all_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (143, _) -> (Sec_label_stmt (decode_pb_sec_label_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (144, _) -> (Create_foreign_table_stmt (decode_pb_create_foreign_table_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (145, _) -> (Import_foreign_schema_stmt (decode_pb_import_foreign_schema_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (146, _) -> (Create_extension_stmt (decode_pb_create_extension_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (147, _) -> (Alter_extension_stmt (decode_pb_alter_extension_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (148, _) -> (Alter_extension_contents_stmt (decode_pb_alter_extension_contents_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (149, _) -> (Create_event_trig_stmt (decode_pb_create_event_trig_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (150, _) -> (Alter_event_trig_stmt (decode_pb_alter_event_trig_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (151, _) -> (Refresh_mat_view_stmt (decode_pb_refresh_mat_view_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (152, _) -> (Replica_identity_stmt (decode_pb_replica_identity_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (153, _) -> (Alter_system_stmt (decode_pb_alter_system_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (154, _) -> (Create_policy_stmt (decode_pb_create_policy_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (155, _) -> (Alter_policy_stmt (decode_pb_alter_policy_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (156, _) -> (Create_transform_stmt (decode_pb_create_transform_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (157, _) -> (Create_am_stmt (decode_pb_create_am_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (158, _) -> (Create_publication_stmt (decode_pb_create_publication_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (159, _) -> (Alter_publication_stmt (decode_pb_alter_publication_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (160, _) -> (Create_subscription_stmt (decode_pb_create_subscription_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (161, _) -> (Alter_subscription_stmt (decode_pb_alter_subscription_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (162, _) -> (Drop_subscription_stmt (decode_pb_drop_subscription_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (163, _) -> (Create_stats_stmt (decode_pb_create_stats_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (164, _) -> (Alter_collation_stmt (decode_pb_alter_collation_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (165, _) -> (Call_stmt (decode_pb_call_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (166, _) -> (Alter_stats_stmt (decode_pb_alter_stats_stmt (Pbrt.Decoder.nested d)) : node) 
      | Some (167, _) -> (A_expr (decode_pb_a_expr (Pbrt.Decoder.nested d)) : node) 
      | Some (168, _) -> (Column_ref (decode_pb_column_ref (Pbrt.Decoder.nested d)) : node) 
      | Some (169, _) -> (Param_ref (decode_pb_param_ref (Pbrt.Decoder.nested d)) : node) 
      | Some (170, _) -> (A_const (decode_pb_a_const (Pbrt.Decoder.nested d)) : node) 
      | Some (171, _) -> (Func_call (decode_pb_func_call (Pbrt.Decoder.nested d)) : node) 
      | Some (172, _) -> begin 
        Pbrt.Decoder.empty_nested d ;
        (A_star : node)
      end
      | Some (173, _) -> (A_indices (decode_pb_a_indices (Pbrt.Decoder.nested d)) : node) 
      | Some (174, _) -> (A_indirection (decode_pb_a_indirection (Pbrt.Decoder.nested d)) : node) 
      | Some (175, _) -> (A_array_expr (decode_pb_a_array_expr (Pbrt.Decoder.nested d)) : node) 
      | Some (176, _) -> (Res_target (decode_pb_res_target (Pbrt.Decoder.nested d)) : node) 
      | Some (177, _) -> (Multi_assign_ref (decode_pb_multi_assign_ref (Pbrt.Decoder.nested d)) : node) 
      | Some (178, _) -> (Type_cast (decode_pb_type_cast (Pbrt.Decoder.nested d)) : node) 
      | Some (179, _) -> (Collate_clause (decode_pb_collate_clause (Pbrt.Decoder.nested d)) : node) 
      | Some (180, _) -> (Sort_by (decode_pb_sort_by (Pbrt.Decoder.nested d)) : node) 
      | Some (181, _) -> (Window_def (decode_pb_window_def (Pbrt.Decoder.nested d)) : node) 
      | Some (182, _) -> (Range_subselect (decode_pb_range_subselect (Pbrt.Decoder.nested d)) : node) 
      | Some (183, _) -> (Range_function (decode_pb_range_function (Pbrt.Decoder.nested d)) : node) 
      | Some (184, _) -> (Range_table_sample (decode_pb_range_table_sample (Pbrt.Decoder.nested d)) : node) 
      | Some (185, _) -> (Range_table_func (decode_pb_range_table_func (Pbrt.Decoder.nested d)) : node) 
      | Some (186, _) -> (Range_table_func_col (decode_pb_range_table_func_col (Pbrt.Decoder.nested d)) : node) 
      | Some (187, _) -> (Type_name (decode_pb_type_name (Pbrt.Decoder.nested d)) : node) 
      | Some (188, _) -> (Column_def (decode_pb_column_def (Pbrt.Decoder.nested d)) : node) 
      | Some (189, _) -> (Index_elem (decode_pb_index_elem (Pbrt.Decoder.nested d)) : node) 
      | Some (190, _) -> (Constraint (decode_pb_constraint_ (Pbrt.Decoder.nested d)) : node) 
      | Some (191, _) -> (Def_elem (decode_pb_def_elem (Pbrt.Decoder.nested d)) : node) 
      | Some (192, _) -> (Range_tbl_entry (decode_pb_range_tbl_entry (Pbrt.Decoder.nested d)) : node) 
      | Some (193, _) -> (Range_tbl_function (decode_pb_range_tbl_function (Pbrt.Decoder.nested d)) : node) 
      | Some (194, _) -> (Table_sample_clause (decode_pb_table_sample_clause (Pbrt.Decoder.nested d)) : node) 
      | Some (195, _) -> (With_check_option (decode_pb_with_check_option (Pbrt.Decoder.nested d)) : node) 
      | Some (196, _) -> (Sort_group_clause (decode_pb_sort_group_clause (Pbrt.Decoder.nested d)) : node) 
      | Some (197, _) -> (Grouping_set (decode_pb_grouping_set (Pbrt.Decoder.nested d)) : node) 
      | Some (198, _) -> (Window_clause (decode_pb_window_clause (Pbrt.Decoder.nested d)) : node) 
      | Some (199, _) -> (Object_with_args (decode_pb_object_with_args (Pbrt.Decoder.nested d)) : node) 
      | Some (200, _) -> (Access_priv (decode_pb_access_priv (Pbrt.Decoder.nested d)) : node) 
      | Some (201, _) -> (Create_op_class_item (decode_pb_create_op_class_item (Pbrt.Decoder.nested d)) : node) 
      | Some (202, _) -> (Table_like_clause (decode_pb_table_like_clause (Pbrt.Decoder.nested d)) : node) 
      | Some (203, _) -> (Function_parameter (decode_pb_function_parameter (Pbrt.Decoder.nested d)) : node) 
      | Some (204, _) -> (Locking_clause (decode_pb_locking_clause (Pbrt.Decoder.nested d)) : node) 
      | Some (205, _) -> (Row_mark_clause (decode_pb_row_mark_clause (Pbrt.Decoder.nested d)) : node) 
      | Some (206, _) -> (Xml_serialize (decode_pb_xml_serialize (Pbrt.Decoder.nested d)) : node) 
      | Some (207, _) -> (With_clause (decode_pb_with_clause (Pbrt.Decoder.nested d)) : node) 
      | Some (208, _) -> (Infer_clause (decode_pb_infer_clause (Pbrt.Decoder.nested d)) : node) 
      | Some (209, _) -> (On_conflict_clause (decode_pb_on_conflict_clause (Pbrt.Decoder.nested d)) : node) 
      | Some (210, _) -> (Common_table_expr (decode_pb_common_table_expr (Pbrt.Decoder.nested d)) : node) 
      | Some (211, _) -> (Role_spec (decode_pb_role_spec (Pbrt.Decoder.nested d)) : node) 
      | Some (212, _) -> (Trigger_transition (decode_pb_trigger_transition (Pbrt.Decoder.nested d)) : node) 
      | Some (213, _) -> (Partition_elem (decode_pb_partition_elem (Pbrt.Decoder.nested d)) : node) 
      | Some (214, _) -> (Partition_spec (decode_pb_partition_spec (Pbrt.Decoder.nested d)) : node) 
      | Some (215, _) -> (Partition_bound_spec (decode_pb_partition_bound_spec (Pbrt.Decoder.nested d)) : node) 
      | Some (216, _) -> (Partition_range_datum (decode_pb_partition_range_datum (Pbrt.Decoder.nested d)) : node) 
      | Some (217, _) -> (Partition_cmd (decode_pb_partition_cmd (Pbrt.Decoder.nested d)) : node) 
      | Some (218, _) -> (Vacuum_relation (decode_pb_vacuum_relation (Pbrt.Decoder.nested d)) : node) 
      | Some (219, _) -> (Inline_code_block (decode_pb_inline_code_block (Pbrt.Decoder.nested d)) : node) 
      | Some (220, _) -> (Call_context (decode_pb_call_context (Pbrt.Decoder.nested d)) : node) 
      | Some (221, _) -> (Integer (decode_pb_integer (Pbrt.Decoder.nested d)) : node) 
      | Some (222, _) -> (Float (decode_pb_pgfloat (Pbrt.Decoder.nested d)) : node) 
      | Some (223, _) -> (String (decode_pb_pgstring (Pbrt.Decoder.nested d)) : node) 
      | Some (224, _) -> (Bit_string (decode_pb_bit_string (Pbrt.Decoder.nested d)) : node) 
      | Some (225, _) -> begin 
        Pbrt.Decoder.empty_nested d ;
        (Null : node)
      end
      | Some (226, _) -> (List (decode_pb_pglist (Pbrt.Decoder.nested d)) : node) 
      | Some (227, _) -> (Int_list (decode_pb_int_list (Pbrt.Decoder.nested d)) : node) 
      | Some (228, _) -> (Oid_list (decode_pb_oid_list (Pbrt.Decoder.nested d)) : node) 
      | Some (n, payload_kind) -> (
        Pbrt.Decoder.skip d payload_kind; 
        loop () 
      )
    in
    ret
  in
  loop ()

and decode_pb_alias d =
  let v = default_alias_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.colnames <- List.rev v.colnames;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.aliasname <- Pbrt.Decoder.string d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alias), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.colnames <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.colnames;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alias), field(2)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    aliasname = v.aliasname;
    colnames = v.colnames;
  } : alias)

and decode_pb_range_var d =
  let v = default_range_var_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.catalogname <- Pbrt.Decoder.string d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_var), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.schemaname <- Pbrt.Decoder.string d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_var), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.relname <- Pbrt.Decoder.string d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_var), field(3)" pk
    | Some (4, Pbrt.Varint) -> begin
      v.inh <- Pbrt.Decoder.bool d;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_var), field(4)" pk
    | Some (5, Pbrt.Bytes) -> begin
      v.relpersistence <- Pbrt.Decoder.string d;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_var), field(5)" pk
    | Some (6, Pbrt.Bytes) -> begin
      v.alias <- Some (decode_pb_alias (Pbrt.Decoder.nested d));
    end
    | Some (6, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_var), field(6)" pk
    | Some (7, Pbrt.Varint) -> begin
      v.location <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (7, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_var), field(7)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    catalogname = v.catalogname;
    schemaname = v.schemaname;
    relname = v.relname;
    inh = v.inh;
    relpersistence = v.relpersistence;
    alias = v.alias;
    location = v.location;
  } : range_var)

and decode_pb_table_func d =
  let v = default_table_func_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.notnulls <- List.rev v.notnulls;
      v.coldefexprs <- List.rev v.coldefexprs;
      v.colexprs <- List.rev v.colexprs;
      v.colcollations <- List.rev v.colcollations;
      v.coltypmods <- List.rev v.coltypmods;
      v.coltypes <- List.rev v.coltypes;
      v.colnames <- List.rev v.colnames;
      v.ns_names <- List.rev v.ns_names;
      v.ns_uris <- List.rev v.ns_uris;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.ns_uris <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.ns_uris;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(table_func), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.ns_names <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.ns_names;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(table_func), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.docexpr <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(table_func), field(3)" pk
    | Some (4, Pbrt.Bytes) -> begin
      v.rowexpr <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(table_func), field(4)" pk
    | Some (5, Pbrt.Bytes) -> begin
      v.colnames <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.colnames;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(table_func), field(5)" pk
    | Some (6, Pbrt.Bytes) -> begin
      v.coltypes <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.coltypes;
    end
    | Some (6, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(table_func), field(6)" pk
    | Some (7, Pbrt.Bytes) -> begin
      v.coltypmods <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.coltypmods;
    end
    | Some (7, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(table_func), field(7)" pk
    | Some (8, Pbrt.Bytes) -> begin
      v.colcollations <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.colcollations;
    end
    | Some (8, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(table_func), field(8)" pk
    | Some (9, Pbrt.Bytes) -> begin
      v.colexprs <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.colexprs;
    end
    | Some (9, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(table_func), field(9)" pk
    | Some (10, Pbrt.Bytes) -> begin
      v.coldefexprs <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.coldefexprs;
    end
    | Some (10, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(table_func), field(10)" pk
    | Some (11, Pbrt.Bytes) -> begin
      v.notnulls <- Pbrt.Decoder.packed_fold (fun l d -> (Pbrt.Decoder.int64_as_varint d)::l) [] d;
    end
    | Some (11, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(table_func), field(11)" pk
    | Some (12, Pbrt.Varint) -> begin
      v.ordinalitycol <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (12, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(table_func), field(12)" pk
    | Some (13, Pbrt.Varint) -> begin
      v.location <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (13, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(table_func), field(13)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    ns_uris = v.ns_uris;
    ns_names = v.ns_names;
    docexpr = v.docexpr;
    rowexpr = v.rowexpr;
    colnames = v.colnames;
    coltypes = v.coltypes;
    coltypmods = v.coltypmods;
    colcollations = v.colcollations;
    colexprs = v.colexprs;
    coldefexprs = v.coldefexprs;
    notnulls = v.notnulls;
    ordinalitycol = v.ordinalitycol;
    location = v.location;
  } : table_func)

and decode_pb_var d =
  let v = default_var_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.xpr <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(var), field(1)" pk
    | Some (2, Pbrt.Varint) -> begin
      v.varno <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(var), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.varattno <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(var), field(3)" pk
    | Some (4, Pbrt.Varint) -> begin
      v.vartype <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(var), field(4)" pk
    | Some (5, Pbrt.Varint) -> begin
      v.vartypmod <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(var), field(5)" pk
    | Some (6, Pbrt.Varint) -> begin
      v.varcollid <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (6, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(var), field(6)" pk
    | Some (7, Pbrt.Varint) -> begin
      v.varlevelsup <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (7, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(var), field(7)" pk
    | Some (8, Pbrt.Varint) -> begin
      v.varnosyn <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (8, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(var), field(8)" pk
    | Some (9, Pbrt.Varint) -> begin
      v.varattnosyn <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (9, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(var), field(9)" pk
    | Some (10, Pbrt.Varint) -> begin
      v.location <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (10, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(var), field(10)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    xpr = v.xpr;
    varno = v.varno;
    varattno = v.varattno;
    vartype = v.vartype;
    vartypmod = v.vartypmod;
    varcollid = v.varcollid;
    varlevelsup = v.varlevelsup;
    varnosyn = v.varnosyn;
    varattnosyn = v.varattnosyn;
    location = v.location;
  } : var)

and decode_pb_param d =
  let v = default_param_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.xpr <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(param), field(1)" pk
    | Some (2, Pbrt.Varint) -> begin
      v.paramkind <- decode_pb_param_kind d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(param), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.paramid <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(param), field(3)" pk
    | Some (4, Pbrt.Varint) -> begin
      v.paramtype <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(param), field(4)" pk
    | Some (5, Pbrt.Varint) -> begin
      v.paramtypmod <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(param), field(5)" pk
    | Some (6, Pbrt.Varint) -> begin
      v.paramcollid <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (6, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(param), field(6)" pk
    | Some (7, Pbrt.Varint) -> begin
      v.location <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (7, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(param), field(7)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    xpr = v.xpr;
    paramkind = v.paramkind;
    paramid = v.paramid;
    paramtype = v.paramtype;
    paramtypmod = v.paramtypmod;
    paramcollid = v.paramcollid;
    location = v.location;
  } : param)

and decode_pb_aggref d =
  let v = default_aggref_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.aggdistinct <- List.rev v.aggdistinct;
      v.aggorder <- List.rev v.aggorder;
      v.args <- List.rev v.args;
      v.aggdirectargs <- List.rev v.aggdirectargs;
      v.aggargtypes <- List.rev v.aggargtypes;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.xpr <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(aggref), field(1)" pk
    | Some (2, Pbrt.Varint) -> begin
      v.aggfnoid <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(aggref), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.aggtype <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(aggref), field(3)" pk
    | Some (4, Pbrt.Varint) -> begin
      v.aggcollid <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(aggref), field(4)" pk
    | Some (5, Pbrt.Varint) -> begin
      v.inputcollid <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(aggref), field(5)" pk
    | Some (6, Pbrt.Varint) -> begin
      v.aggtranstype <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (6, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(aggref), field(6)" pk
    | Some (7, Pbrt.Bytes) -> begin
      v.aggargtypes <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.aggargtypes;
    end
    | Some (7, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(aggref), field(7)" pk
    | Some (8, Pbrt.Bytes) -> begin
      v.aggdirectargs <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.aggdirectargs;
    end
    | Some (8, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(aggref), field(8)" pk
    | Some (9, Pbrt.Bytes) -> begin
      v.args <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.args;
    end
    | Some (9, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(aggref), field(9)" pk
    | Some (10, Pbrt.Bytes) -> begin
      v.aggorder <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.aggorder;
    end
    | Some (10, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(aggref), field(10)" pk
    | Some (11, Pbrt.Bytes) -> begin
      v.aggdistinct <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.aggdistinct;
    end
    | Some (11, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(aggref), field(11)" pk
    | Some (12, Pbrt.Bytes) -> begin
      v.aggfilter <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (12, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(aggref), field(12)" pk
    | Some (13, Pbrt.Varint) -> begin
      v.aggstar <- Pbrt.Decoder.bool d;
    end
    | Some (13, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(aggref), field(13)" pk
    | Some (14, Pbrt.Varint) -> begin
      v.aggvariadic <- Pbrt.Decoder.bool d;
    end
    | Some (14, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(aggref), field(14)" pk
    | Some (15, Pbrt.Bytes) -> begin
      v.aggkind <- Pbrt.Decoder.string d;
    end
    | Some (15, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(aggref), field(15)" pk
    | Some (16, Pbrt.Varint) -> begin
      v.agglevelsup <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (16, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(aggref), field(16)" pk
    | Some (17, Pbrt.Varint) -> begin
      v.aggsplit <- decode_pb_agg_split d;
    end
    | Some (17, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(aggref), field(17)" pk
    | Some (18, Pbrt.Varint) -> begin
      v.location <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (18, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(aggref), field(18)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    xpr = v.xpr;
    aggfnoid = v.aggfnoid;
    aggtype = v.aggtype;
    aggcollid = v.aggcollid;
    inputcollid = v.inputcollid;
    aggtranstype = v.aggtranstype;
    aggargtypes = v.aggargtypes;
    aggdirectargs = v.aggdirectargs;
    args = v.args;
    aggorder = v.aggorder;
    aggdistinct = v.aggdistinct;
    aggfilter = v.aggfilter;
    aggstar = v.aggstar;
    aggvariadic = v.aggvariadic;
    aggkind = v.aggkind;
    agglevelsup = v.agglevelsup;
    aggsplit = v.aggsplit;
    location = v.location;
  } : aggref)

and decode_pb_grouping_func d =
  let v = default_grouping_func_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.cols <- List.rev v.cols;
      v.refs <- List.rev v.refs;
      v.args <- List.rev v.args;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.xpr <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(grouping_func), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.args <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.args;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(grouping_func), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.refs <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.refs;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(grouping_func), field(3)" pk
    | Some (4, Pbrt.Bytes) -> begin
      v.cols <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.cols;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(grouping_func), field(4)" pk
    | Some (5, Pbrt.Varint) -> begin
      v.agglevelsup <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(grouping_func), field(5)" pk
    | Some (6, Pbrt.Varint) -> begin
      v.location <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (6, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(grouping_func), field(6)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    xpr = v.xpr;
    args = v.args;
    refs = v.refs;
    cols = v.cols;
    agglevelsup = v.agglevelsup;
    location = v.location;
  } : grouping_func)

and decode_pb_window_func d =
  let v = default_window_func_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.args <- List.rev v.args;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.xpr <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(window_func), field(1)" pk
    | Some (2, Pbrt.Varint) -> begin
      v.winfnoid <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(window_func), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.wintype <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(window_func), field(3)" pk
    | Some (4, Pbrt.Varint) -> begin
      v.wincollid <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(window_func), field(4)" pk
    | Some (5, Pbrt.Varint) -> begin
      v.inputcollid <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(window_func), field(5)" pk
    | Some (6, Pbrt.Bytes) -> begin
      v.args <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.args;
    end
    | Some (6, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(window_func), field(6)" pk
    | Some (7, Pbrt.Bytes) -> begin
      v.aggfilter <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (7, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(window_func), field(7)" pk
    | Some (8, Pbrt.Varint) -> begin
      v.winref <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (8, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(window_func), field(8)" pk
    | Some (9, Pbrt.Varint) -> begin
      v.winstar <- Pbrt.Decoder.bool d;
    end
    | Some (9, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(window_func), field(9)" pk
    | Some (10, Pbrt.Varint) -> begin
      v.winagg <- Pbrt.Decoder.bool d;
    end
    | Some (10, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(window_func), field(10)" pk
    | Some (11, Pbrt.Varint) -> begin
      v.location <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (11, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(window_func), field(11)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    xpr = v.xpr;
    winfnoid = v.winfnoid;
    wintype = v.wintype;
    wincollid = v.wincollid;
    inputcollid = v.inputcollid;
    args = v.args;
    aggfilter = v.aggfilter;
    winref = v.winref;
    winstar = v.winstar;
    winagg = v.winagg;
    location = v.location;
  } : window_func)

and decode_pb_subscripting_ref d =
  let v = default_subscripting_ref_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.reflowerindexpr <- List.rev v.reflowerindexpr;
      v.refupperindexpr <- List.rev v.refupperindexpr;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.xpr <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(subscripting_ref), field(1)" pk
    | Some (2, Pbrt.Varint) -> begin
      v.refcontainertype <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(subscripting_ref), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.refelemtype <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(subscripting_ref), field(3)" pk
    | Some (4, Pbrt.Varint) -> begin
      v.reftypmod <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(subscripting_ref), field(4)" pk
    | Some (5, Pbrt.Varint) -> begin
      v.refcollid <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(subscripting_ref), field(5)" pk
    | Some (6, Pbrt.Bytes) -> begin
      v.refupperindexpr <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.refupperindexpr;
    end
    | Some (6, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(subscripting_ref), field(6)" pk
    | Some (7, Pbrt.Bytes) -> begin
      v.reflowerindexpr <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.reflowerindexpr;
    end
    | Some (7, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(subscripting_ref), field(7)" pk
    | Some (8, Pbrt.Bytes) -> begin
      v.refexpr <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (8, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(subscripting_ref), field(8)" pk
    | Some (9, Pbrt.Bytes) -> begin
      v.refassgnexpr <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (9, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(subscripting_ref), field(9)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    xpr = v.xpr;
    refcontainertype = v.refcontainertype;
    refelemtype = v.refelemtype;
    reftypmod = v.reftypmod;
    refcollid = v.refcollid;
    refupperindexpr = v.refupperindexpr;
    reflowerindexpr = v.reflowerindexpr;
    refexpr = v.refexpr;
    refassgnexpr = v.refassgnexpr;
  } : subscripting_ref)

and decode_pb_func_expr d =
  let v = default_func_expr_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.args <- List.rev v.args;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.xpr <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(func_expr), field(1)" pk
    | Some (2, Pbrt.Varint) -> begin
      v.funcid <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(func_expr), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.funcresulttype <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(func_expr), field(3)" pk
    | Some (4, Pbrt.Varint) -> begin
      v.funcretset <- Pbrt.Decoder.bool d;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(func_expr), field(4)" pk
    | Some (5, Pbrt.Varint) -> begin
      v.funcvariadic <- Pbrt.Decoder.bool d;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(func_expr), field(5)" pk
    | Some (6, Pbrt.Varint) -> begin
      v.funcformat <- decode_pb_coercion_form d;
    end
    | Some (6, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(func_expr), field(6)" pk
    | Some (7, Pbrt.Varint) -> begin
      v.funccollid <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (7, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(func_expr), field(7)" pk
    | Some (8, Pbrt.Varint) -> begin
      v.inputcollid <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (8, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(func_expr), field(8)" pk
    | Some (9, Pbrt.Bytes) -> begin
      v.args <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.args;
    end
    | Some (9, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(func_expr), field(9)" pk
    | Some (10, Pbrt.Varint) -> begin
      v.location <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (10, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(func_expr), field(10)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    xpr = v.xpr;
    funcid = v.funcid;
    funcresulttype = v.funcresulttype;
    funcretset = v.funcretset;
    funcvariadic = v.funcvariadic;
    funcformat = v.funcformat;
    funccollid = v.funccollid;
    inputcollid = v.inputcollid;
    args = v.args;
    location = v.location;
  } : func_expr)

and decode_pb_named_arg_expr d =
  let v = default_named_arg_expr_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.xpr <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(named_arg_expr), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.arg <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(named_arg_expr), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.name <- Pbrt.Decoder.string d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(named_arg_expr), field(3)" pk
    | Some (4, Pbrt.Varint) -> begin
      v.argnumber <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(named_arg_expr), field(4)" pk
    | Some (5, Pbrt.Varint) -> begin
      v.location <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(named_arg_expr), field(5)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    xpr = v.xpr;
    arg = v.arg;
    name = v.name;
    argnumber = v.argnumber;
    location = v.location;
  } : named_arg_expr)

and decode_pb_op_expr d =
  let v = default_op_expr_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.args <- List.rev v.args;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.xpr <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(op_expr), field(1)" pk
    | Some (2, Pbrt.Varint) -> begin
      v.opno <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(op_expr), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.opfuncid <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(op_expr), field(3)" pk
    | Some (4, Pbrt.Varint) -> begin
      v.opresulttype <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(op_expr), field(4)" pk
    | Some (5, Pbrt.Varint) -> begin
      v.opretset <- Pbrt.Decoder.bool d;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(op_expr), field(5)" pk
    | Some (6, Pbrt.Varint) -> begin
      v.opcollid <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (6, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(op_expr), field(6)" pk
    | Some (7, Pbrt.Varint) -> begin
      v.inputcollid <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (7, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(op_expr), field(7)" pk
    | Some (8, Pbrt.Bytes) -> begin
      v.args <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.args;
    end
    | Some (8, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(op_expr), field(8)" pk
    | Some (9, Pbrt.Varint) -> begin
      v.location <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (9, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(op_expr), field(9)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    xpr = v.xpr;
    opno = v.opno;
    opfuncid = v.opfuncid;
    opresulttype = v.opresulttype;
    opretset = v.opretset;
    opcollid = v.opcollid;
    inputcollid = v.inputcollid;
    args = v.args;
    location = v.location;
  } : op_expr)

and decode_pb_distinct_expr d =
  let v = default_distinct_expr_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.args <- List.rev v.args;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.xpr <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(distinct_expr), field(1)" pk
    | Some (2, Pbrt.Varint) -> begin
      v.opno <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(distinct_expr), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.opfuncid <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(distinct_expr), field(3)" pk
    | Some (4, Pbrt.Varint) -> begin
      v.opresulttype <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(distinct_expr), field(4)" pk
    | Some (5, Pbrt.Varint) -> begin
      v.opretset <- Pbrt.Decoder.bool d;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(distinct_expr), field(5)" pk
    | Some (6, Pbrt.Varint) -> begin
      v.opcollid <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (6, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(distinct_expr), field(6)" pk
    | Some (7, Pbrt.Varint) -> begin
      v.inputcollid <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (7, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(distinct_expr), field(7)" pk
    | Some (8, Pbrt.Bytes) -> begin
      v.args <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.args;
    end
    | Some (8, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(distinct_expr), field(8)" pk
    | Some (9, Pbrt.Varint) -> begin
      v.location <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (9, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(distinct_expr), field(9)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    xpr = v.xpr;
    opno = v.opno;
    opfuncid = v.opfuncid;
    opresulttype = v.opresulttype;
    opretset = v.opretset;
    opcollid = v.opcollid;
    inputcollid = v.inputcollid;
    args = v.args;
    location = v.location;
  } : distinct_expr)

and decode_pb_null_if_expr d =
  let v = default_null_if_expr_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.args <- List.rev v.args;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.xpr <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(null_if_expr), field(1)" pk
    | Some (2, Pbrt.Varint) -> begin
      v.opno <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(null_if_expr), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.opfuncid <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(null_if_expr), field(3)" pk
    | Some (4, Pbrt.Varint) -> begin
      v.opresulttype <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(null_if_expr), field(4)" pk
    | Some (5, Pbrt.Varint) -> begin
      v.opretset <- Pbrt.Decoder.bool d;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(null_if_expr), field(5)" pk
    | Some (6, Pbrt.Varint) -> begin
      v.opcollid <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (6, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(null_if_expr), field(6)" pk
    | Some (7, Pbrt.Varint) -> begin
      v.inputcollid <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (7, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(null_if_expr), field(7)" pk
    | Some (8, Pbrt.Bytes) -> begin
      v.args <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.args;
    end
    | Some (8, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(null_if_expr), field(8)" pk
    | Some (9, Pbrt.Varint) -> begin
      v.location <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (9, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(null_if_expr), field(9)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    xpr = v.xpr;
    opno = v.opno;
    opfuncid = v.opfuncid;
    opresulttype = v.opresulttype;
    opretset = v.opretset;
    opcollid = v.opcollid;
    inputcollid = v.inputcollid;
    args = v.args;
    location = v.location;
  } : null_if_expr)

and decode_pb_scalar_array_op_expr d =
  let v = default_scalar_array_op_expr_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.args <- List.rev v.args;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.xpr <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(scalar_array_op_expr), field(1)" pk
    | Some (2, Pbrt.Varint) -> begin
      v.opno <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(scalar_array_op_expr), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.opfuncid <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(scalar_array_op_expr), field(3)" pk
    | Some (4, Pbrt.Varint) -> begin
      v.use_or <- Pbrt.Decoder.bool d;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(scalar_array_op_expr), field(4)" pk
    | Some (5, Pbrt.Varint) -> begin
      v.inputcollid <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(scalar_array_op_expr), field(5)" pk
    | Some (6, Pbrt.Bytes) -> begin
      v.args <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.args;
    end
    | Some (6, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(scalar_array_op_expr), field(6)" pk
    | Some (7, Pbrt.Varint) -> begin
      v.location <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (7, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(scalar_array_op_expr), field(7)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    xpr = v.xpr;
    opno = v.opno;
    opfuncid = v.opfuncid;
    use_or = v.use_or;
    inputcollid = v.inputcollid;
    args = v.args;
    location = v.location;
  } : scalar_array_op_expr)

and decode_pb_bool_expr d =
  let v = default_bool_expr_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.args <- List.rev v.args;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.xpr <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(bool_expr), field(1)" pk
    | Some (2, Pbrt.Varint) -> begin
      v.boolop <- decode_pb_bool_expr_type d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(bool_expr), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.args <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.args;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(bool_expr), field(3)" pk
    | Some (4, Pbrt.Varint) -> begin
      v.location <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(bool_expr), field(4)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    xpr = v.xpr;
    boolop = v.boolop;
    args = v.args;
    location = v.location;
  } : bool_expr)

and decode_pb_sub_link d =
  let v = default_sub_link_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.oper_name <- List.rev v.oper_name;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.xpr <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(sub_link), field(1)" pk
    | Some (2, Pbrt.Varint) -> begin
      v.sub_link_type <- decode_pb_sub_link_type d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(sub_link), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.sub_link_id <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(sub_link), field(3)" pk
    | Some (4, Pbrt.Bytes) -> begin
      v.testexpr <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(sub_link), field(4)" pk
    | Some (5, Pbrt.Bytes) -> begin
      v.oper_name <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.oper_name;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(sub_link), field(5)" pk
    | Some (6, Pbrt.Bytes) -> begin
      v.subselect <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (6, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(sub_link), field(6)" pk
    | Some (7, Pbrt.Varint) -> begin
      v.location <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (7, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(sub_link), field(7)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    xpr = v.xpr;
    sub_link_type = v.sub_link_type;
    sub_link_id = v.sub_link_id;
    testexpr = v.testexpr;
    oper_name = v.oper_name;
    subselect = v.subselect;
    location = v.location;
  } : sub_link)

and decode_pb_sub_plan d =
  let v = default_sub_plan_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.args <- List.rev v.args;
      v.par_param <- List.rev v.par_param;
      v.set_param <- List.rev v.set_param;
      v.param_ids <- List.rev v.param_ids;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.xpr <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(sub_plan), field(1)" pk
    | Some (2, Pbrt.Varint) -> begin
      v.sub_link_type <- decode_pb_sub_link_type d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(sub_plan), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.testexpr <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(sub_plan), field(3)" pk
    | Some (4, Pbrt.Bytes) -> begin
      v.param_ids <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.param_ids;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(sub_plan), field(4)" pk
    | Some (5, Pbrt.Varint) -> begin
      v.plan_id <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(sub_plan), field(5)" pk
    | Some (6, Pbrt.Bytes) -> begin
      v.plan_name <- Pbrt.Decoder.string d;
    end
    | Some (6, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(sub_plan), field(6)" pk
    | Some (7, Pbrt.Varint) -> begin
      v.first_col_type <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (7, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(sub_plan), field(7)" pk
    | Some (8, Pbrt.Varint) -> begin
      v.first_col_typmod <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (8, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(sub_plan), field(8)" pk
    | Some (9, Pbrt.Varint) -> begin
      v.first_col_collation <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (9, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(sub_plan), field(9)" pk
    | Some (10, Pbrt.Varint) -> begin
      v.use_hash_table <- Pbrt.Decoder.bool d;
    end
    | Some (10, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(sub_plan), field(10)" pk
    | Some (11, Pbrt.Varint) -> begin
      v.unknown_eq_false <- Pbrt.Decoder.bool d;
    end
    | Some (11, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(sub_plan), field(11)" pk
    | Some (12, Pbrt.Varint) -> begin
      v.parallel_safe <- Pbrt.Decoder.bool d;
    end
    | Some (12, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(sub_plan), field(12)" pk
    | Some (13, Pbrt.Bytes) -> begin
      v.set_param <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.set_param;
    end
    | Some (13, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(sub_plan), field(13)" pk
    | Some (14, Pbrt.Bytes) -> begin
      v.par_param <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.par_param;
    end
    | Some (14, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(sub_plan), field(14)" pk
    | Some (15, Pbrt.Bytes) -> begin
      v.args <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.args;
    end
    | Some (15, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(sub_plan), field(15)" pk
    | Some (16, Pbrt.Bits64) -> begin
      v.startup_cost <- Pbrt.Decoder.float_as_bits64 d;
    end
    | Some (16, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(sub_plan), field(16)" pk
    | Some (17, Pbrt.Bits64) -> begin
      v.per_call_cost <- Pbrt.Decoder.float_as_bits64 d;
    end
    | Some (17, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(sub_plan), field(17)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    xpr = v.xpr;
    sub_link_type = v.sub_link_type;
    testexpr = v.testexpr;
    param_ids = v.param_ids;
    plan_id = v.plan_id;
    plan_name = v.plan_name;
    first_col_type = v.first_col_type;
    first_col_typmod = v.first_col_typmod;
    first_col_collation = v.first_col_collation;
    use_hash_table = v.use_hash_table;
    unknown_eq_false = v.unknown_eq_false;
    parallel_safe = v.parallel_safe;
    set_param = v.set_param;
    par_param = v.par_param;
    args = v.args;
    startup_cost = v.startup_cost;
    per_call_cost = v.per_call_cost;
  } : sub_plan)

and decode_pb_alternative_sub_plan d =
  let v = default_alternative_sub_plan_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.subplans <- List.rev v.subplans;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.xpr <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alternative_sub_plan), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.subplans <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.subplans;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alternative_sub_plan), field(2)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    xpr = v.xpr;
    subplans = v.subplans;
  } : alternative_sub_plan)

and decode_pb_field_select d =
  let v = default_field_select_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.xpr <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(field_select), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.arg <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(field_select), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.fieldnum <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(field_select), field(3)" pk
    | Some (4, Pbrt.Varint) -> begin
      v.resulttype <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(field_select), field(4)" pk
    | Some (5, Pbrt.Varint) -> begin
      v.resulttypmod <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(field_select), field(5)" pk
    | Some (6, Pbrt.Varint) -> begin
      v.resultcollid <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (6, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(field_select), field(6)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    xpr = v.xpr;
    arg = v.arg;
    fieldnum = v.fieldnum;
    resulttype = v.resulttype;
    resulttypmod = v.resulttypmod;
    resultcollid = v.resultcollid;
  } : field_select)

and decode_pb_field_store d =
  let v = default_field_store_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.fieldnums <- List.rev v.fieldnums;
      v.newvals <- List.rev v.newvals;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.xpr <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(field_store), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.arg <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(field_store), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.newvals <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.newvals;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(field_store), field(3)" pk
    | Some (4, Pbrt.Bytes) -> begin
      v.fieldnums <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.fieldnums;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(field_store), field(4)" pk
    | Some (5, Pbrt.Varint) -> begin
      v.resulttype <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(field_store), field(5)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    xpr = v.xpr;
    arg = v.arg;
    newvals = v.newvals;
    fieldnums = v.fieldnums;
    resulttype = v.resulttype;
  } : field_store)

and decode_pb_relabel_type d =
  let v = default_relabel_type_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.xpr <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(relabel_type), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.arg <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(relabel_type), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.resulttype <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(relabel_type), field(3)" pk
    | Some (4, Pbrt.Varint) -> begin
      v.resulttypmod <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(relabel_type), field(4)" pk
    | Some (5, Pbrt.Varint) -> begin
      v.resultcollid <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(relabel_type), field(5)" pk
    | Some (6, Pbrt.Varint) -> begin
      v.relabelformat <- decode_pb_coercion_form d;
    end
    | Some (6, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(relabel_type), field(6)" pk
    | Some (7, Pbrt.Varint) -> begin
      v.location <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (7, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(relabel_type), field(7)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    xpr = v.xpr;
    arg = v.arg;
    resulttype = v.resulttype;
    resulttypmod = v.resulttypmod;
    resultcollid = v.resultcollid;
    relabelformat = v.relabelformat;
    location = v.location;
  } : relabel_type)

and decode_pb_coerce_via_io d =
  let v = default_coerce_via_io_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.xpr <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(coerce_via_io), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.arg <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(coerce_via_io), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.resulttype <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(coerce_via_io), field(3)" pk
    | Some (4, Pbrt.Varint) -> begin
      v.resultcollid <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(coerce_via_io), field(4)" pk
    | Some (5, Pbrt.Varint) -> begin
      v.coerceformat <- decode_pb_coercion_form d;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(coerce_via_io), field(5)" pk
    | Some (6, Pbrt.Varint) -> begin
      v.location <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (6, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(coerce_via_io), field(6)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    xpr = v.xpr;
    arg = v.arg;
    resulttype = v.resulttype;
    resultcollid = v.resultcollid;
    coerceformat = v.coerceformat;
    location = v.location;
  } : coerce_via_io)

and decode_pb_array_coerce_expr d =
  let v = default_array_coerce_expr_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.xpr <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(array_coerce_expr), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.arg <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(array_coerce_expr), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.elemexpr <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(array_coerce_expr), field(3)" pk
    | Some (4, Pbrt.Varint) -> begin
      v.resulttype <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(array_coerce_expr), field(4)" pk
    | Some (5, Pbrt.Varint) -> begin
      v.resulttypmod <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(array_coerce_expr), field(5)" pk
    | Some (6, Pbrt.Varint) -> begin
      v.resultcollid <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (6, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(array_coerce_expr), field(6)" pk
    | Some (7, Pbrt.Varint) -> begin
      v.coerceformat <- decode_pb_coercion_form d;
    end
    | Some (7, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(array_coerce_expr), field(7)" pk
    | Some (8, Pbrt.Varint) -> begin
      v.location <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (8, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(array_coerce_expr), field(8)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    xpr = v.xpr;
    arg = v.arg;
    elemexpr = v.elemexpr;
    resulttype = v.resulttype;
    resulttypmod = v.resulttypmod;
    resultcollid = v.resultcollid;
    coerceformat = v.coerceformat;
    location = v.location;
  } : array_coerce_expr)

and decode_pb_convert_rowtype_expr d =
  let v = default_convert_rowtype_expr_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.xpr <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(convert_rowtype_expr), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.arg <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(convert_rowtype_expr), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.resulttype <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(convert_rowtype_expr), field(3)" pk
    | Some (4, Pbrt.Varint) -> begin
      v.convertformat <- decode_pb_coercion_form d;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(convert_rowtype_expr), field(4)" pk
    | Some (5, Pbrt.Varint) -> begin
      v.location <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(convert_rowtype_expr), field(5)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    xpr = v.xpr;
    arg = v.arg;
    resulttype = v.resulttype;
    convertformat = v.convertformat;
    location = v.location;
  } : convert_rowtype_expr)

and decode_pb_collate_expr d =
  let v = default_collate_expr_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.xpr <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(collate_expr), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.arg <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(collate_expr), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.coll_oid <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(collate_expr), field(3)" pk
    | Some (4, Pbrt.Varint) -> begin
      v.location <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(collate_expr), field(4)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    xpr = v.xpr;
    arg = v.arg;
    coll_oid = v.coll_oid;
    location = v.location;
  } : collate_expr)

and decode_pb_case_expr d =
  let v = default_case_expr_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.args <- List.rev v.args;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.xpr <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(case_expr), field(1)" pk
    | Some (2, Pbrt.Varint) -> begin
      v.casetype <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(case_expr), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.casecollid <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(case_expr), field(3)" pk
    | Some (4, Pbrt.Bytes) -> begin
      v.arg <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(case_expr), field(4)" pk
    | Some (5, Pbrt.Bytes) -> begin
      v.args <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.args;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(case_expr), field(5)" pk
    | Some (6, Pbrt.Bytes) -> begin
      v.defresult <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (6, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(case_expr), field(6)" pk
    | Some (7, Pbrt.Varint) -> begin
      v.location <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (7, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(case_expr), field(7)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    xpr = v.xpr;
    casetype = v.casetype;
    casecollid = v.casecollid;
    arg = v.arg;
    args = v.args;
    defresult = v.defresult;
    location = v.location;
  } : case_expr)

and decode_pb_case_when d =
  let v = default_case_when_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.xpr <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(case_when), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.expr <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(case_when), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.result <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(case_when), field(3)" pk
    | Some (4, Pbrt.Varint) -> begin
      v.location <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(case_when), field(4)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    xpr = v.xpr;
    expr = v.expr;
    result = v.result;
    location = v.location;
  } : case_when)

and decode_pb_case_test_expr d =
  let v = default_case_test_expr_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.xpr <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(case_test_expr), field(1)" pk
    | Some (2, Pbrt.Varint) -> begin
      v.type_id <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(case_test_expr), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.type_mod <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(case_test_expr), field(3)" pk
    | Some (4, Pbrt.Varint) -> begin
      v.collation <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(case_test_expr), field(4)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    xpr = v.xpr;
    type_id = v.type_id;
    type_mod = v.type_mod;
    collation = v.collation;
  } : case_test_expr)

and decode_pb_array_expr d =
  let v = default_array_expr_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.elements <- List.rev v.elements;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.xpr <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(array_expr), field(1)" pk
    | Some (2, Pbrt.Varint) -> begin
      v.array_typeid <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(array_expr), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.array_collid <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(array_expr), field(3)" pk
    | Some (4, Pbrt.Varint) -> begin
      v.element_typeid <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(array_expr), field(4)" pk
    | Some (5, Pbrt.Bytes) -> begin
      v.elements <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.elements;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(array_expr), field(5)" pk
    | Some (6, Pbrt.Varint) -> begin
      v.multidims <- Pbrt.Decoder.bool d;
    end
    | Some (6, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(array_expr), field(6)" pk
    | Some (7, Pbrt.Varint) -> begin
      v.location <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (7, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(array_expr), field(7)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    xpr = v.xpr;
    array_typeid = v.array_typeid;
    array_collid = v.array_collid;
    element_typeid = v.element_typeid;
    elements = v.elements;
    multidims = v.multidims;
    location = v.location;
  } : array_expr)

and decode_pb_row_expr d =
  let v = default_row_expr_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.colnames <- List.rev v.colnames;
      v.args <- List.rev v.args;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.xpr <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(row_expr), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.args <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.args;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(row_expr), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.row_typeid <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(row_expr), field(3)" pk
    | Some (4, Pbrt.Varint) -> begin
      v.row_format <- decode_pb_coercion_form d;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(row_expr), field(4)" pk
    | Some (5, Pbrt.Bytes) -> begin
      v.colnames <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.colnames;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(row_expr), field(5)" pk
    | Some (6, Pbrt.Varint) -> begin
      v.location <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (6, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(row_expr), field(6)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    xpr = v.xpr;
    args = v.args;
    row_typeid = v.row_typeid;
    row_format = v.row_format;
    colnames = v.colnames;
    location = v.location;
  } : row_expr)

and decode_pb_row_compare_expr d =
  let v = default_row_compare_expr_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.rargs <- List.rev v.rargs;
      v.largs <- List.rev v.largs;
      v.inputcollids <- List.rev v.inputcollids;
      v.opfamilies <- List.rev v.opfamilies;
      v.opnos <- List.rev v.opnos;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.xpr <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(row_compare_expr), field(1)" pk
    | Some (2, Pbrt.Varint) -> begin
      v.rctype <- decode_pb_row_compare_type d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(row_compare_expr), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.opnos <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.opnos;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(row_compare_expr), field(3)" pk
    | Some (4, Pbrt.Bytes) -> begin
      v.opfamilies <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.opfamilies;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(row_compare_expr), field(4)" pk
    | Some (5, Pbrt.Bytes) -> begin
      v.inputcollids <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.inputcollids;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(row_compare_expr), field(5)" pk
    | Some (6, Pbrt.Bytes) -> begin
      v.largs <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.largs;
    end
    | Some (6, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(row_compare_expr), field(6)" pk
    | Some (7, Pbrt.Bytes) -> begin
      v.rargs <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.rargs;
    end
    | Some (7, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(row_compare_expr), field(7)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    xpr = v.xpr;
    rctype = v.rctype;
    opnos = v.opnos;
    opfamilies = v.opfamilies;
    inputcollids = v.inputcollids;
    largs = v.largs;
    rargs = v.rargs;
  } : row_compare_expr)

and decode_pb_coalesce_expr d =
  let v = default_coalesce_expr_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.args <- List.rev v.args;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.xpr <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(coalesce_expr), field(1)" pk
    | Some (2, Pbrt.Varint) -> begin
      v.coalescetype <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(coalesce_expr), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.coalescecollid <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(coalesce_expr), field(3)" pk
    | Some (4, Pbrt.Bytes) -> begin
      v.args <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.args;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(coalesce_expr), field(4)" pk
    | Some (5, Pbrt.Varint) -> begin
      v.location <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(coalesce_expr), field(5)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    xpr = v.xpr;
    coalescetype = v.coalescetype;
    coalescecollid = v.coalescecollid;
    args = v.args;
    location = v.location;
  } : coalesce_expr)

and decode_pb_min_max_expr d =
  let v = default_min_max_expr_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.args <- List.rev v.args;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.xpr <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(min_max_expr), field(1)" pk
    | Some (2, Pbrt.Varint) -> begin
      v.minmaxtype <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(min_max_expr), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.minmaxcollid <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(min_max_expr), field(3)" pk
    | Some (4, Pbrt.Varint) -> begin
      v.inputcollid <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(min_max_expr), field(4)" pk
    | Some (5, Pbrt.Varint) -> begin
      v.op <- decode_pb_min_max_op d;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(min_max_expr), field(5)" pk
    | Some (6, Pbrt.Bytes) -> begin
      v.args <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.args;
    end
    | Some (6, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(min_max_expr), field(6)" pk
    | Some (7, Pbrt.Varint) -> begin
      v.location <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (7, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(min_max_expr), field(7)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    xpr = v.xpr;
    minmaxtype = v.minmaxtype;
    minmaxcollid = v.minmaxcollid;
    inputcollid = v.inputcollid;
    op = v.op;
    args = v.args;
    location = v.location;
  } : min_max_expr)

and decode_pb_sqlvalue_function d =
  let v = default_sqlvalue_function_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.xpr <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(sqlvalue_function), field(1)" pk
    | Some (2, Pbrt.Varint) -> begin
      v.op <- decode_pb_sqlvalue_function_op d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(sqlvalue_function), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.type_ <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(sqlvalue_function), field(3)" pk
    | Some (4, Pbrt.Varint) -> begin
      v.typmod <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(sqlvalue_function), field(4)" pk
    | Some (5, Pbrt.Varint) -> begin
      v.location <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(sqlvalue_function), field(5)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    xpr = v.xpr;
    op = v.op;
    type_ = v.type_;
    typmod = v.typmod;
    location = v.location;
  } : sqlvalue_function)

and decode_pb_xml_expr d =
  let v = default_xml_expr_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.args <- List.rev v.args;
      v.arg_names <- List.rev v.arg_names;
      v.named_args <- List.rev v.named_args;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.xpr <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(xml_expr), field(1)" pk
    | Some (2, Pbrt.Varint) -> begin
      v.op <- decode_pb_xml_expr_op d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(xml_expr), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.name <- Pbrt.Decoder.string d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(xml_expr), field(3)" pk
    | Some (4, Pbrt.Bytes) -> begin
      v.named_args <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.named_args;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(xml_expr), field(4)" pk
    | Some (5, Pbrt.Bytes) -> begin
      v.arg_names <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.arg_names;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(xml_expr), field(5)" pk
    | Some (6, Pbrt.Bytes) -> begin
      v.args <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.args;
    end
    | Some (6, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(xml_expr), field(6)" pk
    | Some (7, Pbrt.Varint) -> begin
      v.xmloption <- decode_pb_xml_option_type d;
    end
    | Some (7, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(xml_expr), field(7)" pk
    | Some (8, Pbrt.Varint) -> begin
      v.type_ <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (8, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(xml_expr), field(8)" pk
    | Some (9, Pbrt.Varint) -> begin
      v.typmod <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (9, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(xml_expr), field(9)" pk
    | Some (10, Pbrt.Varint) -> begin
      v.location <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (10, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(xml_expr), field(10)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    xpr = v.xpr;
    op = v.op;
    name = v.name;
    named_args = v.named_args;
    arg_names = v.arg_names;
    args = v.args;
    xmloption = v.xmloption;
    type_ = v.type_;
    typmod = v.typmod;
    location = v.location;
  } : xml_expr)

and decode_pb_null_test d =
  let v = default_null_test_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.xpr <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(null_test), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.arg <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(null_test), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.nulltesttype <- decode_pb_null_test_type d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(null_test), field(3)" pk
    | Some (4, Pbrt.Varint) -> begin
      v.argisrow <- Pbrt.Decoder.bool d;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(null_test), field(4)" pk
    | Some (5, Pbrt.Varint) -> begin
      v.location <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(null_test), field(5)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    xpr = v.xpr;
    arg = v.arg;
    nulltesttype = v.nulltesttype;
    argisrow = v.argisrow;
    location = v.location;
  } : null_test)

and decode_pb_boolean_test d =
  let v = default_boolean_test_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.xpr <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(boolean_test), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.arg <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(boolean_test), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.booltesttype <- decode_pb_bool_test_type d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(boolean_test), field(3)" pk
    | Some (4, Pbrt.Varint) -> begin
      v.location <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(boolean_test), field(4)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    xpr = v.xpr;
    arg = v.arg;
    booltesttype = v.booltesttype;
    location = v.location;
  } : boolean_test)

and decode_pb_coerce_to_domain d =
  let v = default_coerce_to_domain_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.xpr <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(coerce_to_domain), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.arg <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(coerce_to_domain), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.resulttype <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(coerce_to_domain), field(3)" pk
    | Some (4, Pbrt.Varint) -> begin
      v.resulttypmod <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(coerce_to_domain), field(4)" pk
    | Some (5, Pbrt.Varint) -> begin
      v.resultcollid <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(coerce_to_domain), field(5)" pk
    | Some (6, Pbrt.Varint) -> begin
      v.coercionformat <- decode_pb_coercion_form d;
    end
    | Some (6, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(coerce_to_domain), field(6)" pk
    | Some (7, Pbrt.Varint) -> begin
      v.location <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (7, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(coerce_to_domain), field(7)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    xpr = v.xpr;
    arg = v.arg;
    resulttype = v.resulttype;
    resulttypmod = v.resulttypmod;
    resultcollid = v.resultcollid;
    coercionformat = v.coercionformat;
    location = v.location;
  } : coerce_to_domain)

and decode_pb_coerce_to_domain_value d =
  let v = default_coerce_to_domain_value_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.xpr <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(coerce_to_domain_value), field(1)" pk
    | Some (2, Pbrt.Varint) -> begin
      v.type_id <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(coerce_to_domain_value), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.type_mod <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(coerce_to_domain_value), field(3)" pk
    | Some (4, Pbrt.Varint) -> begin
      v.collation <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(coerce_to_domain_value), field(4)" pk
    | Some (5, Pbrt.Varint) -> begin
      v.location <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(coerce_to_domain_value), field(5)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    xpr = v.xpr;
    type_id = v.type_id;
    type_mod = v.type_mod;
    collation = v.collation;
    location = v.location;
  } : coerce_to_domain_value)

and decode_pb_set_to_default d =
  let v = default_set_to_default_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.xpr <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(set_to_default), field(1)" pk
    | Some (2, Pbrt.Varint) -> begin
      v.type_id <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(set_to_default), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.type_mod <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(set_to_default), field(3)" pk
    | Some (4, Pbrt.Varint) -> begin
      v.collation <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(set_to_default), field(4)" pk
    | Some (5, Pbrt.Varint) -> begin
      v.location <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(set_to_default), field(5)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    xpr = v.xpr;
    type_id = v.type_id;
    type_mod = v.type_mod;
    collation = v.collation;
    location = v.location;
  } : set_to_default)

and decode_pb_current_of_expr d =
  let v = default_current_of_expr_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.xpr <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(current_of_expr), field(1)" pk
    | Some (2, Pbrt.Varint) -> begin
      v.cvarno <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(current_of_expr), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.cursor_name <- Pbrt.Decoder.string d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(current_of_expr), field(3)" pk
    | Some (4, Pbrt.Varint) -> begin
      v.cursor_param <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(current_of_expr), field(4)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    xpr = v.xpr;
    cvarno = v.cvarno;
    cursor_name = v.cursor_name;
    cursor_param = v.cursor_param;
  } : current_of_expr)

and decode_pb_next_value_expr d =
  let v = default_next_value_expr_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.xpr <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(next_value_expr), field(1)" pk
    | Some (2, Pbrt.Varint) -> begin
      v.seqid <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(next_value_expr), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.type_id <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(next_value_expr), field(3)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    xpr = v.xpr;
    seqid = v.seqid;
    type_id = v.type_id;
  } : next_value_expr)

and decode_pb_inference_elem d =
  let v = default_inference_elem_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.xpr <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(inference_elem), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.expr <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(inference_elem), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.infercollid <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(inference_elem), field(3)" pk
    | Some (4, Pbrt.Varint) -> begin
      v.inferopclass <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(inference_elem), field(4)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    xpr = v.xpr;
    expr = v.expr;
    infercollid = v.infercollid;
    inferopclass = v.inferopclass;
  } : inference_elem)

and decode_pb_target_entry d =
  let v = default_target_entry_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.xpr <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(target_entry), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.expr <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(target_entry), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.resno <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(target_entry), field(3)" pk
    | Some (4, Pbrt.Bytes) -> begin
      v.resname <- Pbrt.Decoder.string d;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(target_entry), field(4)" pk
    | Some (5, Pbrt.Varint) -> begin
      v.ressortgroupref <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(target_entry), field(5)" pk
    | Some (6, Pbrt.Varint) -> begin
      v.resorigtbl <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (6, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(target_entry), field(6)" pk
    | Some (7, Pbrt.Varint) -> begin
      v.resorigcol <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (7, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(target_entry), field(7)" pk
    | Some (8, Pbrt.Varint) -> begin
      v.resjunk <- Pbrt.Decoder.bool d;
    end
    | Some (8, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(target_entry), field(8)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    xpr = v.xpr;
    expr = v.expr;
    resno = v.resno;
    resname = v.resname;
    ressortgroupref = v.ressortgroupref;
    resorigtbl = v.resorigtbl;
    resorigcol = v.resorigcol;
    resjunk = v.resjunk;
  } : target_entry)

and decode_pb_join_expr d =
  let v = default_join_expr_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.using_clause <- List.rev v.using_clause;
    ); continue__ := false
    | Some (1, Pbrt.Varint) -> begin
      v.jointype <- decode_pb_join_type d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(join_expr), field(1)" pk
    | Some (2, Pbrt.Varint) -> begin
      v.is_natural <- Pbrt.Decoder.bool d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(join_expr), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.larg <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(join_expr), field(3)" pk
    | Some (4, Pbrt.Bytes) -> begin
      v.rarg <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(join_expr), field(4)" pk
    | Some (5, Pbrt.Bytes) -> begin
      v.using_clause <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.using_clause;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(join_expr), field(5)" pk
    | Some (6, Pbrt.Bytes) -> begin
      v.quals <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (6, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(join_expr), field(6)" pk
    | Some (7, Pbrt.Bytes) -> begin
      v.alias <- Some (decode_pb_alias (Pbrt.Decoder.nested d));
    end
    | Some (7, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(join_expr), field(7)" pk
    | Some (8, Pbrt.Varint) -> begin
      v.rtindex <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (8, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(join_expr), field(8)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    jointype = v.jointype;
    is_natural = v.is_natural;
    larg = v.larg;
    rarg = v.rarg;
    using_clause = v.using_clause;
    quals = v.quals;
    alias = v.alias;
    rtindex = v.rtindex;
  } : join_expr)

and decode_pb_from_expr d =
  let v = default_from_expr_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.fromlist <- List.rev v.fromlist;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.fromlist <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.fromlist;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(from_expr), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.quals <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(from_expr), field(2)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    fromlist = v.fromlist;
    quals = v.quals;
  } : from_expr)

and decode_pb_on_conflict_expr d =
  let v = default_on_conflict_expr_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.excl_rel_tlist <- List.rev v.excl_rel_tlist;
      v.on_conflict_set <- List.rev v.on_conflict_set;
      v.arbiter_elems <- List.rev v.arbiter_elems;
    ); continue__ := false
    | Some (1, Pbrt.Varint) -> begin
      v.action <- decode_pb_on_conflict_action d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(on_conflict_expr), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.arbiter_elems <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.arbiter_elems;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(on_conflict_expr), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.arbiter_where <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(on_conflict_expr), field(3)" pk
    | Some (4, Pbrt.Varint) -> begin
      v.constraint_ <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(on_conflict_expr), field(4)" pk
    | Some (5, Pbrt.Bytes) -> begin
      v.on_conflict_set <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.on_conflict_set;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(on_conflict_expr), field(5)" pk
    | Some (6, Pbrt.Bytes) -> begin
      v.on_conflict_where <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (6, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(on_conflict_expr), field(6)" pk
    | Some (7, Pbrt.Varint) -> begin
      v.excl_rel_index <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (7, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(on_conflict_expr), field(7)" pk
    | Some (8, Pbrt.Bytes) -> begin
      v.excl_rel_tlist <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.excl_rel_tlist;
    end
    | Some (8, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(on_conflict_expr), field(8)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    action = v.action;
    arbiter_elems = v.arbiter_elems;
    arbiter_where = v.arbiter_where;
    constraint_ = v.constraint_;
    on_conflict_set = v.on_conflict_set;
    on_conflict_where = v.on_conflict_where;
    excl_rel_index = v.excl_rel_index;
    excl_rel_tlist = v.excl_rel_tlist;
  } : on_conflict_expr)

and decode_pb_into_clause d =
  let v = default_into_clause_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.options <- List.rev v.options;
      v.col_names <- List.rev v.col_names;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.rel <- Some (decode_pb_range_var (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(into_clause), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.col_names <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.col_names;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(into_clause), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.access_method <- Pbrt.Decoder.string d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(into_clause), field(3)" pk
    | Some (4, Pbrt.Bytes) -> begin
      v.options <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.options;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(into_clause), field(4)" pk
    | Some (5, Pbrt.Varint) -> begin
      v.on_commit <- decode_pb_on_commit_action d;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(into_clause), field(5)" pk
    | Some (6, Pbrt.Bytes) -> begin
      v.table_space_name <- Pbrt.Decoder.string d;
    end
    | Some (6, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(into_clause), field(6)" pk
    | Some (7, Pbrt.Bytes) -> begin
      v.view_query <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (7, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(into_clause), field(7)" pk
    | Some (8, Pbrt.Varint) -> begin
      v.skip_data <- Pbrt.Decoder.bool d;
    end
    | Some (8, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(into_clause), field(8)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    rel = v.rel;
    col_names = v.col_names;
    access_method = v.access_method;
    options = v.options;
    on_commit = v.on_commit;
    table_space_name = v.table_space_name;
    view_query = v.view_query;
    skip_data = v.skip_data;
  } : into_clause)

and decode_pb_query d =
  let v = default_query_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.with_check_options <- List.rev v.with_check_options;
      v.constraint_deps <- List.rev v.constraint_deps;
      v.row_marks <- List.rev v.row_marks;
      v.sort_clause <- List.rev v.sort_clause;
      v.distinct_clause <- List.rev v.distinct_clause;
      v.window_clause <- List.rev v.window_clause;
      v.grouping_sets <- List.rev v.grouping_sets;
      v.group_clause <- List.rev v.group_clause;
      v.returning_list <- List.rev v.returning_list;
      v.target_list <- List.rev v.target_list;
      v.rtable <- List.rev v.rtable;
      v.cte_list <- List.rev v.cte_list;
    ); continue__ := false
    | Some (1, Pbrt.Varint) -> begin
      v.command_type <- decode_pb_cmd_type d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(query), field(1)" pk
    | Some (2, Pbrt.Varint) -> begin
      v.query_source <- decode_pb_query_source d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(query), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.can_set_tag <- Pbrt.Decoder.bool d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(query), field(3)" pk
    | Some (4, Pbrt.Bytes) -> begin
      v.utility_stmt <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(query), field(4)" pk
    | Some (5, Pbrt.Varint) -> begin
      v.result_relation <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(query), field(5)" pk
    | Some (6, Pbrt.Varint) -> begin
      v.has_aggs <- Pbrt.Decoder.bool d;
    end
    | Some (6, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(query), field(6)" pk
    | Some (7, Pbrt.Varint) -> begin
      v.has_window_funcs <- Pbrt.Decoder.bool d;
    end
    | Some (7, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(query), field(7)" pk
    | Some (8, Pbrt.Varint) -> begin
      v.has_target_srfs <- Pbrt.Decoder.bool d;
    end
    | Some (8, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(query), field(8)" pk
    | Some (9, Pbrt.Varint) -> begin
      v.has_sub_links <- Pbrt.Decoder.bool d;
    end
    | Some (9, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(query), field(9)" pk
    | Some (10, Pbrt.Varint) -> begin
      v.has_distinct_on <- Pbrt.Decoder.bool d;
    end
    | Some (10, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(query), field(10)" pk
    | Some (11, Pbrt.Varint) -> begin
      v.has_recursive <- Pbrt.Decoder.bool d;
    end
    | Some (11, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(query), field(11)" pk
    | Some (12, Pbrt.Varint) -> begin
      v.has_modifying_cte <- Pbrt.Decoder.bool d;
    end
    | Some (12, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(query), field(12)" pk
    | Some (13, Pbrt.Varint) -> begin
      v.has_for_update <- Pbrt.Decoder.bool d;
    end
    | Some (13, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(query), field(13)" pk
    | Some (14, Pbrt.Varint) -> begin
      v.has_row_security <- Pbrt.Decoder.bool d;
    end
    | Some (14, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(query), field(14)" pk
    | Some (15, Pbrt.Bytes) -> begin
      v.cte_list <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.cte_list;
    end
    | Some (15, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(query), field(15)" pk
    | Some (16, Pbrt.Bytes) -> begin
      v.rtable <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.rtable;
    end
    | Some (16, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(query), field(16)" pk
    | Some (17, Pbrt.Bytes) -> begin
      v.jointree <- Some (decode_pb_from_expr (Pbrt.Decoder.nested d));
    end
    | Some (17, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(query), field(17)" pk
    | Some (18, Pbrt.Bytes) -> begin
      v.target_list <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.target_list;
    end
    | Some (18, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(query), field(18)" pk
    | Some (19, Pbrt.Varint) -> begin
      v.override <- decode_pb_overriding_kind d;
    end
    | Some (19, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(query), field(19)" pk
    | Some (20, Pbrt.Bytes) -> begin
      v.on_conflict <- Some (decode_pb_on_conflict_expr (Pbrt.Decoder.nested d));
    end
    | Some (20, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(query), field(20)" pk
    | Some (21, Pbrt.Bytes) -> begin
      v.returning_list <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.returning_list;
    end
    | Some (21, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(query), field(21)" pk
    | Some (22, Pbrt.Bytes) -> begin
      v.group_clause <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.group_clause;
    end
    | Some (22, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(query), field(22)" pk
    | Some (23, Pbrt.Bytes) -> begin
      v.grouping_sets <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.grouping_sets;
    end
    | Some (23, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(query), field(23)" pk
    | Some (24, Pbrt.Bytes) -> begin
      v.having_qual <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (24, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(query), field(24)" pk
    | Some (25, Pbrt.Bytes) -> begin
      v.window_clause <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.window_clause;
    end
    | Some (25, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(query), field(25)" pk
    | Some (26, Pbrt.Bytes) -> begin
      v.distinct_clause <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.distinct_clause;
    end
    | Some (26, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(query), field(26)" pk
    | Some (27, Pbrt.Bytes) -> begin
      v.sort_clause <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.sort_clause;
    end
    | Some (27, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(query), field(27)" pk
    | Some (28, Pbrt.Bytes) -> begin
      v.limit_offset <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (28, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(query), field(28)" pk
    | Some (29, Pbrt.Bytes) -> begin
      v.limit_count <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (29, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(query), field(29)" pk
    | Some (30, Pbrt.Varint) -> begin
      v.limit_option <- decode_pb_limit_option d;
    end
    | Some (30, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(query), field(30)" pk
    | Some (31, Pbrt.Bytes) -> begin
      v.row_marks <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.row_marks;
    end
    | Some (31, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(query), field(31)" pk
    | Some (32, Pbrt.Bytes) -> begin
      v.set_operations <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (32, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(query), field(32)" pk
    | Some (33, Pbrt.Bytes) -> begin
      v.constraint_deps <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.constraint_deps;
    end
    | Some (33, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(query), field(33)" pk
    | Some (34, Pbrt.Bytes) -> begin
      v.with_check_options <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.with_check_options;
    end
    | Some (34, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(query), field(34)" pk
    | Some (35, Pbrt.Varint) -> begin
      v.stmt_location <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (35, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(query), field(35)" pk
    | Some (36, Pbrt.Varint) -> begin
      v.stmt_len <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (36, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(query), field(36)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    command_type = v.command_type;
    query_source = v.query_source;
    can_set_tag = v.can_set_tag;
    utility_stmt = v.utility_stmt;
    result_relation = v.result_relation;
    has_aggs = v.has_aggs;
    has_window_funcs = v.has_window_funcs;
    has_target_srfs = v.has_target_srfs;
    has_sub_links = v.has_sub_links;
    has_distinct_on = v.has_distinct_on;
    has_recursive = v.has_recursive;
    has_modifying_cte = v.has_modifying_cte;
    has_for_update = v.has_for_update;
    has_row_security = v.has_row_security;
    cte_list = v.cte_list;
    rtable = v.rtable;
    jointree = v.jointree;
    target_list = v.target_list;
    override = v.override;
    on_conflict = v.on_conflict;
    returning_list = v.returning_list;
    group_clause = v.group_clause;
    grouping_sets = v.grouping_sets;
    having_qual = v.having_qual;
    window_clause = v.window_clause;
    distinct_clause = v.distinct_clause;
    sort_clause = v.sort_clause;
    limit_offset = v.limit_offset;
    limit_count = v.limit_count;
    limit_option = v.limit_option;
    row_marks = v.row_marks;
    set_operations = v.set_operations;
    constraint_deps = v.constraint_deps;
    with_check_options = v.with_check_options;
    stmt_location = v.stmt_location;
    stmt_len = v.stmt_len;
  } : query)

and decode_pb_insert_stmt d =
  let v = default_insert_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.returning_list <- List.rev v.returning_list;
      v.cols <- List.rev v.cols;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.relation <- Some (decode_pb_range_var (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(insert_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.cols <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.cols;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(insert_stmt), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.select_stmt <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(insert_stmt), field(3)" pk
    | Some (4, Pbrt.Bytes) -> begin
      v.on_conflict_clause <- Some (decode_pb_on_conflict_clause (Pbrt.Decoder.nested d));
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(insert_stmt), field(4)" pk
    | Some (5, Pbrt.Bytes) -> begin
      v.returning_list <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.returning_list;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(insert_stmt), field(5)" pk
    | Some (6, Pbrt.Bytes) -> begin
      v.with_clause <- Some (decode_pb_with_clause (Pbrt.Decoder.nested d));
    end
    | Some (6, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(insert_stmt), field(6)" pk
    | Some (7, Pbrt.Varint) -> begin
      v.override <- decode_pb_overriding_kind d;
    end
    | Some (7, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(insert_stmt), field(7)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    relation = v.relation;
    cols = v.cols;
    select_stmt = v.select_stmt;
    on_conflict_clause = v.on_conflict_clause;
    returning_list = v.returning_list;
    with_clause = v.with_clause;
    override = v.override;
  } : insert_stmt)

and decode_pb_on_conflict_clause d =
  let v = default_on_conflict_clause_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.target_list <- List.rev v.target_list;
    ); continue__ := false
    | Some (1, Pbrt.Varint) -> begin
      v.action <- decode_pb_on_conflict_action d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(on_conflict_clause), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.infer <- Some (decode_pb_infer_clause (Pbrt.Decoder.nested d));
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(on_conflict_clause), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.target_list <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.target_list;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(on_conflict_clause), field(3)" pk
    | Some (4, Pbrt.Bytes) -> begin
      v.where_clause <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(on_conflict_clause), field(4)" pk
    | Some (5, Pbrt.Varint) -> begin
      v.location <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(on_conflict_clause), field(5)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    action = v.action;
    infer = v.infer;
    target_list = v.target_list;
    where_clause = v.where_clause;
    location = v.location;
  } : on_conflict_clause)

and decode_pb_infer_clause d =
  let v = default_infer_clause_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.index_elems <- List.rev v.index_elems;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.index_elems <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.index_elems;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(infer_clause), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.where_clause <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(infer_clause), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.conname <- Pbrt.Decoder.string d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(infer_clause), field(3)" pk
    | Some (4, Pbrt.Varint) -> begin
      v.location <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(infer_clause), field(4)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    index_elems = v.index_elems;
    where_clause = v.where_clause;
    conname = v.conname;
    location = v.location;
  } : infer_clause)

and decode_pb_with_clause d =
  let v = default_with_clause_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.ctes <- List.rev v.ctes;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.ctes <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.ctes;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(with_clause), field(1)" pk
    | Some (2, Pbrt.Varint) -> begin
      v.recursive <- Pbrt.Decoder.bool d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(with_clause), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.location <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(with_clause), field(3)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    ctes = v.ctes;
    recursive = v.recursive;
    location = v.location;
  } : with_clause)

and decode_pb_delete_stmt d =
  let v = default_delete_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.returning_list <- List.rev v.returning_list;
      v.using_clause <- List.rev v.using_clause;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.relation <- Some (decode_pb_range_var (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(delete_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.using_clause <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.using_clause;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(delete_stmt), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.where_clause <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(delete_stmt), field(3)" pk
    | Some (4, Pbrt.Bytes) -> begin
      v.returning_list <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.returning_list;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(delete_stmt), field(4)" pk
    | Some (5, Pbrt.Bytes) -> begin
      v.with_clause <- Some (decode_pb_with_clause (Pbrt.Decoder.nested d));
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(delete_stmt), field(5)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    relation = v.relation;
    using_clause = v.using_clause;
    where_clause = v.where_clause;
    returning_list = v.returning_list;
    with_clause = v.with_clause;
  } : delete_stmt)

and decode_pb_update_stmt d =
  let v = default_update_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.returning_list <- List.rev v.returning_list;
      v.from_clause <- List.rev v.from_clause;
      v.target_list <- List.rev v.target_list;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.relation <- Some (decode_pb_range_var (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(update_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.target_list <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.target_list;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(update_stmt), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.where_clause <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(update_stmt), field(3)" pk
    | Some (4, Pbrt.Bytes) -> begin
      v.from_clause <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.from_clause;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(update_stmt), field(4)" pk
    | Some (5, Pbrt.Bytes) -> begin
      v.returning_list <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.returning_list;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(update_stmt), field(5)" pk
    | Some (6, Pbrt.Bytes) -> begin
      v.with_clause <- Some (decode_pb_with_clause (Pbrt.Decoder.nested d));
    end
    | Some (6, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(update_stmt), field(6)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    relation = v.relation;
    target_list = v.target_list;
    where_clause = v.where_clause;
    from_clause = v.from_clause;
    returning_list = v.returning_list;
    with_clause = v.with_clause;
  } : update_stmt)

and decode_pb_select_stmt d =
  let v = default_select_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.locking_clause <- List.rev v.locking_clause;
      v.sort_clause <- List.rev v.sort_clause;
      v.values_lists <- List.rev v.values_lists;
      v.window_clause <- List.rev v.window_clause;
      v.group_clause <- List.rev v.group_clause;
      v.from_clause <- List.rev v.from_clause;
      v.target_list <- List.rev v.target_list;
      v.distinct_clause <- List.rev v.distinct_clause;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.distinct_clause <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.distinct_clause;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(select_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.into_clause <- Some (decode_pb_into_clause (Pbrt.Decoder.nested d));
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(select_stmt), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.target_list <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.target_list;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(select_stmt), field(3)" pk
    | Some (4, Pbrt.Bytes) -> begin
      v.from_clause <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.from_clause;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(select_stmt), field(4)" pk
    | Some (5, Pbrt.Bytes) -> begin
      v.where_clause <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(select_stmt), field(5)" pk
    | Some (6, Pbrt.Bytes) -> begin
      v.group_clause <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.group_clause;
    end
    | Some (6, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(select_stmt), field(6)" pk
    | Some (7, Pbrt.Bytes) -> begin
      v.having_clause <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (7, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(select_stmt), field(7)" pk
    | Some (8, Pbrt.Bytes) -> begin
      v.window_clause <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.window_clause;
    end
    | Some (8, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(select_stmt), field(8)" pk
    | Some (9, Pbrt.Bytes) -> begin
      v.values_lists <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.values_lists;
    end
    | Some (9, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(select_stmt), field(9)" pk
    | Some (10, Pbrt.Bytes) -> begin
      v.sort_clause <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.sort_clause;
    end
    | Some (10, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(select_stmt), field(10)" pk
    | Some (11, Pbrt.Bytes) -> begin
      v.limit_offset <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (11, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(select_stmt), field(11)" pk
    | Some (12, Pbrt.Bytes) -> begin
      v.limit_count <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (12, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(select_stmt), field(12)" pk
    | Some (13, Pbrt.Varint) -> begin
      v.limit_option <- decode_pb_limit_option d;
    end
    | Some (13, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(select_stmt), field(13)" pk
    | Some (14, Pbrt.Bytes) -> begin
      v.locking_clause <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.locking_clause;
    end
    | Some (14, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(select_stmt), field(14)" pk
    | Some (15, Pbrt.Bytes) -> begin
      v.with_clause <- Some (decode_pb_with_clause (Pbrt.Decoder.nested d));
    end
    | Some (15, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(select_stmt), field(15)" pk
    | Some (16, Pbrt.Varint) -> begin
      v.op <- decode_pb_set_operation d;
    end
    | Some (16, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(select_stmt), field(16)" pk
    | Some (17, Pbrt.Varint) -> begin
      v.all <- Pbrt.Decoder.bool d;
    end
    | Some (17, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(select_stmt), field(17)" pk
    | Some (18, Pbrt.Bytes) -> begin
      v.larg <- Some (decode_pb_select_stmt (Pbrt.Decoder.nested d));
    end
    | Some (18, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(select_stmt), field(18)" pk
    | Some (19, Pbrt.Bytes) -> begin
      v.rarg <- Some (decode_pb_select_stmt (Pbrt.Decoder.nested d));
    end
    | Some (19, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(select_stmt), field(19)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    distinct_clause = v.distinct_clause;
    into_clause = v.into_clause;
    target_list = v.target_list;
    from_clause = v.from_clause;
    where_clause = v.where_clause;
    group_clause = v.group_clause;
    having_clause = v.having_clause;
    window_clause = v.window_clause;
    values_lists = v.values_lists;
    sort_clause = v.sort_clause;
    limit_offset = v.limit_offset;
    limit_count = v.limit_count;
    limit_option = v.limit_option;
    locking_clause = v.locking_clause;
    with_clause = v.with_clause;
    op = v.op;
    all = v.all;
    larg = v.larg;
    rarg = v.rarg;
  } : select_stmt)

and decode_pb_alter_table_stmt d =
  let v = default_alter_table_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.cmds <- List.rev v.cmds;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.relation <- Some (decode_pb_range_var (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_table_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.cmds <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.cmds;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_table_stmt), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.relkind <- decode_pb_object_type d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_table_stmt), field(3)" pk
    | Some (4, Pbrt.Varint) -> begin
      v.missing_ok <- Pbrt.Decoder.bool d;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_table_stmt), field(4)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    relation = v.relation;
    cmds = v.cmds;
    relkind = v.relkind;
    missing_ok = v.missing_ok;
  } : alter_table_stmt)

and decode_pb_alter_table_cmd d =
  let v = default_alter_table_cmd_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Varint) -> begin
      v.subtype <- decode_pb_alter_table_type d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_table_cmd), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.name <- Pbrt.Decoder.string d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_table_cmd), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.num <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_table_cmd), field(3)" pk
    | Some (4, Pbrt.Bytes) -> begin
      v.newowner <- Some (decode_pb_role_spec (Pbrt.Decoder.nested d));
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_table_cmd), field(4)" pk
    | Some (5, Pbrt.Bytes) -> begin
      v.def <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_table_cmd), field(5)" pk
    | Some (6, Pbrt.Varint) -> begin
      v.behavior <- decode_pb_drop_behavior d;
    end
    | Some (6, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_table_cmd), field(6)" pk
    | Some (7, Pbrt.Varint) -> begin
      v.missing_ok <- Pbrt.Decoder.bool d;
    end
    | Some (7, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_table_cmd), field(7)" pk
    | Some (8, Pbrt.Varint) -> begin
      v.recurse <- Pbrt.Decoder.bool d;
    end
    | Some (8, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_table_cmd), field(8)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    subtype = v.subtype;
    name = v.name;
    num = v.num;
    newowner = v.newowner;
    def = v.def;
    behavior = v.behavior;
    missing_ok = v.missing_ok;
    recurse = v.recurse;
  } : alter_table_cmd)

and decode_pb_alter_domain_stmt d =
  let v = default_alter_domain_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.type_name <- List.rev v.type_name;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.subtype <- Pbrt.Decoder.string d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_domain_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.type_name <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.type_name;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_domain_stmt), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.name <- Pbrt.Decoder.string d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_domain_stmt), field(3)" pk
    | Some (4, Pbrt.Bytes) -> begin
      v.def <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_domain_stmt), field(4)" pk
    | Some (5, Pbrt.Varint) -> begin
      v.behavior <- decode_pb_drop_behavior d;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_domain_stmt), field(5)" pk
    | Some (6, Pbrt.Varint) -> begin
      v.missing_ok <- Pbrt.Decoder.bool d;
    end
    | Some (6, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_domain_stmt), field(6)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    subtype = v.subtype;
    type_name = v.type_name;
    name = v.name;
    def = v.def;
    behavior = v.behavior;
    missing_ok = v.missing_ok;
  } : alter_domain_stmt)

and decode_pb_set_operation_stmt d =
  let v = default_set_operation_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.group_clauses <- List.rev v.group_clauses;
      v.col_collations <- List.rev v.col_collations;
      v.col_typmods <- List.rev v.col_typmods;
      v.col_types <- List.rev v.col_types;
    ); continue__ := false
    | Some (1, Pbrt.Varint) -> begin
      v.op <- decode_pb_set_operation d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(set_operation_stmt), field(1)" pk
    | Some (2, Pbrt.Varint) -> begin
      v.all <- Pbrt.Decoder.bool d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(set_operation_stmt), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.larg <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(set_operation_stmt), field(3)" pk
    | Some (4, Pbrt.Bytes) -> begin
      v.rarg <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(set_operation_stmt), field(4)" pk
    | Some (5, Pbrt.Bytes) -> begin
      v.col_types <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.col_types;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(set_operation_stmt), field(5)" pk
    | Some (6, Pbrt.Bytes) -> begin
      v.col_typmods <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.col_typmods;
    end
    | Some (6, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(set_operation_stmt), field(6)" pk
    | Some (7, Pbrt.Bytes) -> begin
      v.col_collations <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.col_collations;
    end
    | Some (7, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(set_operation_stmt), field(7)" pk
    | Some (8, Pbrt.Bytes) -> begin
      v.group_clauses <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.group_clauses;
    end
    | Some (8, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(set_operation_stmt), field(8)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    op = v.op;
    all = v.all;
    larg = v.larg;
    rarg = v.rarg;
    col_types = v.col_types;
    col_typmods = v.col_typmods;
    col_collations = v.col_collations;
    group_clauses = v.group_clauses;
  } : set_operation_stmt)

and decode_pb_grant_stmt d =
  let v = default_grant_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.grantees <- List.rev v.grantees;
      v.privileges <- List.rev v.privileges;
      v.objects <- List.rev v.objects;
    ); continue__ := false
    | Some (1, Pbrt.Varint) -> begin
      v.is_grant <- Pbrt.Decoder.bool d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(grant_stmt), field(1)" pk
    | Some (2, Pbrt.Varint) -> begin
      v.targtype <- decode_pb_grant_target_type d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(grant_stmt), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.objtype <- decode_pb_object_type d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(grant_stmt), field(3)" pk
    | Some (4, Pbrt.Bytes) -> begin
      v.objects <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.objects;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(grant_stmt), field(4)" pk
    | Some (5, Pbrt.Bytes) -> begin
      v.privileges <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.privileges;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(grant_stmt), field(5)" pk
    | Some (6, Pbrt.Bytes) -> begin
      v.grantees <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.grantees;
    end
    | Some (6, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(grant_stmt), field(6)" pk
    | Some (7, Pbrt.Varint) -> begin
      v.grant_option <- Pbrt.Decoder.bool d;
    end
    | Some (7, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(grant_stmt), field(7)" pk
    | Some (8, Pbrt.Varint) -> begin
      v.behavior <- decode_pb_drop_behavior d;
    end
    | Some (8, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(grant_stmt), field(8)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    is_grant = v.is_grant;
    targtype = v.targtype;
    objtype = v.objtype;
    objects = v.objects;
    privileges = v.privileges;
    grantees = v.grantees;
    grant_option = v.grant_option;
    behavior = v.behavior;
  } : grant_stmt)

and decode_pb_grant_role_stmt d =
  let v = default_grant_role_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.grantee_roles <- List.rev v.grantee_roles;
      v.granted_roles <- List.rev v.granted_roles;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.granted_roles <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.granted_roles;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(grant_role_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.grantee_roles <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.grantee_roles;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(grant_role_stmt), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.is_grant <- Pbrt.Decoder.bool d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(grant_role_stmt), field(3)" pk
    | Some (4, Pbrt.Varint) -> begin
      v.admin_opt <- Pbrt.Decoder.bool d;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(grant_role_stmt), field(4)" pk
    | Some (5, Pbrt.Bytes) -> begin
      v.grantor <- Some (decode_pb_role_spec (Pbrt.Decoder.nested d));
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(grant_role_stmt), field(5)" pk
    | Some (6, Pbrt.Varint) -> begin
      v.behavior <- decode_pb_drop_behavior d;
    end
    | Some (6, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(grant_role_stmt), field(6)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    granted_roles = v.granted_roles;
    grantee_roles = v.grantee_roles;
    is_grant = v.is_grant;
    admin_opt = v.admin_opt;
    grantor = v.grantor;
    behavior = v.behavior;
  } : grant_role_stmt)

and decode_pb_alter_default_privileges_stmt d =
  let v = default_alter_default_privileges_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.options <- List.rev v.options;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.options <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.options;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_default_privileges_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.action <- Some (decode_pb_grant_stmt (Pbrt.Decoder.nested d));
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_default_privileges_stmt), field(2)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    options = v.options;
    action = v.action;
  } : alter_default_privileges_stmt)

and decode_pb_cluster_stmt d =
  let v = default_cluster_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.relation <- Some (decode_pb_range_var (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(cluster_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.indexname <- Pbrt.Decoder.string d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(cluster_stmt), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.options <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(cluster_stmt), field(3)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    relation = v.relation;
    indexname = v.indexname;
    options = v.options;
  } : cluster_stmt)

and decode_pb_copy_stmt d =
  let v = default_copy_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.options <- List.rev v.options;
      v.attlist <- List.rev v.attlist;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.relation <- Some (decode_pb_range_var (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(copy_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.query <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(copy_stmt), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.attlist <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.attlist;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(copy_stmt), field(3)" pk
    | Some (4, Pbrt.Varint) -> begin
      v.is_from <- Pbrt.Decoder.bool d;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(copy_stmt), field(4)" pk
    | Some (5, Pbrt.Varint) -> begin
      v.is_program <- Pbrt.Decoder.bool d;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(copy_stmt), field(5)" pk
    | Some (6, Pbrt.Bytes) -> begin
      v.filename <- Pbrt.Decoder.string d;
    end
    | Some (6, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(copy_stmt), field(6)" pk
    | Some (7, Pbrt.Bytes) -> begin
      v.options <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.options;
    end
    | Some (7, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(copy_stmt), field(7)" pk
    | Some (8, Pbrt.Bytes) -> begin
      v.where_clause <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (8, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(copy_stmt), field(8)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    relation = v.relation;
    query = v.query;
    attlist = v.attlist;
    is_from = v.is_from;
    is_program = v.is_program;
    filename = v.filename;
    options = v.options;
    where_clause = v.where_clause;
  } : copy_stmt)

and decode_pb_create_stmt d =
  let v = default_create_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.options <- List.rev v.options;
      v.constraints <- List.rev v.constraints;
      v.inh_relations <- List.rev v.inh_relations;
      v.table_elts <- List.rev v.table_elts;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.relation <- Some (decode_pb_range_var (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.table_elts <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.table_elts;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_stmt), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.inh_relations <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.inh_relations;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_stmt), field(3)" pk
    | Some (4, Pbrt.Bytes) -> begin
      v.partbound <- Some (decode_pb_partition_bound_spec (Pbrt.Decoder.nested d));
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_stmt), field(4)" pk
    | Some (5, Pbrt.Bytes) -> begin
      v.partspec <- Some (decode_pb_partition_spec (Pbrt.Decoder.nested d));
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_stmt), field(5)" pk
    | Some (6, Pbrt.Bytes) -> begin
      v.of_typename <- Some (decode_pb_type_name (Pbrt.Decoder.nested d));
    end
    | Some (6, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_stmt), field(6)" pk
    | Some (7, Pbrt.Bytes) -> begin
      v.constraints <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.constraints;
    end
    | Some (7, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_stmt), field(7)" pk
    | Some (8, Pbrt.Bytes) -> begin
      v.options <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.options;
    end
    | Some (8, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_stmt), field(8)" pk
    | Some (9, Pbrt.Varint) -> begin
      v.oncommit <- decode_pb_on_commit_action d;
    end
    | Some (9, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_stmt), field(9)" pk
    | Some (10, Pbrt.Bytes) -> begin
      v.tablespacename <- Pbrt.Decoder.string d;
    end
    | Some (10, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_stmt), field(10)" pk
    | Some (11, Pbrt.Bytes) -> begin
      v.access_method <- Pbrt.Decoder.string d;
    end
    | Some (11, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_stmt), field(11)" pk
    | Some (12, Pbrt.Varint) -> begin
      v.if_not_exists <- Pbrt.Decoder.bool d;
    end
    | Some (12, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_stmt), field(12)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    relation = v.relation;
    table_elts = v.table_elts;
    inh_relations = v.inh_relations;
    partbound = v.partbound;
    partspec = v.partspec;
    of_typename = v.of_typename;
    constraints = v.constraints;
    options = v.options;
    oncommit = v.oncommit;
    tablespacename = v.tablespacename;
    access_method = v.access_method;
    if_not_exists = v.if_not_exists;
  } : create_stmt)

and decode_pb_partition_bound_spec d =
  let v = default_partition_bound_spec_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.upperdatums <- List.rev v.upperdatums;
      v.lowerdatums <- List.rev v.lowerdatums;
      v.listdatums <- List.rev v.listdatums;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.strategy <- Pbrt.Decoder.string d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(partition_bound_spec), field(1)" pk
    | Some (2, Pbrt.Varint) -> begin
      v.is_default <- Pbrt.Decoder.bool d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(partition_bound_spec), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.modulus <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(partition_bound_spec), field(3)" pk
    | Some (4, Pbrt.Varint) -> begin
      v.remainder <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(partition_bound_spec), field(4)" pk
    | Some (5, Pbrt.Bytes) -> begin
      v.listdatums <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.listdatums;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(partition_bound_spec), field(5)" pk
    | Some (6, Pbrt.Bytes) -> begin
      v.lowerdatums <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.lowerdatums;
    end
    | Some (6, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(partition_bound_spec), field(6)" pk
    | Some (7, Pbrt.Bytes) -> begin
      v.upperdatums <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.upperdatums;
    end
    | Some (7, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(partition_bound_spec), field(7)" pk
    | Some (8, Pbrt.Varint) -> begin
      v.location <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (8, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(partition_bound_spec), field(8)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    strategy = v.strategy;
    is_default = v.is_default;
    modulus = v.modulus;
    remainder = v.remainder;
    listdatums = v.listdatums;
    lowerdatums = v.lowerdatums;
    upperdatums = v.upperdatums;
    location = v.location;
  } : partition_bound_spec)

and decode_pb_partition_spec d =
  let v = default_partition_spec_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.part_params <- List.rev v.part_params;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.strategy <- Pbrt.Decoder.string d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(partition_spec), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.part_params <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.part_params;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(partition_spec), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.location <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(partition_spec), field(3)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    strategy = v.strategy;
    part_params = v.part_params;
    location = v.location;
  } : partition_spec)

and decode_pb_type_name d =
  let v = default_type_name_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.array_bounds <- List.rev v.array_bounds;
      v.typmods <- List.rev v.typmods;
      v.names <- List.rev v.names;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.names <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.names;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(type_name), field(1)" pk
    | Some (2, Pbrt.Varint) -> begin
      v.type_oid <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(type_name), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.setof <- Pbrt.Decoder.bool d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(type_name), field(3)" pk
    | Some (4, Pbrt.Varint) -> begin
      v.pct_type <- Pbrt.Decoder.bool d;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(type_name), field(4)" pk
    | Some (5, Pbrt.Bytes) -> begin
      v.typmods <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.typmods;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(type_name), field(5)" pk
    | Some (6, Pbrt.Varint) -> begin
      v.typemod <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (6, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(type_name), field(6)" pk
    | Some (7, Pbrt.Bytes) -> begin
      v.array_bounds <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.array_bounds;
    end
    | Some (7, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(type_name), field(7)" pk
    | Some (8, Pbrt.Varint) -> begin
      v.location <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (8, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(type_name), field(8)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    names = v.names;
    type_oid = v.type_oid;
    setof = v.setof;
    pct_type = v.pct_type;
    typmods = v.typmods;
    typemod = v.typemod;
    array_bounds = v.array_bounds;
    location = v.location;
  } : type_name)

and decode_pb_define_stmt d =
  let v = default_define_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.definition <- List.rev v.definition;
      v.args <- List.rev v.args;
      v.defnames <- List.rev v.defnames;
    ); continue__ := false
    | Some (1, Pbrt.Varint) -> begin
      v.kind <- decode_pb_object_type d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(define_stmt), field(1)" pk
    | Some (2, Pbrt.Varint) -> begin
      v.oldstyle <- Pbrt.Decoder.bool d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(define_stmt), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.defnames <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.defnames;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(define_stmt), field(3)" pk
    | Some (4, Pbrt.Bytes) -> begin
      v.args <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.args;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(define_stmt), field(4)" pk
    | Some (5, Pbrt.Bytes) -> begin
      v.definition <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.definition;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(define_stmt), field(5)" pk
    | Some (6, Pbrt.Varint) -> begin
      v.if_not_exists <- Pbrt.Decoder.bool d;
    end
    | Some (6, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(define_stmt), field(6)" pk
    | Some (7, Pbrt.Varint) -> begin
      v.replace <- Pbrt.Decoder.bool d;
    end
    | Some (7, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(define_stmt), field(7)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    kind = v.kind;
    oldstyle = v.oldstyle;
    defnames = v.defnames;
    args = v.args;
    definition = v.definition;
    if_not_exists = v.if_not_exists;
    replace = v.replace;
  } : define_stmt)

and decode_pb_drop_stmt d =
  let v = default_drop_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.objects <- List.rev v.objects;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.objects <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.objects;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(drop_stmt), field(1)" pk
    | Some (2, Pbrt.Varint) -> begin
      v.remove_type <- decode_pb_object_type d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(drop_stmt), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.behavior <- decode_pb_drop_behavior d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(drop_stmt), field(3)" pk
    | Some (4, Pbrt.Varint) -> begin
      v.missing_ok <- Pbrt.Decoder.bool d;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(drop_stmt), field(4)" pk
    | Some (5, Pbrt.Varint) -> begin
      v.concurrent <- Pbrt.Decoder.bool d;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(drop_stmt), field(5)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    objects = v.objects;
    remove_type = v.remove_type;
    behavior = v.behavior;
    missing_ok = v.missing_ok;
    concurrent = v.concurrent;
  } : drop_stmt)

and decode_pb_truncate_stmt d =
  let v = default_truncate_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.relations <- List.rev v.relations;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.relations <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.relations;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(truncate_stmt), field(1)" pk
    | Some (2, Pbrt.Varint) -> begin
      v.restart_seqs <- Pbrt.Decoder.bool d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(truncate_stmt), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.behavior <- decode_pb_drop_behavior d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(truncate_stmt), field(3)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    relations = v.relations;
    restart_seqs = v.restart_seqs;
    behavior = v.behavior;
  } : truncate_stmt)

and decode_pb_comment_stmt d =
  let v = default_comment_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Varint) -> begin
      v.objtype <- decode_pb_object_type d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(comment_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.object_ <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(comment_stmt), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.comment <- Pbrt.Decoder.string d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(comment_stmt), field(3)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    objtype = v.objtype;
    object_ = v.object_;
    comment = v.comment;
  } : comment_stmt)

and decode_pb_index_stmt d =
  let v = default_index_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.exclude_op_names <- List.rev v.exclude_op_names;
      v.options <- List.rev v.options;
      v.index_including_params <- List.rev v.index_including_params;
      v.index_params <- List.rev v.index_params;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.idxname <- Pbrt.Decoder.string d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(index_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.relation <- Some (decode_pb_range_var (Pbrt.Decoder.nested d));
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(index_stmt), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.access_method <- Pbrt.Decoder.string d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(index_stmt), field(3)" pk
    | Some (4, Pbrt.Bytes) -> begin
      v.table_space <- Pbrt.Decoder.string d;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(index_stmt), field(4)" pk
    | Some (5, Pbrt.Bytes) -> begin
      v.index_params <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.index_params;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(index_stmt), field(5)" pk
    | Some (6, Pbrt.Bytes) -> begin
      v.index_including_params <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.index_including_params;
    end
    | Some (6, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(index_stmt), field(6)" pk
    | Some (7, Pbrt.Bytes) -> begin
      v.options <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.options;
    end
    | Some (7, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(index_stmt), field(7)" pk
    | Some (8, Pbrt.Bytes) -> begin
      v.where_clause <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (8, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(index_stmt), field(8)" pk
    | Some (9, Pbrt.Bytes) -> begin
      v.exclude_op_names <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.exclude_op_names;
    end
    | Some (9, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(index_stmt), field(9)" pk
    | Some (10, Pbrt.Bytes) -> begin
      v.idxcomment <- Pbrt.Decoder.string d;
    end
    | Some (10, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(index_stmt), field(10)" pk
    | Some (11, Pbrt.Varint) -> begin
      v.index_oid <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (11, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(index_stmt), field(11)" pk
    | Some (12, Pbrt.Varint) -> begin
      v.old_node <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (12, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(index_stmt), field(12)" pk
    | Some (13, Pbrt.Varint) -> begin
      v.old_create_subid <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (13, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(index_stmt), field(13)" pk
    | Some (14, Pbrt.Varint) -> begin
      v.old_first_relfilenode_subid <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (14, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(index_stmt), field(14)" pk
    | Some (15, Pbrt.Varint) -> begin
      v.unique <- Pbrt.Decoder.bool d;
    end
    | Some (15, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(index_stmt), field(15)" pk
    | Some (16, Pbrt.Varint) -> begin
      v.primary <- Pbrt.Decoder.bool d;
    end
    | Some (16, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(index_stmt), field(16)" pk
    | Some (17, Pbrt.Varint) -> begin
      v.isconstraint <- Pbrt.Decoder.bool d;
    end
    | Some (17, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(index_stmt), field(17)" pk
    | Some (18, Pbrt.Varint) -> begin
      v.deferrable <- Pbrt.Decoder.bool d;
    end
    | Some (18, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(index_stmt), field(18)" pk
    | Some (19, Pbrt.Varint) -> begin
      v.initdeferred <- Pbrt.Decoder.bool d;
    end
    | Some (19, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(index_stmt), field(19)" pk
    | Some (20, Pbrt.Varint) -> begin
      v.transformed <- Pbrt.Decoder.bool d;
    end
    | Some (20, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(index_stmt), field(20)" pk
    | Some (21, Pbrt.Varint) -> begin
      v.concurrent <- Pbrt.Decoder.bool d;
    end
    | Some (21, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(index_stmt), field(21)" pk
    | Some (22, Pbrt.Varint) -> begin
      v.if_not_exists <- Pbrt.Decoder.bool d;
    end
    | Some (22, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(index_stmt), field(22)" pk
    | Some (23, Pbrt.Varint) -> begin
      v.reset_default_tblspc <- Pbrt.Decoder.bool d;
    end
    | Some (23, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(index_stmt), field(23)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    idxname = v.idxname;
    relation = v.relation;
    access_method = v.access_method;
    table_space = v.table_space;
    index_params = v.index_params;
    index_including_params = v.index_including_params;
    options = v.options;
    where_clause = v.where_clause;
    exclude_op_names = v.exclude_op_names;
    idxcomment = v.idxcomment;
    index_oid = v.index_oid;
    old_node = v.old_node;
    old_create_subid = v.old_create_subid;
    old_first_relfilenode_subid = v.old_first_relfilenode_subid;
    unique = v.unique;
    primary = v.primary;
    isconstraint = v.isconstraint;
    deferrable = v.deferrable;
    initdeferred = v.initdeferred;
    transformed = v.transformed;
    concurrent = v.concurrent;
    if_not_exists = v.if_not_exists;
    reset_default_tblspc = v.reset_default_tblspc;
  } : index_stmt)

and decode_pb_create_function_stmt d =
  let v = default_create_function_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.options <- List.rev v.options;
      v.parameters <- List.rev v.parameters;
      v.funcname <- List.rev v.funcname;
    ); continue__ := false
    | Some (1, Pbrt.Varint) -> begin
      v.is_procedure <- Pbrt.Decoder.bool d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_function_stmt), field(1)" pk
    | Some (2, Pbrt.Varint) -> begin
      v.replace <- Pbrt.Decoder.bool d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_function_stmt), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.funcname <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.funcname;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_function_stmt), field(3)" pk
    | Some (4, Pbrt.Bytes) -> begin
      v.parameters <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.parameters;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_function_stmt), field(4)" pk
    | Some (5, Pbrt.Bytes) -> begin
      v.return_type <- Some (decode_pb_type_name (Pbrt.Decoder.nested d));
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_function_stmt), field(5)" pk
    | Some (6, Pbrt.Bytes) -> begin
      v.options <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.options;
    end
    | Some (6, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_function_stmt), field(6)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    is_procedure = v.is_procedure;
    replace = v.replace;
    funcname = v.funcname;
    parameters = v.parameters;
    return_type = v.return_type;
    options = v.options;
  } : create_function_stmt)

and decode_pb_alter_function_stmt d =
  let v = default_alter_function_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.actions <- List.rev v.actions;
    ); continue__ := false
    | Some (1, Pbrt.Varint) -> begin
      v.objtype <- decode_pb_object_type d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_function_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.func <- Some (decode_pb_object_with_args (Pbrt.Decoder.nested d));
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_function_stmt), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.actions <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.actions;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_function_stmt), field(3)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    objtype = v.objtype;
    func = v.func;
    actions = v.actions;
  } : alter_function_stmt)

and decode_pb_object_with_args d =
  let v = default_object_with_args_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.objargs <- List.rev v.objargs;
      v.objname <- List.rev v.objname;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.objname <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.objname;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(object_with_args), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.objargs <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.objargs;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(object_with_args), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.args_unspecified <- Pbrt.Decoder.bool d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(object_with_args), field(3)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    objname = v.objname;
    objargs = v.objargs;
    args_unspecified = v.args_unspecified;
  } : object_with_args)

and decode_pb_do_stmt d =
  let v = default_do_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.args <- List.rev v.args;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.args <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.args;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(do_stmt), field(1)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    args = v.args;
  } : do_stmt)

and decode_pb_rename_stmt d =
  let v = default_rename_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Varint) -> begin
      v.rename_type <- decode_pb_object_type d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(rename_stmt), field(1)" pk
    | Some (2, Pbrt.Varint) -> begin
      v.relation_type <- decode_pb_object_type d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(rename_stmt), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.relation <- Some (decode_pb_range_var (Pbrt.Decoder.nested d));
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(rename_stmt), field(3)" pk
    | Some (4, Pbrt.Bytes) -> begin
      v.object_ <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(rename_stmt), field(4)" pk
    | Some (5, Pbrt.Bytes) -> begin
      v.subname <- Pbrt.Decoder.string d;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(rename_stmt), field(5)" pk
    | Some (6, Pbrt.Bytes) -> begin
      v.newname <- Pbrt.Decoder.string d;
    end
    | Some (6, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(rename_stmt), field(6)" pk
    | Some (7, Pbrt.Varint) -> begin
      v.behavior <- decode_pb_drop_behavior d;
    end
    | Some (7, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(rename_stmt), field(7)" pk
    | Some (8, Pbrt.Varint) -> begin
      v.missing_ok <- Pbrt.Decoder.bool d;
    end
    | Some (8, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(rename_stmt), field(8)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    rename_type = v.rename_type;
    relation_type = v.relation_type;
    relation = v.relation;
    object_ = v.object_;
    subname = v.subname;
    newname = v.newname;
    behavior = v.behavior;
    missing_ok = v.missing_ok;
  } : rename_stmt)

and decode_pb_rule_stmt d =
  let v = default_rule_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.actions <- List.rev v.actions;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.relation <- Some (decode_pb_range_var (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(rule_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.rulename <- Pbrt.Decoder.string d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(rule_stmt), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.where_clause <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(rule_stmt), field(3)" pk
    | Some (4, Pbrt.Varint) -> begin
      v.event <- decode_pb_cmd_type d;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(rule_stmt), field(4)" pk
    | Some (5, Pbrt.Varint) -> begin
      v.instead <- Pbrt.Decoder.bool d;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(rule_stmt), field(5)" pk
    | Some (6, Pbrt.Bytes) -> begin
      v.actions <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.actions;
    end
    | Some (6, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(rule_stmt), field(6)" pk
    | Some (7, Pbrt.Varint) -> begin
      v.replace <- Pbrt.Decoder.bool d;
    end
    | Some (7, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(rule_stmt), field(7)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    relation = v.relation;
    rulename = v.rulename;
    where_clause = v.where_clause;
    event = v.event;
    instead = v.instead;
    actions = v.actions;
    replace = v.replace;
  } : rule_stmt)

and decode_pb_transaction_stmt d =
  let v = default_transaction_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.options <- List.rev v.options;
    ); continue__ := false
    | Some (1, Pbrt.Varint) -> begin
      v.kind <- decode_pb_transaction_stmt_kind d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(transaction_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.options <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.options;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(transaction_stmt), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.savepoint_name <- Pbrt.Decoder.string d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(transaction_stmt), field(3)" pk
    | Some (4, Pbrt.Bytes) -> begin
      v.gid <- Pbrt.Decoder.string d;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(transaction_stmt), field(4)" pk
    | Some (5, Pbrt.Varint) -> begin
      v.chain <- Pbrt.Decoder.bool d;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(transaction_stmt), field(5)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    kind = v.kind;
    options = v.options;
    savepoint_name = v.savepoint_name;
    gid = v.gid;
    chain = v.chain;
  } : transaction_stmt)

and decode_pb_view_stmt d =
  let v = default_view_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.options <- List.rev v.options;
      v.aliases <- List.rev v.aliases;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.view <- Some (decode_pb_range_var (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(view_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.aliases <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.aliases;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(view_stmt), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.query <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(view_stmt), field(3)" pk
    | Some (4, Pbrt.Varint) -> begin
      v.replace <- Pbrt.Decoder.bool d;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(view_stmt), field(4)" pk
    | Some (5, Pbrt.Bytes) -> begin
      v.options <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.options;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(view_stmt), field(5)" pk
    | Some (6, Pbrt.Varint) -> begin
      v.with_check_option <- decode_pb_view_check_option d;
    end
    | Some (6, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(view_stmt), field(6)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    view = v.view;
    aliases = v.aliases;
    query = v.query;
    replace = v.replace;
    options = v.options;
    with_check_option = v.with_check_option;
  } : view_stmt)

and decode_pb_create_domain_stmt d =
  let v = default_create_domain_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.constraints <- List.rev v.constraints;
      v.domainname <- List.rev v.domainname;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.domainname <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.domainname;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_domain_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.type_name <- Some (decode_pb_type_name (Pbrt.Decoder.nested d));
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_domain_stmt), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.coll_clause <- Some (decode_pb_collate_clause (Pbrt.Decoder.nested d));
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_domain_stmt), field(3)" pk
    | Some (4, Pbrt.Bytes) -> begin
      v.constraints <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.constraints;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_domain_stmt), field(4)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    domainname = v.domainname;
    type_name = v.type_name;
    coll_clause = v.coll_clause;
    constraints = v.constraints;
  } : create_domain_stmt)

and decode_pb_collate_clause d =
  let v = default_collate_clause_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.collname <- List.rev v.collname;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.arg <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(collate_clause), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.collname <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.collname;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(collate_clause), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.location <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(collate_clause), field(3)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    arg = v.arg;
    collname = v.collname;
    location = v.location;
  } : collate_clause)

and decode_pb_createdb_stmt d =
  let v = default_createdb_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.options <- List.rev v.options;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.dbname <- Pbrt.Decoder.string d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(createdb_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.options <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.options;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(createdb_stmt), field(2)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    dbname = v.dbname;
    options = v.options;
  } : createdb_stmt)

and decode_pb_dropdb_stmt d =
  let v = default_dropdb_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.options <- List.rev v.options;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.dbname <- Pbrt.Decoder.string d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(dropdb_stmt), field(1)" pk
    | Some (2, Pbrt.Varint) -> begin
      v.missing_ok <- Pbrt.Decoder.bool d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(dropdb_stmt), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.options <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.options;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(dropdb_stmt), field(3)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    dbname = v.dbname;
    missing_ok = v.missing_ok;
    options = v.options;
  } : dropdb_stmt)

and decode_pb_vacuum_stmt d =
  let v = default_vacuum_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.rels <- List.rev v.rels;
      v.options <- List.rev v.options;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.options <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.options;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(vacuum_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.rels <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.rels;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(vacuum_stmt), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.is_vacuumcmd <- Pbrt.Decoder.bool d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(vacuum_stmt), field(3)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    options = v.options;
    rels = v.rels;
    is_vacuumcmd = v.is_vacuumcmd;
  } : vacuum_stmt)

and decode_pb_explain_stmt d =
  let v = default_explain_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.options <- List.rev v.options;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.query <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(explain_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.options <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.options;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(explain_stmt), field(2)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    query = v.query;
    options = v.options;
  } : explain_stmt)

and decode_pb_create_table_as_stmt d =
  let v = default_create_table_as_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.query <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_table_as_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.into <- Some (decode_pb_into_clause (Pbrt.Decoder.nested d));
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_table_as_stmt), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.relkind <- decode_pb_object_type d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_table_as_stmt), field(3)" pk
    | Some (4, Pbrt.Varint) -> begin
      v.is_select_into <- Pbrt.Decoder.bool d;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_table_as_stmt), field(4)" pk
    | Some (5, Pbrt.Varint) -> begin
      v.if_not_exists <- Pbrt.Decoder.bool d;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_table_as_stmt), field(5)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    query = v.query;
    into = v.into;
    relkind = v.relkind;
    is_select_into = v.is_select_into;
    if_not_exists = v.if_not_exists;
  } : create_table_as_stmt)

and decode_pb_create_seq_stmt d =
  let v = default_create_seq_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.options <- List.rev v.options;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.sequence <- Some (decode_pb_range_var (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_seq_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.options <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.options;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_seq_stmt), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.owner_id <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_seq_stmt), field(3)" pk
    | Some (4, Pbrt.Varint) -> begin
      v.for_identity <- Pbrt.Decoder.bool d;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_seq_stmt), field(4)" pk
    | Some (5, Pbrt.Varint) -> begin
      v.if_not_exists <- Pbrt.Decoder.bool d;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_seq_stmt), field(5)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    sequence = v.sequence;
    options = v.options;
    owner_id = v.owner_id;
    for_identity = v.for_identity;
    if_not_exists = v.if_not_exists;
  } : create_seq_stmt)

and decode_pb_alter_seq_stmt d =
  let v = default_alter_seq_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.options <- List.rev v.options;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.sequence <- Some (decode_pb_range_var (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_seq_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.options <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.options;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_seq_stmt), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.for_identity <- Pbrt.Decoder.bool d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_seq_stmt), field(3)" pk
    | Some (4, Pbrt.Varint) -> begin
      v.missing_ok <- Pbrt.Decoder.bool d;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_seq_stmt), field(4)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    sequence = v.sequence;
    options = v.options;
    for_identity = v.for_identity;
    missing_ok = v.missing_ok;
  } : alter_seq_stmt)

and decode_pb_variable_set_stmt d =
  let v = default_variable_set_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.args <- List.rev v.args;
    ); continue__ := false
    | Some (1, Pbrt.Varint) -> begin
      v.kind <- decode_pb_variable_set_kind d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(variable_set_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.name <- Pbrt.Decoder.string d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(variable_set_stmt), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.args <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.args;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(variable_set_stmt), field(3)" pk
    | Some (4, Pbrt.Varint) -> begin
      v.is_local <- Pbrt.Decoder.bool d;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(variable_set_stmt), field(4)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    kind = v.kind;
    name = v.name;
    args = v.args;
    is_local = v.is_local;
  } : variable_set_stmt)

and decode_pb_create_trig_stmt d =
  let v = default_create_trig_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.transition_rels <- List.rev v.transition_rels;
      v.columns <- List.rev v.columns;
      v.args <- List.rev v.args;
      v.funcname <- List.rev v.funcname;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.trigname <- Pbrt.Decoder.string d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_trig_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.relation <- Some (decode_pb_range_var (Pbrt.Decoder.nested d));
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_trig_stmt), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.funcname <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.funcname;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_trig_stmt), field(3)" pk
    | Some (4, Pbrt.Bytes) -> begin
      v.args <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.args;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_trig_stmt), field(4)" pk
    | Some (5, Pbrt.Varint) -> begin
      v.row <- Pbrt.Decoder.bool d;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_trig_stmt), field(5)" pk
    | Some (6, Pbrt.Varint) -> begin
      v.timing <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (6, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_trig_stmt), field(6)" pk
    | Some (7, Pbrt.Varint) -> begin
      v.events <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (7, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_trig_stmt), field(7)" pk
    | Some (8, Pbrt.Bytes) -> begin
      v.columns <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.columns;
    end
    | Some (8, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_trig_stmt), field(8)" pk
    | Some (9, Pbrt.Bytes) -> begin
      v.when_clause <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (9, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_trig_stmt), field(9)" pk
    | Some (10, Pbrt.Varint) -> begin
      v.isconstraint <- Pbrt.Decoder.bool d;
    end
    | Some (10, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_trig_stmt), field(10)" pk
    | Some (11, Pbrt.Bytes) -> begin
      v.transition_rels <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.transition_rels;
    end
    | Some (11, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_trig_stmt), field(11)" pk
    | Some (12, Pbrt.Varint) -> begin
      v.deferrable <- Pbrt.Decoder.bool d;
    end
    | Some (12, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_trig_stmt), field(12)" pk
    | Some (13, Pbrt.Varint) -> begin
      v.initdeferred <- Pbrt.Decoder.bool d;
    end
    | Some (13, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_trig_stmt), field(13)" pk
    | Some (14, Pbrt.Bytes) -> begin
      v.constrrel <- Some (decode_pb_range_var (Pbrt.Decoder.nested d));
    end
    | Some (14, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_trig_stmt), field(14)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    trigname = v.trigname;
    relation = v.relation;
    funcname = v.funcname;
    args = v.args;
    row = v.row;
    timing = v.timing;
    events = v.events;
    columns = v.columns;
    when_clause = v.when_clause;
    isconstraint = v.isconstraint;
    transition_rels = v.transition_rels;
    deferrable = v.deferrable;
    initdeferred = v.initdeferred;
    constrrel = v.constrrel;
  } : create_trig_stmt)

and decode_pb_create_plang_stmt d =
  let v = default_create_plang_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.plvalidator <- List.rev v.plvalidator;
      v.plinline <- List.rev v.plinline;
      v.plhandler <- List.rev v.plhandler;
    ); continue__ := false
    | Some (1, Pbrt.Varint) -> begin
      v.replace <- Pbrt.Decoder.bool d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_plang_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.plname <- Pbrt.Decoder.string d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_plang_stmt), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.plhandler <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.plhandler;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_plang_stmt), field(3)" pk
    | Some (4, Pbrt.Bytes) -> begin
      v.plinline <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.plinline;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_plang_stmt), field(4)" pk
    | Some (5, Pbrt.Bytes) -> begin
      v.plvalidator <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.plvalidator;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_plang_stmt), field(5)" pk
    | Some (6, Pbrt.Varint) -> begin
      v.pltrusted <- Pbrt.Decoder.bool d;
    end
    | Some (6, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_plang_stmt), field(6)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    replace = v.replace;
    plname = v.plname;
    plhandler = v.plhandler;
    plinline = v.plinline;
    plvalidator = v.plvalidator;
    pltrusted = v.pltrusted;
  } : create_plang_stmt)

and decode_pb_create_role_stmt d =
  let v = default_create_role_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.options <- List.rev v.options;
    ); continue__ := false
    | Some (1, Pbrt.Varint) -> begin
      v.stmt_type <- decode_pb_role_stmt_type d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_role_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.role <- Pbrt.Decoder.string d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_role_stmt), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.options <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.options;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_role_stmt), field(3)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    stmt_type = v.stmt_type;
    role = v.role;
    options = v.options;
  } : create_role_stmt)

and decode_pb_alter_role_stmt d =
  let v = default_alter_role_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.options <- List.rev v.options;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.role <- Some (decode_pb_role_spec (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_role_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.options <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.options;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_role_stmt), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.action <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_role_stmt), field(3)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    role = v.role;
    options = v.options;
    action = v.action;
  } : alter_role_stmt)

and decode_pb_drop_role_stmt d =
  let v = default_drop_role_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.roles <- List.rev v.roles;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.roles <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.roles;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(drop_role_stmt), field(1)" pk
    | Some (2, Pbrt.Varint) -> begin
      v.missing_ok <- Pbrt.Decoder.bool d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(drop_role_stmt), field(2)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    roles = v.roles;
    missing_ok = v.missing_ok;
  } : drop_role_stmt)

and decode_pb_lock_stmt d =
  let v = default_lock_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.relations <- List.rev v.relations;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.relations <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.relations;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(lock_stmt), field(1)" pk
    | Some (2, Pbrt.Varint) -> begin
      v.mode <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(lock_stmt), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.nowait <- Pbrt.Decoder.bool d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(lock_stmt), field(3)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    relations = v.relations;
    mode = v.mode;
    nowait = v.nowait;
  } : lock_stmt)

and decode_pb_constraints_set_stmt d =
  let v = default_constraints_set_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.constraints <- List.rev v.constraints;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.constraints <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.constraints;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(constraints_set_stmt), field(1)" pk
    | Some (2, Pbrt.Varint) -> begin
      v.deferred <- Pbrt.Decoder.bool d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(constraints_set_stmt), field(2)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    constraints = v.constraints;
    deferred = v.deferred;
  } : constraints_set_stmt)

and decode_pb_reindex_stmt d =
  let v = default_reindex_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Varint) -> begin
      v.kind <- decode_pb_reindex_object_type d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(reindex_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.relation <- Some (decode_pb_range_var (Pbrt.Decoder.nested d));
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(reindex_stmt), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.name <- Pbrt.Decoder.string d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(reindex_stmt), field(3)" pk
    | Some (4, Pbrt.Varint) -> begin
      v.options <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(reindex_stmt), field(4)" pk
    | Some (5, Pbrt.Varint) -> begin
      v.concurrent <- Pbrt.Decoder.bool d;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(reindex_stmt), field(5)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    kind = v.kind;
    relation = v.relation;
    name = v.name;
    options = v.options;
    concurrent = v.concurrent;
  } : reindex_stmt)

and decode_pb_create_schema_stmt d =
  let v = default_create_schema_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.schema_elts <- List.rev v.schema_elts;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.schemaname <- Pbrt.Decoder.string d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_schema_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.authrole <- Some (decode_pb_role_spec (Pbrt.Decoder.nested d));
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_schema_stmt), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.schema_elts <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.schema_elts;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_schema_stmt), field(3)" pk
    | Some (4, Pbrt.Varint) -> begin
      v.if_not_exists <- Pbrt.Decoder.bool d;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_schema_stmt), field(4)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    schemaname = v.schemaname;
    authrole = v.authrole;
    schema_elts = v.schema_elts;
    if_not_exists = v.if_not_exists;
  } : create_schema_stmt)

and decode_pb_alter_database_stmt d =
  let v = default_alter_database_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.options <- List.rev v.options;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.dbname <- Pbrt.Decoder.string d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_database_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.options <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.options;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_database_stmt), field(2)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    dbname = v.dbname;
    options = v.options;
  } : alter_database_stmt)

and decode_pb_alter_database_set_stmt d =
  let v = default_alter_database_set_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.dbname <- Pbrt.Decoder.string d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_database_set_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.setstmt <- Some (decode_pb_variable_set_stmt (Pbrt.Decoder.nested d));
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_database_set_stmt), field(2)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    dbname = v.dbname;
    setstmt = v.setstmt;
  } : alter_database_set_stmt)

and decode_pb_alter_role_set_stmt d =
  let v = default_alter_role_set_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.role <- Some (decode_pb_role_spec (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_role_set_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.database <- Pbrt.Decoder.string d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_role_set_stmt), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.setstmt <- Some (decode_pb_variable_set_stmt (Pbrt.Decoder.nested d));
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_role_set_stmt), field(3)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    role = v.role;
    database = v.database;
    setstmt = v.setstmt;
  } : alter_role_set_stmt)

and decode_pb_create_conversion_stmt d =
  let v = default_create_conversion_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.func_name <- List.rev v.func_name;
      v.conversion_name <- List.rev v.conversion_name;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.conversion_name <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.conversion_name;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_conversion_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.for_encoding_name <- Pbrt.Decoder.string d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_conversion_stmt), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.to_encoding_name <- Pbrt.Decoder.string d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_conversion_stmt), field(3)" pk
    | Some (4, Pbrt.Bytes) -> begin
      v.func_name <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.func_name;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_conversion_stmt), field(4)" pk
    | Some (5, Pbrt.Varint) -> begin
      v.def <- Pbrt.Decoder.bool d;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_conversion_stmt), field(5)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    conversion_name = v.conversion_name;
    for_encoding_name = v.for_encoding_name;
    to_encoding_name = v.to_encoding_name;
    func_name = v.func_name;
    def = v.def;
  } : create_conversion_stmt)

and decode_pb_create_cast_stmt d =
  let v = default_create_cast_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.sourcetype <- Some (decode_pb_type_name (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_cast_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.targettype <- Some (decode_pb_type_name (Pbrt.Decoder.nested d));
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_cast_stmt), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.func <- Some (decode_pb_object_with_args (Pbrt.Decoder.nested d));
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_cast_stmt), field(3)" pk
    | Some (4, Pbrt.Varint) -> begin
      v.context <- decode_pb_coercion_context d;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_cast_stmt), field(4)" pk
    | Some (5, Pbrt.Varint) -> begin
      v.inout <- Pbrt.Decoder.bool d;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_cast_stmt), field(5)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    sourcetype = v.sourcetype;
    targettype = v.targettype;
    func = v.func;
    context = v.context;
    inout = v.inout;
  } : create_cast_stmt)

and decode_pb_create_op_class_stmt d =
  let v = default_create_op_class_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.items <- List.rev v.items;
      v.opfamilyname <- List.rev v.opfamilyname;
      v.opclassname <- List.rev v.opclassname;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.opclassname <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.opclassname;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_op_class_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.opfamilyname <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.opfamilyname;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_op_class_stmt), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.amname <- Pbrt.Decoder.string d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_op_class_stmt), field(3)" pk
    | Some (4, Pbrt.Bytes) -> begin
      v.datatype <- Some (decode_pb_type_name (Pbrt.Decoder.nested d));
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_op_class_stmt), field(4)" pk
    | Some (5, Pbrt.Bytes) -> begin
      v.items <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.items;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_op_class_stmt), field(5)" pk
    | Some (6, Pbrt.Varint) -> begin
      v.is_default <- Pbrt.Decoder.bool d;
    end
    | Some (6, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_op_class_stmt), field(6)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    opclassname = v.opclassname;
    opfamilyname = v.opfamilyname;
    amname = v.amname;
    datatype = v.datatype;
    items = v.items;
    is_default = v.is_default;
  } : create_op_class_stmt)

and decode_pb_create_op_family_stmt d =
  let v = default_create_op_family_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.opfamilyname <- List.rev v.opfamilyname;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.opfamilyname <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.opfamilyname;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_op_family_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.amname <- Pbrt.Decoder.string d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_op_family_stmt), field(2)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    opfamilyname = v.opfamilyname;
    amname = v.amname;
  } : create_op_family_stmt)

and decode_pb_alter_op_family_stmt d =
  let v = default_alter_op_family_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.items <- List.rev v.items;
      v.opfamilyname <- List.rev v.opfamilyname;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.opfamilyname <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.opfamilyname;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_op_family_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.amname <- Pbrt.Decoder.string d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_op_family_stmt), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.is_drop <- Pbrt.Decoder.bool d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_op_family_stmt), field(3)" pk
    | Some (4, Pbrt.Bytes) -> begin
      v.items <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.items;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_op_family_stmt), field(4)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    opfamilyname = v.opfamilyname;
    amname = v.amname;
    is_drop = v.is_drop;
    items = v.items;
  } : alter_op_family_stmt)

and decode_pb_prepare_stmt d =
  let v = default_prepare_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.argtypes <- List.rev v.argtypes;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.name <- Pbrt.Decoder.string d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(prepare_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.argtypes <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.argtypes;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(prepare_stmt), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.query <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(prepare_stmt), field(3)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    name = v.name;
    argtypes = v.argtypes;
    query = v.query;
  } : prepare_stmt)

and decode_pb_execute_stmt d =
  let v = default_execute_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.params <- List.rev v.params;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.name <- Pbrt.Decoder.string d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(execute_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.params <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.params;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(execute_stmt), field(2)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    name = v.name;
    params = v.params;
  } : execute_stmt)

and decode_pb_declare_cursor_stmt d =
  let v = default_declare_cursor_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.portalname <- Pbrt.Decoder.string d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(declare_cursor_stmt), field(1)" pk
    | Some (2, Pbrt.Varint) -> begin
      v.options <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(declare_cursor_stmt), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.query <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(declare_cursor_stmt), field(3)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    portalname = v.portalname;
    options = v.options;
    query = v.query;
  } : declare_cursor_stmt)

and decode_pb_create_table_space_stmt d =
  let v = default_create_table_space_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.options <- List.rev v.options;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.tablespacename <- Pbrt.Decoder.string d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_table_space_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.owner <- Some (decode_pb_role_spec (Pbrt.Decoder.nested d));
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_table_space_stmt), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.location <- Pbrt.Decoder.string d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_table_space_stmt), field(3)" pk
    | Some (4, Pbrt.Bytes) -> begin
      v.options <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.options;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_table_space_stmt), field(4)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    tablespacename = v.tablespacename;
    owner = v.owner;
    location = v.location;
    options = v.options;
  } : create_table_space_stmt)

and decode_pb_alter_object_depends_stmt d =
  let v = default_alter_object_depends_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Varint) -> begin
      v.object_type <- decode_pb_object_type d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_object_depends_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.relation <- Some (decode_pb_range_var (Pbrt.Decoder.nested d));
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_object_depends_stmt), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.object_ <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_object_depends_stmt), field(3)" pk
    | Some (4, Pbrt.Bytes) -> begin
      v.extname <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_object_depends_stmt), field(4)" pk
    | Some (5, Pbrt.Varint) -> begin
      v.remove <- Pbrt.Decoder.bool d;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_object_depends_stmt), field(5)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    object_type = v.object_type;
    relation = v.relation;
    object_ = v.object_;
    extname = v.extname;
    remove = v.remove;
  } : alter_object_depends_stmt)

and decode_pb_alter_object_schema_stmt d =
  let v = default_alter_object_schema_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Varint) -> begin
      v.object_type <- decode_pb_object_type d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_object_schema_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.relation <- Some (decode_pb_range_var (Pbrt.Decoder.nested d));
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_object_schema_stmt), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.object_ <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_object_schema_stmt), field(3)" pk
    | Some (4, Pbrt.Bytes) -> begin
      v.newschema <- Pbrt.Decoder.string d;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_object_schema_stmt), field(4)" pk
    | Some (5, Pbrt.Varint) -> begin
      v.missing_ok <- Pbrt.Decoder.bool d;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_object_schema_stmt), field(5)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    object_type = v.object_type;
    relation = v.relation;
    object_ = v.object_;
    newschema = v.newschema;
    missing_ok = v.missing_ok;
  } : alter_object_schema_stmt)

and decode_pb_alter_owner_stmt d =
  let v = default_alter_owner_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Varint) -> begin
      v.object_type <- decode_pb_object_type d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_owner_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.relation <- Some (decode_pb_range_var (Pbrt.Decoder.nested d));
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_owner_stmt), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.object_ <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_owner_stmt), field(3)" pk
    | Some (4, Pbrt.Bytes) -> begin
      v.newowner <- Some (decode_pb_role_spec (Pbrt.Decoder.nested d));
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_owner_stmt), field(4)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    object_type = v.object_type;
    relation = v.relation;
    object_ = v.object_;
    newowner = v.newowner;
  } : alter_owner_stmt)

and decode_pb_alter_operator_stmt d =
  let v = default_alter_operator_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.options <- List.rev v.options;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.opername <- Some (decode_pb_object_with_args (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_operator_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.options <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.options;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_operator_stmt), field(2)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    opername = v.opername;
    options = v.options;
  } : alter_operator_stmt)

and decode_pb_alter_type_stmt d =
  let v = default_alter_type_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.options <- List.rev v.options;
      v.type_name <- List.rev v.type_name;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.type_name <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.type_name;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_type_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.options <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.options;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_type_stmt), field(2)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    type_name = v.type_name;
    options = v.options;
  } : alter_type_stmt)

and decode_pb_drop_owned_stmt d =
  let v = default_drop_owned_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.roles <- List.rev v.roles;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.roles <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.roles;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(drop_owned_stmt), field(1)" pk
    | Some (2, Pbrt.Varint) -> begin
      v.behavior <- decode_pb_drop_behavior d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(drop_owned_stmt), field(2)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    roles = v.roles;
    behavior = v.behavior;
  } : drop_owned_stmt)

and decode_pb_reassign_owned_stmt d =
  let v = default_reassign_owned_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.roles <- List.rev v.roles;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.roles <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.roles;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(reassign_owned_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.newrole <- Some (decode_pb_role_spec (Pbrt.Decoder.nested d));
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(reassign_owned_stmt), field(2)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    roles = v.roles;
    newrole = v.newrole;
  } : reassign_owned_stmt)

and decode_pb_composite_type_stmt d =
  let v = default_composite_type_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.coldeflist <- List.rev v.coldeflist;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.typevar <- Some (decode_pb_range_var (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(composite_type_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.coldeflist <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.coldeflist;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(composite_type_stmt), field(2)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    typevar = v.typevar;
    coldeflist = v.coldeflist;
  } : composite_type_stmt)

and decode_pb_create_enum_stmt d =
  let v = default_create_enum_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.vals <- List.rev v.vals;
      v.type_name <- List.rev v.type_name;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.type_name <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.type_name;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_enum_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.vals <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.vals;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_enum_stmt), field(2)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    type_name = v.type_name;
    vals = v.vals;
  } : create_enum_stmt)

and decode_pb_create_range_stmt d =
  let v = default_create_range_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.params <- List.rev v.params;
      v.type_name <- List.rev v.type_name;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.type_name <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.type_name;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_range_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.params <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.params;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_range_stmt), field(2)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    type_name = v.type_name;
    params = v.params;
  } : create_range_stmt)

and decode_pb_alter_enum_stmt d =
  let v = default_alter_enum_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.type_name <- List.rev v.type_name;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.type_name <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.type_name;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_enum_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.old_val <- Pbrt.Decoder.string d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_enum_stmt), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.new_val <- Pbrt.Decoder.string d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_enum_stmt), field(3)" pk
    | Some (4, Pbrt.Bytes) -> begin
      v.new_val_neighbor <- Pbrt.Decoder.string d;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_enum_stmt), field(4)" pk
    | Some (5, Pbrt.Varint) -> begin
      v.new_val_is_after <- Pbrt.Decoder.bool d;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_enum_stmt), field(5)" pk
    | Some (6, Pbrt.Varint) -> begin
      v.skip_if_new_val_exists <- Pbrt.Decoder.bool d;
    end
    | Some (6, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_enum_stmt), field(6)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    type_name = v.type_name;
    old_val = v.old_val;
    new_val = v.new_val;
    new_val_neighbor = v.new_val_neighbor;
    new_val_is_after = v.new_val_is_after;
    skip_if_new_val_exists = v.skip_if_new_val_exists;
  } : alter_enum_stmt)

and decode_pb_alter_tsdictionary_stmt d =
  let v = default_alter_tsdictionary_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.options <- List.rev v.options;
      v.dictname <- List.rev v.dictname;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.dictname <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.dictname;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_tsdictionary_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.options <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.options;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_tsdictionary_stmt), field(2)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    dictname = v.dictname;
    options = v.options;
  } : alter_tsdictionary_stmt)

and decode_pb_alter_tsconfiguration_stmt d =
  let v = default_alter_tsconfiguration_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.dicts <- List.rev v.dicts;
      v.tokentype <- List.rev v.tokentype;
      v.cfgname <- List.rev v.cfgname;
    ); continue__ := false
    | Some (1, Pbrt.Varint) -> begin
      v.kind <- decode_pb_alter_tsconfig_type d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_tsconfiguration_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.cfgname <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.cfgname;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_tsconfiguration_stmt), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.tokentype <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.tokentype;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_tsconfiguration_stmt), field(3)" pk
    | Some (4, Pbrt.Bytes) -> begin
      v.dicts <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.dicts;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_tsconfiguration_stmt), field(4)" pk
    | Some (5, Pbrt.Varint) -> begin
      v.override <- Pbrt.Decoder.bool d;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_tsconfiguration_stmt), field(5)" pk
    | Some (6, Pbrt.Varint) -> begin
      v.replace <- Pbrt.Decoder.bool d;
    end
    | Some (6, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_tsconfiguration_stmt), field(6)" pk
    | Some (7, Pbrt.Varint) -> begin
      v.missing_ok <- Pbrt.Decoder.bool d;
    end
    | Some (7, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_tsconfiguration_stmt), field(7)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    kind = v.kind;
    cfgname = v.cfgname;
    tokentype = v.tokentype;
    dicts = v.dicts;
    override = v.override;
    replace = v.replace;
    missing_ok = v.missing_ok;
  } : alter_tsconfiguration_stmt)

and decode_pb_create_fdw_stmt d =
  let v = default_create_fdw_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.options <- List.rev v.options;
      v.func_options <- List.rev v.func_options;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.fdwname <- Pbrt.Decoder.string d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_fdw_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.func_options <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.func_options;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_fdw_stmt), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.options <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.options;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_fdw_stmt), field(3)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    fdwname = v.fdwname;
    func_options = v.func_options;
    options = v.options;
  } : create_fdw_stmt)

and decode_pb_alter_fdw_stmt d =
  let v = default_alter_fdw_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.options <- List.rev v.options;
      v.func_options <- List.rev v.func_options;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.fdwname <- Pbrt.Decoder.string d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_fdw_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.func_options <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.func_options;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_fdw_stmt), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.options <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.options;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_fdw_stmt), field(3)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    fdwname = v.fdwname;
    func_options = v.func_options;
    options = v.options;
  } : alter_fdw_stmt)

and decode_pb_create_foreign_server_stmt d =
  let v = default_create_foreign_server_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.options <- List.rev v.options;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.servername <- Pbrt.Decoder.string d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_foreign_server_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.servertype <- Pbrt.Decoder.string d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_foreign_server_stmt), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.version <- Pbrt.Decoder.string d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_foreign_server_stmt), field(3)" pk
    | Some (4, Pbrt.Bytes) -> begin
      v.fdwname <- Pbrt.Decoder.string d;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_foreign_server_stmt), field(4)" pk
    | Some (5, Pbrt.Varint) -> begin
      v.if_not_exists <- Pbrt.Decoder.bool d;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_foreign_server_stmt), field(5)" pk
    | Some (6, Pbrt.Bytes) -> begin
      v.options <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.options;
    end
    | Some (6, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_foreign_server_stmt), field(6)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    servername = v.servername;
    servertype = v.servertype;
    version = v.version;
    fdwname = v.fdwname;
    if_not_exists = v.if_not_exists;
    options = v.options;
  } : create_foreign_server_stmt)

and decode_pb_alter_foreign_server_stmt d =
  let v = default_alter_foreign_server_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.options <- List.rev v.options;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.servername <- Pbrt.Decoder.string d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_foreign_server_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.version <- Pbrt.Decoder.string d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_foreign_server_stmt), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.options <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.options;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_foreign_server_stmt), field(3)" pk
    | Some (4, Pbrt.Varint) -> begin
      v.has_version <- Pbrt.Decoder.bool d;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_foreign_server_stmt), field(4)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    servername = v.servername;
    version = v.version;
    options = v.options;
    has_version = v.has_version;
  } : alter_foreign_server_stmt)

and decode_pb_create_user_mapping_stmt d =
  let v = default_create_user_mapping_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.options <- List.rev v.options;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.user <- Some (decode_pb_role_spec (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_user_mapping_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.servername <- Pbrt.Decoder.string d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_user_mapping_stmt), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.if_not_exists <- Pbrt.Decoder.bool d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_user_mapping_stmt), field(3)" pk
    | Some (4, Pbrt.Bytes) -> begin
      v.options <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.options;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_user_mapping_stmt), field(4)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    user = v.user;
    servername = v.servername;
    if_not_exists = v.if_not_exists;
    options = v.options;
  } : create_user_mapping_stmt)

and decode_pb_alter_user_mapping_stmt d =
  let v = default_alter_user_mapping_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.options <- List.rev v.options;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.user <- Some (decode_pb_role_spec (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_user_mapping_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.servername <- Pbrt.Decoder.string d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_user_mapping_stmt), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.options <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.options;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_user_mapping_stmt), field(3)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    user = v.user;
    servername = v.servername;
    options = v.options;
  } : alter_user_mapping_stmt)

and decode_pb_alter_table_space_options_stmt d =
  let v = default_alter_table_space_options_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.options <- List.rev v.options;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.tablespacename <- Pbrt.Decoder.string d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_table_space_options_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.options <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.options;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_table_space_options_stmt), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.is_reset <- Pbrt.Decoder.bool d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_table_space_options_stmt), field(3)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    tablespacename = v.tablespacename;
    options = v.options;
    is_reset = v.is_reset;
  } : alter_table_space_options_stmt)

and decode_pb_alter_table_move_all_stmt d =
  let v = default_alter_table_move_all_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.roles <- List.rev v.roles;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.orig_tablespacename <- Pbrt.Decoder.string d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_table_move_all_stmt), field(1)" pk
    | Some (2, Pbrt.Varint) -> begin
      v.objtype <- decode_pb_object_type d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_table_move_all_stmt), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.roles <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.roles;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_table_move_all_stmt), field(3)" pk
    | Some (4, Pbrt.Bytes) -> begin
      v.new_tablespacename <- Pbrt.Decoder.string d;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_table_move_all_stmt), field(4)" pk
    | Some (5, Pbrt.Varint) -> begin
      v.nowait <- Pbrt.Decoder.bool d;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_table_move_all_stmt), field(5)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    orig_tablespacename = v.orig_tablespacename;
    objtype = v.objtype;
    roles = v.roles;
    new_tablespacename = v.new_tablespacename;
    nowait = v.nowait;
  } : alter_table_move_all_stmt)

and decode_pb_sec_label_stmt d =
  let v = default_sec_label_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Varint) -> begin
      v.objtype <- decode_pb_object_type d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(sec_label_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.object_ <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(sec_label_stmt), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.provider <- Pbrt.Decoder.string d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(sec_label_stmt), field(3)" pk
    | Some (4, Pbrt.Bytes) -> begin
      v.label <- Pbrt.Decoder.string d;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(sec_label_stmt), field(4)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    objtype = v.objtype;
    object_ = v.object_;
    provider = v.provider;
    label = v.label;
  } : sec_label_stmt)

and decode_pb_create_foreign_table_stmt d =
  let v = default_create_foreign_table_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.options <- List.rev v.options;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.base_stmt <- Some (decode_pb_create_stmt (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_foreign_table_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.servername <- Pbrt.Decoder.string d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_foreign_table_stmt), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.options <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.options;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_foreign_table_stmt), field(3)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    base_stmt = v.base_stmt;
    servername = v.servername;
    options = v.options;
  } : create_foreign_table_stmt)

and decode_pb_import_foreign_schema_stmt d =
  let v = default_import_foreign_schema_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.options <- List.rev v.options;
      v.table_list <- List.rev v.table_list;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.server_name <- Pbrt.Decoder.string d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(import_foreign_schema_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.remote_schema <- Pbrt.Decoder.string d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(import_foreign_schema_stmt), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.local_schema <- Pbrt.Decoder.string d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(import_foreign_schema_stmt), field(3)" pk
    | Some (4, Pbrt.Varint) -> begin
      v.list_type <- decode_pb_import_foreign_schema_type d;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(import_foreign_schema_stmt), field(4)" pk
    | Some (5, Pbrt.Bytes) -> begin
      v.table_list <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.table_list;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(import_foreign_schema_stmt), field(5)" pk
    | Some (6, Pbrt.Bytes) -> begin
      v.options <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.options;
    end
    | Some (6, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(import_foreign_schema_stmt), field(6)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    server_name = v.server_name;
    remote_schema = v.remote_schema;
    local_schema = v.local_schema;
    list_type = v.list_type;
    table_list = v.table_list;
    options = v.options;
  } : import_foreign_schema_stmt)

and decode_pb_create_extension_stmt d =
  let v = default_create_extension_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.options <- List.rev v.options;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.extname <- Pbrt.Decoder.string d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_extension_stmt), field(1)" pk
    | Some (2, Pbrt.Varint) -> begin
      v.if_not_exists <- Pbrt.Decoder.bool d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_extension_stmt), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.options <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.options;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_extension_stmt), field(3)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    extname = v.extname;
    if_not_exists = v.if_not_exists;
    options = v.options;
  } : create_extension_stmt)

and decode_pb_alter_extension_stmt d =
  let v = default_alter_extension_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.options <- List.rev v.options;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.extname <- Pbrt.Decoder.string d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_extension_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.options <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.options;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_extension_stmt), field(2)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    extname = v.extname;
    options = v.options;
  } : alter_extension_stmt)

and decode_pb_alter_extension_contents_stmt d =
  let v = default_alter_extension_contents_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.extname <- Pbrt.Decoder.string d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_extension_contents_stmt), field(1)" pk
    | Some (2, Pbrt.Varint) -> begin
      v.action <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_extension_contents_stmt), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.objtype <- decode_pb_object_type d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_extension_contents_stmt), field(3)" pk
    | Some (4, Pbrt.Bytes) -> begin
      v.object_ <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_extension_contents_stmt), field(4)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    extname = v.extname;
    action = v.action;
    objtype = v.objtype;
    object_ = v.object_;
  } : alter_extension_contents_stmt)

and decode_pb_create_event_trig_stmt d =
  let v = default_create_event_trig_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.funcname <- List.rev v.funcname;
      v.whenclause <- List.rev v.whenclause;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.trigname <- Pbrt.Decoder.string d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_event_trig_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.eventname <- Pbrt.Decoder.string d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_event_trig_stmt), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.whenclause <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.whenclause;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_event_trig_stmt), field(3)" pk
    | Some (4, Pbrt.Bytes) -> begin
      v.funcname <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.funcname;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_event_trig_stmt), field(4)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    trigname = v.trigname;
    eventname = v.eventname;
    whenclause = v.whenclause;
    funcname = v.funcname;
  } : create_event_trig_stmt)

and decode_pb_refresh_mat_view_stmt d =
  let v = default_refresh_mat_view_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Varint) -> begin
      v.concurrent <- Pbrt.Decoder.bool d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(refresh_mat_view_stmt), field(1)" pk
    | Some (2, Pbrt.Varint) -> begin
      v.skip_data <- Pbrt.Decoder.bool d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(refresh_mat_view_stmt), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.relation <- Some (decode_pb_range_var (Pbrt.Decoder.nested d));
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(refresh_mat_view_stmt), field(3)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    concurrent = v.concurrent;
    skip_data = v.skip_data;
    relation = v.relation;
  } : refresh_mat_view_stmt)

and decode_pb_alter_system_stmt d =
  let v = default_alter_system_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.setstmt <- Some (decode_pb_variable_set_stmt (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_system_stmt), field(1)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    setstmt = v.setstmt;
  } : alter_system_stmt)

and decode_pb_create_policy_stmt d =
  let v = default_create_policy_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.roles <- List.rev v.roles;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.policy_name <- Pbrt.Decoder.string d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_policy_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.table <- Some (decode_pb_range_var (Pbrt.Decoder.nested d));
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_policy_stmt), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.cmd_name <- Pbrt.Decoder.string d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_policy_stmt), field(3)" pk
    | Some (4, Pbrt.Varint) -> begin
      v.permissive <- Pbrt.Decoder.bool d;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_policy_stmt), field(4)" pk
    | Some (5, Pbrt.Bytes) -> begin
      v.roles <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.roles;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_policy_stmt), field(5)" pk
    | Some (6, Pbrt.Bytes) -> begin
      v.qual <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (6, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_policy_stmt), field(6)" pk
    | Some (7, Pbrt.Bytes) -> begin
      v.with_check <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (7, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_policy_stmt), field(7)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    policy_name = v.policy_name;
    table = v.table;
    cmd_name = v.cmd_name;
    permissive = v.permissive;
    roles = v.roles;
    qual = v.qual;
    with_check = v.with_check;
  } : create_policy_stmt)

and decode_pb_alter_policy_stmt d =
  let v = default_alter_policy_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.roles <- List.rev v.roles;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.policy_name <- Pbrt.Decoder.string d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_policy_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.table <- Some (decode_pb_range_var (Pbrt.Decoder.nested d));
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_policy_stmt), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.roles <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.roles;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_policy_stmt), field(3)" pk
    | Some (4, Pbrt.Bytes) -> begin
      v.qual <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_policy_stmt), field(4)" pk
    | Some (5, Pbrt.Bytes) -> begin
      v.with_check <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_policy_stmt), field(5)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    policy_name = v.policy_name;
    table = v.table;
    roles = v.roles;
    qual = v.qual;
    with_check = v.with_check;
  } : alter_policy_stmt)

and decode_pb_create_transform_stmt d =
  let v = default_create_transform_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Varint) -> begin
      v.replace <- Pbrt.Decoder.bool d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_transform_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.type_name <- Some (decode_pb_type_name (Pbrt.Decoder.nested d));
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_transform_stmt), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.lang <- Pbrt.Decoder.string d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_transform_stmt), field(3)" pk
    | Some (4, Pbrt.Bytes) -> begin
      v.fromsql <- Some (decode_pb_object_with_args (Pbrt.Decoder.nested d));
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_transform_stmt), field(4)" pk
    | Some (5, Pbrt.Bytes) -> begin
      v.tosql <- Some (decode_pb_object_with_args (Pbrt.Decoder.nested d));
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_transform_stmt), field(5)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    replace = v.replace;
    type_name = v.type_name;
    lang = v.lang;
    fromsql = v.fromsql;
    tosql = v.tosql;
  } : create_transform_stmt)

and decode_pb_create_am_stmt d =
  let v = default_create_am_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.handler_name <- List.rev v.handler_name;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.amname <- Pbrt.Decoder.string d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_am_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.handler_name <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.handler_name;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_am_stmt), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.amtype <- Pbrt.Decoder.string d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_am_stmt), field(3)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    amname = v.amname;
    handler_name = v.handler_name;
    amtype = v.amtype;
  } : create_am_stmt)

and decode_pb_create_publication_stmt d =
  let v = default_create_publication_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.tables <- List.rev v.tables;
      v.options <- List.rev v.options;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.pubname <- Pbrt.Decoder.string d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_publication_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.options <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.options;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_publication_stmt), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.tables <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.tables;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_publication_stmt), field(3)" pk
    | Some (4, Pbrt.Varint) -> begin
      v.for_all_tables <- Pbrt.Decoder.bool d;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_publication_stmt), field(4)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    pubname = v.pubname;
    options = v.options;
    tables = v.tables;
    for_all_tables = v.for_all_tables;
  } : create_publication_stmt)

and decode_pb_alter_publication_stmt d =
  let v = default_alter_publication_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.tables <- List.rev v.tables;
      v.options <- List.rev v.options;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.pubname <- Pbrt.Decoder.string d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_publication_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.options <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.options;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_publication_stmt), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.tables <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.tables;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_publication_stmt), field(3)" pk
    | Some (4, Pbrt.Varint) -> begin
      v.for_all_tables <- Pbrt.Decoder.bool d;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_publication_stmt), field(4)" pk
    | Some (5, Pbrt.Varint) -> begin
      v.table_action <- decode_pb_def_elem_action d;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_publication_stmt), field(5)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    pubname = v.pubname;
    options = v.options;
    tables = v.tables;
    for_all_tables = v.for_all_tables;
    table_action = v.table_action;
  } : alter_publication_stmt)

and decode_pb_create_subscription_stmt d =
  let v = default_create_subscription_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.options <- List.rev v.options;
      v.publication <- List.rev v.publication;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.subname <- Pbrt.Decoder.string d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_subscription_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.conninfo <- Pbrt.Decoder.string d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_subscription_stmt), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.publication <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.publication;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_subscription_stmt), field(3)" pk
    | Some (4, Pbrt.Bytes) -> begin
      v.options <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.options;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_subscription_stmt), field(4)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    subname = v.subname;
    conninfo = v.conninfo;
    publication = v.publication;
    options = v.options;
  } : create_subscription_stmt)

and decode_pb_alter_subscription_stmt d =
  let v = default_alter_subscription_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.options <- List.rev v.options;
      v.publication <- List.rev v.publication;
    ); continue__ := false
    | Some (1, Pbrt.Varint) -> begin
      v.kind <- decode_pb_alter_subscription_type d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_subscription_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.subname <- Pbrt.Decoder.string d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_subscription_stmt), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.conninfo <- Pbrt.Decoder.string d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_subscription_stmt), field(3)" pk
    | Some (4, Pbrt.Bytes) -> begin
      v.publication <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.publication;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_subscription_stmt), field(4)" pk
    | Some (5, Pbrt.Bytes) -> begin
      v.options <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.options;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_subscription_stmt), field(5)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    kind = v.kind;
    subname = v.subname;
    conninfo = v.conninfo;
    publication = v.publication;
    options = v.options;
  } : alter_subscription_stmt)

and decode_pb_create_stats_stmt d =
  let v = default_create_stats_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.relations <- List.rev v.relations;
      v.exprs <- List.rev v.exprs;
      v.stat_types <- List.rev v.stat_types;
      v.defnames <- List.rev v.defnames;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.defnames <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.defnames;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_stats_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.stat_types <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.stat_types;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_stats_stmt), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.exprs <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.exprs;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_stats_stmt), field(3)" pk
    | Some (4, Pbrt.Bytes) -> begin
      v.relations <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.relations;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_stats_stmt), field(4)" pk
    | Some (5, Pbrt.Bytes) -> begin
      v.stxcomment <- Pbrt.Decoder.string d;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_stats_stmt), field(5)" pk
    | Some (6, Pbrt.Varint) -> begin
      v.if_not_exists <- Pbrt.Decoder.bool d;
    end
    | Some (6, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_stats_stmt), field(6)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    defnames = v.defnames;
    stat_types = v.stat_types;
    exprs = v.exprs;
    relations = v.relations;
    stxcomment = v.stxcomment;
    if_not_exists = v.if_not_exists;
  } : create_stats_stmt)

and decode_pb_alter_collation_stmt d =
  let v = default_alter_collation_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.collname <- List.rev v.collname;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.collname <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.collname;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_collation_stmt), field(1)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    collname = v.collname;
  } : alter_collation_stmt)

and decode_pb_call_stmt d =
  let v = default_call_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.funccall <- Some (decode_pb_func_call (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(call_stmt), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.funcexpr <- Some (decode_pb_func_expr (Pbrt.Decoder.nested d));
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(call_stmt), field(2)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    funccall = v.funccall;
    funcexpr = v.funcexpr;
  } : call_stmt)

and decode_pb_func_call d =
  let v = default_func_call_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.agg_order <- List.rev v.agg_order;
      v.args <- List.rev v.args;
      v.funcname <- List.rev v.funcname;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.funcname <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.funcname;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(func_call), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.args <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.args;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(func_call), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.agg_order <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.agg_order;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(func_call), field(3)" pk
    | Some (4, Pbrt.Bytes) -> begin
      v.agg_filter <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(func_call), field(4)" pk
    | Some (5, Pbrt.Varint) -> begin
      v.agg_within_group <- Pbrt.Decoder.bool d;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(func_call), field(5)" pk
    | Some (6, Pbrt.Varint) -> begin
      v.agg_star <- Pbrt.Decoder.bool d;
    end
    | Some (6, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(func_call), field(6)" pk
    | Some (7, Pbrt.Varint) -> begin
      v.agg_distinct <- Pbrt.Decoder.bool d;
    end
    | Some (7, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(func_call), field(7)" pk
    | Some (8, Pbrt.Varint) -> begin
      v.func_variadic <- Pbrt.Decoder.bool d;
    end
    | Some (8, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(func_call), field(8)" pk
    | Some (9, Pbrt.Bytes) -> begin
      v.over <- Some (decode_pb_window_def (Pbrt.Decoder.nested d));
    end
    | Some (9, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(func_call), field(9)" pk
    | Some (10, Pbrt.Varint) -> begin
      v.location <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (10, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(func_call), field(10)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    funcname = v.funcname;
    args = v.args;
    agg_order = v.agg_order;
    agg_filter = v.agg_filter;
    agg_within_group = v.agg_within_group;
    agg_star = v.agg_star;
    agg_distinct = v.agg_distinct;
    func_variadic = v.func_variadic;
    over = v.over;
    location = v.location;
  } : func_call)

and decode_pb_window_def d =
  let v = default_window_def_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.order_clause <- List.rev v.order_clause;
      v.partition_clause <- List.rev v.partition_clause;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.name <- Pbrt.Decoder.string d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(window_def), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.refname <- Pbrt.Decoder.string d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(window_def), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.partition_clause <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.partition_clause;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(window_def), field(3)" pk
    | Some (4, Pbrt.Bytes) -> begin
      v.order_clause <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.order_clause;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(window_def), field(4)" pk
    | Some (5, Pbrt.Varint) -> begin
      v.frame_options <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(window_def), field(5)" pk
    | Some (6, Pbrt.Bytes) -> begin
      v.start_offset <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (6, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(window_def), field(6)" pk
    | Some (7, Pbrt.Bytes) -> begin
      v.end_offset <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (7, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(window_def), field(7)" pk
    | Some (8, Pbrt.Varint) -> begin
      v.location <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (8, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(window_def), field(8)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    name = v.name;
    refname = v.refname;
    partition_clause = v.partition_clause;
    order_clause = v.order_clause;
    frame_options = v.frame_options;
    start_offset = v.start_offset;
    end_offset = v.end_offset;
    location = v.location;
  } : window_def)

and decode_pb_alter_stats_stmt d =
  let v = default_alter_stats_stmt_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.defnames <- List.rev v.defnames;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.defnames <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.defnames;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_stats_stmt), field(1)" pk
    | Some (2, Pbrt.Varint) -> begin
      v.stxstattarget <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_stats_stmt), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.missing_ok <- Pbrt.Decoder.bool d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(alter_stats_stmt), field(3)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    defnames = v.defnames;
    stxstattarget = v.stxstattarget;
    missing_ok = v.missing_ok;
  } : alter_stats_stmt)

and decode_pb_a_expr d =
  let v = default_a_expr_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.name <- List.rev v.name;
    ); continue__ := false
    | Some (1, Pbrt.Varint) -> begin
      v.kind <- decode_pb_a_expr_kind d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(a_expr), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.name <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.name;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(a_expr), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.lexpr <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(a_expr), field(3)" pk
    | Some (4, Pbrt.Bytes) -> begin
      v.rexpr <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(a_expr), field(4)" pk
    | Some (5, Pbrt.Varint) -> begin
      v.location <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(a_expr), field(5)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    kind = v.kind;
    name = v.name;
    lexpr = v.lexpr;
    rexpr = v.rexpr;
    location = v.location;
  } : a_expr)

and decode_pb_column_ref d =
  let v = default_column_ref_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.fields <- List.rev v.fields;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.fields <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.fields;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(column_ref), field(1)" pk
    | Some (2, Pbrt.Varint) -> begin
      v.location <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(column_ref), field(2)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    fields = v.fields;
    location = v.location;
  } : column_ref)

and decode_pb_a_const d =
  let v = default_a_const_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.val_ <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(a_const), field(1)" pk
    | Some (2, Pbrt.Varint) -> begin
      v.location <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(a_const), field(2)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    val_ = v.val_;
    location = v.location;
  } : a_const)

and decode_pb_a_indices d =
  let v = default_a_indices_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Varint) -> begin
      v.is_slice <- Pbrt.Decoder.bool d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(a_indices), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.lidx <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(a_indices), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.uidx <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(a_indices), field(3)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    is_slice = v.is_slice;
    lidx = v.lidx;
    uidx = v.uidx;
  } : a_indices)

and decode_pb_a_indirection d =
  let v = default_a_indirection_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.indirection <- List.rev v.indirection;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.arg <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(a_indirection), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.indirection <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.indirection;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(a_indirection), field(2)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    arg = v.arg;
    indirection = v.indirection;
  } : a_indirection)

and decode_pb_a_array_expr d =
  let v = default_a_array_expr_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.elements <- List.rev v.elements;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.elements <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.elements;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(a_array_expr), field(1)" pk
    | Some (2, Pbrt.Varint) -> begin
      v.location <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(a_array_expr), field(2)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    elements = v.elements;
    location = v.location;
  } : a_array_expr)

and decode_pb_res_target d =
  let v = default_res_target_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.indirection <- List.rev v.indirection;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.name <- Pbrt.Decoder.string d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(res_target), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.indirection <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.indirection;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(res_target), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.val_ <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(res_target), field(3)" pk
    | Some (4, Pbrt.Varint) -> begin
      v.location <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(res_target), field(4)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    name = v.name;
    indirection = v.indirection;
    val_ = v.val_;
    location = v.location;
  } : res_target)

and decode_pb_multi_assign_ref d =
  let v = default_multi_assign_ref_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.source <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(multi_assign_ref), field(1)" pk
    | Some (2, Pbrt.Varint) -> begin
      v.colno <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(multi_assign_ref), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.ncolumns <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(multi_assign_ref), field(3)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    source = v.source;
    colno = v.colno;
    ncolumns = v.ncolumns;
  } : multi_assign_ref)

and decode_pb_type_cast d =
  let v = default_type_cast_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.arg <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(type_cast), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.type_name <- Some (decode_pb_type_name (Pbrt.Decoder.nested d));
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(type_cast), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.location <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(type_cast), field(3)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    arg = v.arg;
    type_name = v.type_name;
    location = v.location;
  } : type_cast)

and decode_pb_sort_by d =
  let v = default_sort_by_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.use_op <- List.rev v.use_op;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.node <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(sort_by), field(1)" pk
    | Some (2, Pbrt.Varint) -> begin
      v.sortby_dir <- decode_pb_sort_by_dir d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(sort_by), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.sortby_nulls <- decode_pb_sort_by_nulls d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(sort_by), field(3)" pk
    | Some (4, Pbrt.Bytes) -> begin
      v.use_op <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.use_op;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(sort_by), field(4)" pk
    | Some (5, Pbrt.Varint) -> begin
      v.location <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(sort_by), field(5)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    node = v.node;
    sortby_dir = v.sortby_dir;
    sortby_nulls = v.sortby_nulls;
    use_op = v.use_op;
    location = v.location;
  } : sort_by)

and decode_pb_range_subselect d =
  let v = default_range_subselect_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Varint) -> begin
      v.lateral <- Pbrt.Decoder.bool d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_subselect), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.subquery <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_subselect), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.alias <- Some (decode_pb_alias (Pbrt.Decoder.nested d));
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_subselect), field(3)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    lateral = v.lateral;
    subquery = v.subquery;
    alias = v.alias;
  } : range_subselect)

and decode_pb_range_function d =
  let v = default_range_function_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.coldeflist <- List.rev v.coldeflist;
      v.functions <- List.rev v.functions;
    ); continue__ := false
    | Some (1, Pbrt.Varint) -> begin
      v.lateral <- Pbrt.Decoder.bool d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_function), field(1)" pk
    | Some (2, Pbrt.Varint) -> begin
      v.ordinality <- Pbrt.Decoder.bool d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_function), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.is_rowsfrom <- Pbrt.Decoder.bool d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_function), field(3)" pk
    | Some (4, Pbrt.Bytes) -> begin
      v.functions <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.functions;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_function), field(4)" pk
    | Some (5, Pbrt.Bytes) -> begin
      v.alias <- Some (decode_pb_alias (Pbrt.Decoder.nested d));
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_function), field(5)" pk
    | Some (6, Pbrt.Bytes) -> begin
      v.coldeflist <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.coldeflist;
    end
    | Some (6, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_function), field(6)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    lateral = v.lateral;
    ordinality = v.ordinality;
    is_rowsfrom = v.is_rowsfrom;
    functions = v.functions;
    alias = v.alias;
    coldeflist = v.coldeflist;
  } : range_function)

and decode_pb_range_table_sample d =
  let v = default_range_table_sample_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.args <- List.rev v.args;
      v.method_ <- List.rev v.method_;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.relation <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_table_sample), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.method_ <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.method_;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_table_sample), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.args <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.args;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_table_sample), field(3)" pk
    | Some (4, Pbrt.Bytes) -> begin
      v.repeatable <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_table_sample), field(4)" pk
    | Some (5, Pbrt.Varint) -> begin
      v.location <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_table_sample), field(5)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    relation = v.relation;
    method_ = v.method_;
    args = v.args;
    repeatable = v.repeatable;
    location = v.location;
  } : range_table_sample)

and decode_pb_range_table_func d =
  let v = default_range_table_func_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.columns <- List.rev v.columns;
      v.namespaces <- List.rev v.namespaces;
    ); continue__ := false
    | Some (1, Pbrt.Varint) -> begin
      v.lateral <- Pbrt.Decoder.bool d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_table_func), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.docexpr <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_table_func), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.rowexpr <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_table_func), field(3)" pk
    | Some (4, Pbrt.Bytes) -> begin
      v.namespaces <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.namespaces;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_table_func), field(4)" pk
    | Some (5, Pbrt.Bytes) -> begin
      v.columns <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.columns;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_table_func), field(5)" pk
    | Some (6, Pbrt.Bytes) -> begin
      v.alias <- Some (decode_pb_alias (Pbrt.Decoder.nested d));
    end
    | Some (6, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_table_func), field(6)" pk
    | Some (7, Pbrt.Varint) -> begin
      v.location <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (7, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_table_func), field(7)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    lateral = v.lateral;
    docexpr = v.docexpr;
    rowexpr = v.rowexpr;
    namespaces = v.namespaces;
    columns = v.columns;
    alias = v.alias;
    location = v.location;
  } : range_table_func)

and decode_pb_range_table_func_col d =
  let v = default_range_table_func_col_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.colname <- Pbrt.Decoder.string d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_table_func_col), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.type_name <- Some (decode_pb_type_name (Pbrt.Decoder.nested d));
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_table_func_col), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.for_ordinality <- Pbrt.Decoder.bool d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_table_func_col), field(3)" pk
    | Some (4, Pbrt.Varint) -> begin
      v.is_not_null <- Pbrt.Decoder.bool d;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_table_func_col), field(4)" pk
    | Some (5, Pbrt.Bytes) -> begin
      v.colexpr <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_table_func_col), field(5)" pk
    | Some (6, Pbrt.Bytes) -> begin
      v.coldefexpr <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (6, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_table_func_col), field(6)" pk
    | Some (7, Pbrt.Varint) -> begin
      v.location <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (7, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_table_func_col), field(7)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    colname = v.colname;
    type_name = v.type_name;
    for_ordinality = v.for_ordinality;
    is_not_null = v.is_not_null;
    colexpr = v.colexpr;
    coldefexpr = v.coldefexpr;
    location = v.location;
  } : range_table_func_col)

and decode_pb_column_def d =
  let v = default_column_def_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.fdwoptions <- List.rev v.fdwoptions;
      v.constraints <- List.rev v.constraints;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.colname <- Pbrt.Decoder.string d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(column_def), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.type_name <- Some (decode_pb_type_name (Pbrt.Decoder.nested d));
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(column_def), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.inhcount <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(column_def), field(3)" pk
    | Some (4, Pbrt.Varint) -> begin
      v.is_local <- Pbrt.Decoder.bool d;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(column_def), field(4)" pk
    | Some (5, Pbrt.Varint) -> begin
      v.is_not_null <- Pbrt.Decoder.bool d;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(column_def), field(5)" pk
    | Some (6, Pbrt.Varint) -> begin
      v.is_from_type <- Pbrt.Decoder.bool d;
    end
    | Some (6, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(column_def), field(6)" pk
    | Some (7, Pbrt.Bytes) -> begin
      v.storage <- Pbrt.Decoder.string d;
    end
    | Some (7, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(column_def), field(7)" pk
    | Some (8, Pbrt.Bytes) -> begin
      v.raw_default <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (8, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(column_def), field(8)" pk
    | Some (9, Pbrt.Bytes) -> begin
      v.cooked_default <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (9, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(column_def), field(9)" pk
    | Some (10, Pbrt.Bytes) -> begin
      v.identity <- Pbrt.Decoder.string d;
    end
    | Some (10, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(column_def), field(10)" pk
    | Some (11, Pbrt.Bytes) -> begin
      v.identity_sequence <- Some (decode_pb_range_var (Pbrt.Decoder.nested d));
    end
    | Some (11, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(column_def), field(11)" pk
    | Some (12, Pbrt.Bytes) -> begin
      v.generated <- Pbrt.Decoder.string d;
    end
    | Some (12, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(column_def), field(12)" pk
    | Some (13, Pbrt.Bytes) -> begin
      v.coll_clause <- Some (decode_pb_collate_clause (Pbrt.Decoder.nested d));
    end
    | Some (13, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(column_def), field(13)" pk
    | Some (14, Pbrt.Varint) -> begin
      v.coll_oid <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (14, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(column_def), field(14)" pk
    | Some (15, Pbrt.Bytes) -> begin
      v.constraints <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.constraints;
    end
    | Some (15, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(column_def), field(15)" pk
    | Some (16, Pbrt.Bytes) -> begin
      v.fdwoptions <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.fdwoptions;
    end
    | Some (16, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(column_def), field(16)" pk
    | Some (17, Pbrt.Varint) -> begin
      v.location <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (17, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(column_def), field(17)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    colname = v.colname;
    type_name = v.type_name;
    inhcount = v.inhcount;
    is_local = v.is_local;
    is_not_null = v.is_not_null;
    is_from_type = v.is_from_type;
    storage = v.storage;
    raw_default = v.raw_default;
    cooked_default = v.cooked_default;
    identity = v.identity;
    identity_sequence = v.identity_sequence;
    generated = v.generated;
    coll_clause = v.coll_clause;
    coll_oid = v.coll_oid;
    constraints = v.constraints;
    fdwoptions = v.fdwoptions;
    location = v.location;
  } : column_def)

and decode_pb_index_elem d =
  let v = default_index_elem_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.opclassopts <- List.rev v.opclassopts;
      v.opclass <- List.rev v.opclass;
      v.collation <- List.rev v.collation;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.name <- Pbrt.Decoder.string d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(index_elem), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.expr <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(index_elem), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.indexcolname <- Pbrt.Decoder.string d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(index_elem), field(3)" pk
    | Some (4, Pbrt.Bytes) -> begin
      v.collation <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.collation;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(index_elem), field(4)" pk
    | Some (5, Pbrt.Bytes) -> begin
      v.opclass <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.opclass;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(index_elem), field(5)" pk
    | Some (6, Pbrt.Bytes) -> begin
      v.opclassopts <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.opclassopts;
    end
    | Some (6, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(index_elem), field(6)" pk
    | Some (7, Pbrt.Varint) -> begin
      v.ordering <- decode_pb_sort_by_dir d;
    end
    | Some (7, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(index_elem), field(7)" pk
    | Some (8, Pbrt.Varint) -> begin
      v.nulls_ordering <- decode_pb_sort_by_nulls d;
    end
    | Some (8, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(index_elem), field(8)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    name = v.name;
    expr = v.expr;
    indexcolname = v.indexcolname;
    collation = v.collation;
    opclass = v.opclass;
    opclassopts = v.opclassopts;
    ordering = v.ordering;
    nulls_ordering = v.nulls_ordering;
  } : index_elem)

and decode_pb_constraint_ d =
  let v = default_constraint__mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.old_conpfeqop <- List.rev v.old_conpfeqop;
      v.pk_attrs <- List.rev v.pk_attrs;
      v.fk_attrs <- List.rev v.fk_attrs;
      v.options <- List.rev v.options;
      v.exclusions <- List.rev v.exclusions;
      v.including <- List.rev v.including;
      v.keys <- List.rev v.keys;
    ); continue__ := false
    | Some (1, Pbrt.Varint) -> begin
      v.contype <- decode_pb_constr_type d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(constraint_), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.conname <- Pbrt.Decoder.string d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(constraint_), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.deferrable <- Pbrt.Decoder.bool d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(constraint_), field(3)" pk
    | Some (4, Pbrt.Varint) -> begin
      v.initdeferred <- Pbrt.Decoder.bool d;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(constraint_), field(4)" pk
    | Some (5, Pbrt.Varint) -> begin
      v.location <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(constraint_), field(5)" pk
    | Some (6, Pbrt.Varint) -> begin
      v.is_no_inherit <- Pbrt.Decoder.bool d;
    end
    | Some (6, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(constraint_), field(6)" pk
    | Some (7, Pbrt.Bytes) -> begin
      v.raw_expr <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (7, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(constraint_), field(7)" pk
    | Some (8, Pbrt.Bytes) -> begin
      v.cooked_expr <- Pbrt.Decoder.string d;
    end
    | Some (8, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(constraint_), field(8)" pk
    | Some (9, Pbrt.Bytes) -> begin
      v.generated_when <- Pbrt.Decoder.string d;
    end
    | Some (9, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(constraint_), field(9)" pk
    | Some (10, Pbrt.Bytes) -> begin
      v.keys <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.keys;
    end
    | Some (10, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(constraint_), field(10)" pk
    | Some (11, Pbrt.Bytes) -> begin
      v.including <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.including;
    end
    | Some (11, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(constraint_), field(11)" pk
    | Some (12, Pbrt.Bytes) -> begin
      v.exclusions <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.exclusions;
    end
    | Some (12, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(constraint_), field(12)" pk
    | Some (13, Pbrt.Bytes) -> begin
      v.options <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.options;
    end
    | Some (13, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(constraint_), field(13)" pk
    | Some (14, Pbrt.Bytes) -> begin
      v.indexname <- Pbrt.Decoder.string d;
    end
    | Some (14, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(constraint_), field(14)" pk
    | Some (15, Pbrt.Bytes) -> begin
      v.indexspace <- Pbrt.Decoder.string d;
    end
    | Some (15, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(constraint_), field(15)" pk
    | Some (16, Pbrt.Varint) -> begin
      v.reset_default_tblspc <- Pbrt.Decoder.bool d;
    end
    | Some (16, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(constraint_), field(16)" pk
    | Some (17, Pbrt.Bytes) -> begin
      v.access_method <- Pbrt.Decoder.string d;
    end
    | Some (17, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(constraint_), field(17)" pk
    | Some (18, Pbrt.Bytes) -> begin
      v.where_clause <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (18, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(constraint_), field(18)" pk
    | Some (19, Pbrt.Bytes) -> begin
      v.pktable <- Some (decode_pb_range_var (Pbrt.Decoder.nested d));
    end
    | Some (19, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(constraint_), field(19)" pk
    | Some (20, Pbrt.Bytes) -> begin
      v.fk_attrs <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.fk_attrs;
    end
    | Some (20, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(constraint_), field(20)" pk
    | Some (21, Pbrt.Bytes) -> begin
      v.pk_attrs <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.pk_attrs;
    end
    | Some (21, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(constraint_), field(21)" pk
    | Some (22, Pbrt.Bytes) -> begin
      v.fk_matchtype <- Pbrt.Decoder.string d;
    end
    | Some (22, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(constraint_), field(22)" pk
    | Some (23, Pbrt.Bytes) -> begin
      v.fk_upd_action <- Pbrt.Decoder.string d;
    end
    | Some (23, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(constraint_), field(23)" pk
    | Some (24, Pbrt.Bytes) -> begin
      v.fk_del_action <- Pbrt.Decoder.string d;
    end
    | Some (24, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(constraint_), field(24)" pk
    | Some (25, Pbrt.Bytes) -> begin
      v.old_conpfeqop <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.old_conpfeqop;
    end
    | Some (25, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(constraint_), field(25)" pk
    | Some (26, Pbrt.Varint) -> begin
      v.old_pktable_oid <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (26, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(constraint_), field(26)" pk
    | Some (27, Pbrt.Varint) -> begin
      v.skip_validation <- Pbrt.Decoder.bool d;
    end
    | Some (27, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(constraint_), field(27)" pk
    | Some (28, Pbrt.Varint) -> begin
      v.initially_valid <- Pbrt.Decoder.bool d;
    end
    | Some (28, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(constraint_), field(28)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    contype = v.contype;
    conname = v.conname;
    deferrable = v.deferrable;
    initdeferred = v.initdeferred;
    location = v.location;
    is_no_inherit = v.is_no_inherit;
    raw_expr = v.raw_expr;
    cooked_expr = v.cooked_expr;
    generated_when = v.generated_when;
    keys = v.keys;
    including = v.including;
    exclusions = v.exclusions;
    options = v.options;
    indexname = v.indexname;
    indexspace = v.indexspace;
    reset_default_tblspc = v.reset_default_tblspc;
    access_method = v.access_method;
    where_clause = v.where_clause;
    pktable = v.pktable;
    fk_attrs = v.fk_attrs;
    pk_attrs = v.pk_attrs;
    fk_matchtype = v.fk_matchtype;
    fk_upd_action = v.fk_upd_action;
    fk_del_action = v.fk_del_action;
    old_conpfeqop = v.old_conpfeqop;
    old_pktable_oid = v.old_pktable_oid;
    skip_validation = v.skip_validation;
    initially_valid = v.initially_valid;
  } : constraint_)

and decode_pb_def_elem d =
  let v = default_def_elem_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.defnamespace <- Pbrt.Decoder.string d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(def_elem), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.defname <- Pbrt.Decoder.string d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(def_elem), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.arg <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(def_elem), field(3)" pk
    | Some (4, Pbrt.Varint) -> begin
      v.defaction <- decode_pb_def_elem_action d;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(def_elem), field(4)" pk
    | Some (5, Pbrt.Varint) -> begin
      v.location <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(def_elem), field(5)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    defnamespace = v.defnamespace;
    defname = v.defname;
    arg = v.arg;
    defaction = v.defaction;
    location = v.location;
  } : def_elem)

and decode_pb_range_tbl_entry d =
  let v = default_range_tbl_entry_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.security_quals <- List.rev v.security_quals;
      v.extra_updated_cols <- List.rev v.extra_updated_cols;
      v.updated_cols <- List.rev v.updated_cols;
      v.inserted_cols <- List.rev v.inserted_cols;
      v.selected_cols <- List.rev v.selected_cols;
      v.colcollations <- List.rev v.colcollations;
      v.coltypmods <- List.rev v.coltypmods;
      v.coltypes <- List.rev v.coltypes;
      v.values_lists <- List.rev v.values_lists;
      v.functions <- List.rev v.functions;
      v.joinrightcols <- List.rev v.joinrightcols;
      v.joinleftcols <- List.rev v.joinleftcols;
      v.joinaliasvars <- List.rev v.joinaliasvars;
    ); continue__ := false
    | Some (1, Pbrt.Varint) -> begin
      v.rtekind <- decode_pb_rtekind d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_tbl_entry), field(1)" pk
    | Some (2, Pbrt.Varint) -> begin
      v.relid <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_tbl_entry), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.relkind <- Pbrt.Decoder.string d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_tbl_entry), field(3)" pk
    | Some (4, Pbrt.Varint) -> begin
      v.rellockmode <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_tbl_entry), field(4)" pk
    | Some (5, Pbrt.Bytes) -> begin
      v.tablesample <- Some (decode_pb_table_sample_clause (Pbrt.Decoder.nested d));
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_tbl_entry), field(5)" pk
    | Some (6, Pbrt.Bytes) -> begin
      v.subquery <- Some (decode_pb_query (Pbrt.Decoder.nested d));
    end
    | Some (6, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_tbl_entry), field(6)" pk
    | Some (7, Pbrt.Varint) -> begin
      v.security_barrier <- Pbrt.Decoder.bool d;
    end
    | Some (7, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_tbl_entry), field(7)" pk
    | Some (8, Pbrt.Varint) -> begin
      v.jointype <- decode_pb_join_type d;
    end
    | Some (8, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_tbl_entry), field(8)" pk
    | Some (9, Pbrt.Varint) -> begin
      v.joinmergedcols <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (9, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_tbl_entry), field(9)" pk
    | Some (10, Pbrt.Bytes) -> begin
      v.joinaliasvars <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.joinaliasvars;
    end
    | Some (10, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_tbl_entry), field(10)" pk
    | Some (11, Pbrt.Bytes) -> begin
      v.joinleftcols <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.joinleftcols;
    end
    | Some (11, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_tbl_entry), field(11)" pk
    | Some (12, Pbrt.Bytes) -> begin
      v.joinrightcols <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.joinrightcols;
    end
    | Some (12, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_tbl_entry), field(12)" pk
    | Some (13, Pbrt.Bytes) -> begin
      v.functions <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.functions;
    end
    | Some (13, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_tbl_entry), field(13)" pk
    | Some (14, Pbrt.Varint) -> begin
      v.funcordinality <- Pbrt.Decoder.bool d;
    end
    | Some (14, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_tbl_entry), field(14)" pk
    | Some (15, Pbrt.Bytes) -> begin
      v.tablefunc <- Some (decode_pb_table_func (Pbrt.Decoder.nested d));
    end
    | Some (15, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_tbl_entry), field(15)" pk
    | Some (16, Pbrt.Bytes) -> begin
      v.values_lists <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.values_lists;
    end
    | Some (16, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_tbl_entry), field(16)" pk
    | Some (17, Pbrt.Bytes) -> begin
      v.ctename <- Pbrt.Decoder.string d;
    end
    | Some (17, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_tbl_entry), field(17)" pk
    | Some (18, Pbrt.Varint) -> begin
      v.ctelevelsup <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (18, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_tbl_entry), field(18)" pk
    | Some (19, Pbrt.Varint) -> begin
      v.self_reference <- Pbrt.Decoder.bool d;
    end
    | Some (19, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_tbl_entry), field(19)" pk
    | Some (20, Pbrt.Bytes) -> begin
      v.coltypes <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.coltypes;
    end
    | Some (20, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_tbl_entry), field(20)" pk
    | Some (21, Pbrt.Bytes) -> begin
      v.coltypmods <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.coltypmods;
    end
    | Some (21, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_tbl_entry), field(21)" pk
    | Some (22, Pbrt.Bytes) -> begin
      v.colcollations <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.colcollations;
    end
    | Some (22, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_tbl_entry), field(22)" pk
    | Some (23, Pbrt.Bytes) -> begin
      v.enrname <- Pbrt.Decoder.string d;
    end
    | Some (23, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_tbl_entry), field(23)" pk
    | Some (24, Pbrt.Bits64) -> begin
      v.enrtuples <- Pbrt.Decoder.float_as_bits64 d;
    end
    | Some (24, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_tbl_entry), field(24)" pk
    | Some (25, Pbrt.Bytes) -> begin
      v.alias <- Some (decode_pb_alias (Pbrt.Decoder.nested d));
    end
    | Some (25, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_tbl_entry), field(25)" pk
    | Some (26, Pbrt.Bytes) -> begin
      v.eref <- Some (decode_pb_alias (Pbrt.Decoder.nested d));
    end
    | Some (26, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_tbl_entry), field(26)" pk
    | Some (27, Pbrt.Varint) -> begin
      v.lateral <- Pbrt.Decoder.bool d;
    end
    | Some (27, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_tbl_entry), field(27)" pk
    | Some (28, Pbrt.Varint) -> begin
      v.inh <- Pbrt.Decoder.bool d;
    end
    | Some (28, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_tbl_entry), field(28)" pk
    | Some (29, Pbrt.Varint) -> begin
      v.in_from_cl <- Pbrt.Decoder.bool d;
    end
    | Some (29, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_tbl_entry), field(29)" pk
    | Some (30, Pbrt.Varint) -> begin
      v.required_perms <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (30, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_tbl_entry), field(30)" pk
    | Some (31, Pbrt.Varint) -> begin
      v.check_as_user <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (31, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_tbl_entry), field(31)" pk
    | Some (32, Pbrt.Bytes) -> begin
      v.selected_cols <- Pbrt.Decoder.packed_fold (fun l d -> (Pbrt.Decoder.int64_as_varint d)::l) [] d;
    end
    | Some (32, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_tbl_entry), field(32)" pk
    | Some (33, Pbrt.Bytes) -> begin
      v.inserted_cols <- Pbrt.Decoder.packed_fold (fun l d -> (Pbrt.Decoder.int64_as_varint d)::l) [] d;
    end
    | Some (33, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_tbl_entry), field(33)" pk
    | Some (34, Pbrt.Bytes) -> begin
      v.updated_cols <- Pbrt.Decoder.packed_fold (fun l d -> (Pbrt.Decoder.int64_as_varint d)::l) [] d;
    end
    | Some (34, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_tbl_entry), field(34)" pk
    | Some (35, Pbrt.Bytes) -> begin
      v.extra_updated_cols <- Pbrt.Decoder.packed_fold (fun l d -> (Pbrt.Decoder.int64_as_varint d)::l) [] d;
    end
    | Some (35, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_tbl_entry), field(35)" pk
    | Some (36, Pbrt.Bytes) -> begin
      v.security_quals <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.security_quals;
    end
    | Some (36, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_tbl_entry), field(36)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    rtekind = v.rtekind;
    relid = v.relid;
    relkind = v.relkind;
    rellockmode = v.rellockmode;
    tablesample = v.tablesample;
    subquery = v.subquery;
    security_barrier = v.security_barrier;
    jointype = v.jointype;
    joinmergedcols = v.joinmergedcols;
    joinaliasvars = v.joinaliasvars;
    joinleftcols = v.joinleftcols;
    joinrightcols = v.joinrightcols;
    functions = v.functions;
    funcordinality = v.funcordinality;
    tablefunc = v.tablefunc;
    values_lists = v.values_lists;
    ctename = v.ctename;
    ctelevelsup = v.ctelevelsup;
    self_reference = v.self_reference;
    coltypes = v.coltypes;
    coltypmods = v.coltypmods;
    colcollations = v.colcollations;
    enrname = v.enrname;
    enrtuples = v.enrtuples;
    alias = v.alias;
    eref = v.eref;
    lateral = v.lateral;
    inh = v.inh;
    in_from_cl = v.in_from_cl;
    required_perms = v.required_perms;
    check_as_user = v.check_as_user;
    selected_cols = v.selected_cols;
    inserted_cols = v.inserted_cols;
    updated_cols = v.updated_cols;
    extra_updated_cols = v.extra_updated_cols;
    security_quals = v.security_quals;
  } : range_tbl_entry)

and decode_pb_table_sample_clause d =
  let v = default_table_sample_clause_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.args <- List.rev v.args;
    ); continue__ := false
    | Some (1, Pbrt.Varint) -> begin
      v.tsmhandler <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(table_sample_clause), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.args <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.args;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(table_sample_clause), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.repeatable <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(table_sample_clause), field(3)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    tsmhandler = v.tsmhandler;
    args = v.args;
    repeatable = v.repeatable;
  } : table_sample_clause)

and decode_pb_range_tbl_function d =
  let v = default_range_tbl_function_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.funcparams <- List.rev v.funcparams;
      v.funccolcollations <- List.rev v.funccolcollations;
      v.funccoltypmods <- List.rev v.funccoltypmods;
      v.funccoltypes <- List.rev v.funccoltypes;
      v.funccolnames <- List.rev v.funccolnames;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.funcexpr <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_tbl_function), field(1)" pk
    | Some (2, Pbrt.Varint) -> begin
      v.funccolcount <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_tbl_function), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.funccolnames <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.funccolnames;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_tbl_function), field(3)" pk
    | Some (4, Pbrt.Bytes) -> begin
      v.funccoltypes <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.funccoltypes;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_tbl_function), field(4)" pk
    | Some (5, Pbrt.Bytes) -> begin
      v.funccoltypmods <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.funccoltypmods;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_tbl_function), field(5)" pk
    | Some (6, Pbrt.Bytes) -> begin
      v.funccolcollations <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.funccolcollations;
    end
    | Some (6, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_tbl_function), field(6)" pk
    | Some (7, Pbrt.Bytes) -> begin
      v.funcparams <- Pbrt.Decoder.packed_fold (fun l d -> (Pbrt.Decoder.int64_as_varint d)::l) [] d;
    end
    | Some (7, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(range_tbl_function), field(7)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    funcexpr = v.funcexpr;
    funccolcount = v.funccolcount;
    funccolnames = v.funccolnames;
    funccoltypes = v.funccoltypes;
    funccoltypmods = v.funccoltypmods;
    funccolcollations = v.funccolcollations;
    funcparams = v.funcparams;
  } : range_tbl_function)

and decode_pb_with_check_option d =
  let v = default_with_check_option_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Varint) -> begin
      v.kind <- decode_pb_wcokind d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(with_check_option), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.relname <- Pbrt.Decoder.string d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(with_check_option), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.polname <- Pbrt.Decoder.string d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(with_check_option), field(3)" pk
    | Some (4, Pbrt.Bytes) -> begin
      v.qual <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(with_check_option), field(4)" pk
    | Some (5, Pbrt.Varint) -> begin
      v.cascaded <- Pbrt.Decoder.bool d;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(with_check_option), field(5)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    kind = v.kind;
    relname = v.relname;
    polname = v.polname;
    qual = v.qual;
    cascaded = v.cascaded;
  } : with_check_option)

and decode_pb_grouping_set d =
  let v = default_grouping_set_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.content <- List.rev v.content;
    ); continue__ := false
    | Some (1, Pbrt.Varint) -> begin
      v.kind <- decode_pb_grouping_set_kind d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(grouping_set), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.content <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.content;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(grouping_set), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.location <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(grouping_set), field(3)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    kind = v.kind;
    content = v.content;
    location = v.location;
  } : grouping_set)

and decode_pb_window_clause d =
  let v = default_window_clause_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.order_clause <- List.rev v.order_clause;
      v.partition_clause <- List.rev v.partition_clause;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.name <- Pbrt.Decoder.string d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(window_clause), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.refname <- Pbrt.Decoder.string d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(window_clause), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.partition_clause <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.partition_clause;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(window_clause), field(3)" pk
    | Some (4, Pbrt.Bytes) -> begin
      v.order_clause <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.order_clause;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(window_clause), field(4)" pk
    | Some (5, Pbrt.Varint) -> begin
      v.frame_options <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(window_clause), field(5)" pk
    | Some (6, Pbrt.Bytes) -> begin
      v.start_offset <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (6, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(window_clause), field(6)" pk
    | Some (7, Pbrt.Bytes) -> begin
      v.end_offset <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (7, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(window_clause), field(7)" pk
    | Some (8, Pbrt.Varint) -> begin
      v.start_in_range_func <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (8, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(window_clause), field(8)" pk
    | Some (9, Pbrt.Varint) -> begin
      v.end_in_range_func <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (9, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(window_clause), field(9)" pk
    | Some (10, Pbrt.Varint) -> begin
      v.in_range_coll <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (10, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(window_clause), field(10)" pk
    | Some (11, Pbrt.Varint) -> begin
      v.in_range_asc <- Pbrt.Decoder.bool d;
    end
    | Some (11, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(window_clause), field(11)" pk
    | Some (12, Pbrt.Varint) -> begin
      v.in_range_nulls_first <- Pbrt.Decoder.bool d;
    end
    | Some (12, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(window_clause), field(12)" pk
    | Some (13, Pbrt.Varint) -> begin
      v.winref <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (13, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(window_clause), field(13)" pk
    | Some (14, Pbrt.Varint) -> begin
      v.copied_order <- Pbrt.Decoder.bool d;
    end
    | Some (14, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(window_clause), field(14)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    name = v.name;
    refname = v.refname;
    partition_clause = v.partition_clause;
    order_clause = v.order_clause;
    frame_options = v.frame_options;
    start_offset = v.start_offset;
    end_offset = v.end_offset;
    start_in_range_func = v.start_in_range_func;
    end_in_range_func = v.end_in_range_func;
    in_range_coll = v.in_range_coll;
    in_range_asc = v.in_range_asc;
    in_range_nulls_first = v.in_range_nulls_first;
    winref = v.winref;
    copied_order = v.copied_order;
  } : window_clause)

and decode_pb_access_priv d =
  let v = default_access_priv_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.cols <- List.rev v.cols;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.priv_name <- Pbrt.Decoder.string d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(access_priv), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.cols <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.cols;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(access_priv), field(2)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    priv_name = v.priv_name;
    cols = v.cols;
  } : access_priv)

and decode_pb_create_op_class_item d =
  let v = default_create_op_class_item_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.class_args <- List.rev v.class_args;
      v.order_family <- List.rev v.order_family;
    ); continue__ := false
    | Some (1, Pbrt.Varint) -> begin
      v.itemtype <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_op_class_item), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.name <- Some (decode_pb_object_with_args (Pbrt.Decoder.nested d));
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_op_class_item), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.number <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_op_class_item), field(3)" pk
    | Some (4, Pbrt.Bytes) -> begin
      v.order_family <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.order_family;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_op_class_item), field(4)" pk
    | Some (5, Pbrt.Bytes) -> begin
      v.class_args <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.class_args;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_op_class_item), field(5)" pk
    | Some (6, Pbrt.Bytes) -> begin
      v.storedtype <- Some (decode_pb_type_name (Pbrt.Decoder.nested d));
    end
    | Some (6, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(create_op_class_item), field(6)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    itemtype = v.itemtype;
    name = v.name;
    number = v.number;
    order_family = v.order_family;
    class_args = v.class_args;
    storedtype = v.storedtype;
  } : create_op_class_item)

and decode_pb_table_like_clause d =
  let v = default_table_like_clause_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.relation <- Some (decode_pb_range_var (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(table_like_clause), field(1)" pk
    | Some (2, Pbrt.Varint) -> begin
      v.options <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(table_like_clause), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.relation_oid <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(table_like_clause), field(3)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    relation = v.relation;
    options = v.options;
    relation_oid = v.relation_oid;
  } : table_like_clause)

and decode_pb_function_parameter d =
  let v = default_function_parameter_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.name <- Pbrt.Decoder.string d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(function_parameter), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.arg_type <- Some (decode_pb_type_name (Pbrt.Decoder.nested d));
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(function_parameter), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.mode <- decode_pb_function_parameter_mode d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(function_parameter), field(3)" pk
    | Some (4, Pbrt.Bytes) -> begin
      v.defexpr <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(function_parameter), field(4)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    name = v.name;
    arg_type = v.arg_type;
    mode = v.mode;
    defexpr = v.defexpr;
  } : function_parameter)

and decode_pb_locking_clause d =
  let v = default_locking_clause_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.locked_rels <- List.rev v.locked_rels;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.locked_rels <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.locked_rels;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(locking_clause), field(1)" pk
    | Some (2, Pbrt.Varint) -> begin
      v.strength <- decode_pb_lock_clause_strength d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(locking_clause), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.wait_policy <- decode_pb_lock_wait_policy d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(locking_clause), field(3)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    locked_rels = v.locked_rels;
    strength = v.strength;
    wait_policy = v.wait_policy;
  } : locking_clause)

and decode_pb_xml_serialize d =
  let v = default_xml_serialize_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Varint) -> begin
      v.xmloption <- decode_pb_xml_option_type d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(xml_serialize), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.expr <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(xml_serialize), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.type_name <- Some (decode_pb_type_name (Pbrt.Decoder.nested d));
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(xml_serialize), field(3)" pk
    | Some (4, Pbrt.Varint) -> begin
      v.location <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(xml_serialize), field(4)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    xmloption = v.xmloption;
    expr = v.expr;
    type_name = v.type_name;
    location = v.location;
  } : xml_serialize)

and decode_pb_common_table_expr d =
  let v = default_common_table_expr_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.ctecolcollations <- List.rev v.ctecolcollations;
      v.ctecoltypmods <- List.rev v.ctecoltypmods;
      v.ctecoltypes <- List.rev v.ctecoltypes;
      v.ctecolnames <- List.rev v.ctecolnames;
      v.aliascolnames <- List.rev v.aliascolnames;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.ctename <- Pbrt.Decoder.string d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(common_table_expr), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.aliascolnames <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.aliascolnames;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(common_table_expr), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.ctematerialized <- decode_pb_ctematerialize d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(common_table_expr), field(3)" pk
    | Some (4, Pbrt.Bytes) -> begin
      v.ctequery <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(common_table_expr), field(4)" pk
    | Some (5, Pbrt.Varint) -> begin
      v.location <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(common_table_expr), field(5)" pk
    | Some (6, Pbrt.Varint) -> begin
      v.cterecursive <- Pbrt.Decoder.bool d;
    end
    | Some (6, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(common_table_expr), field(6)" pk
    | Some (7, Pbrt.Varint) -> begin
      v.cterefcount <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (7, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(common_table_expr), field(7)" pk
    | Some (8, Pbrt.Bytes) -> begin
      v.ctecolnames <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.ctecolnames;
    end
    | Some (8, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(common_table_expr), field(8)" pk
    | Some (9, Pbrt.Bytes) -> begin
      v.ctecoltypes <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.ctecoltypes;
    end
    | Some (9, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(common_table_expr), field(9)" pk
    | Some (10, Pbrt.Bytes) -> begin
      v.ctecoltypmods <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.ctecoltypmods;
    end
    | Some (10, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(common_table_expr), field(10)" pk
    | Some (11, Pbrt.Bytes) -> begin
      v.ctecolcollations <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.ctecolcollations;
    end
    | Some (11, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(common_table_expr), field(11)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    ctename = v.ctename;
    aliascolnames = v.aliascolnames;
    ctematerialized = v.ctematerialized;
    ctequery = v.ctequery;
    location = v.location;
    cterecursive = v.cterecursive;
    cterefcount = v.cterefcount;
    ctecolnames = v.ctecolnames;
    ctecoltypes = v.ctecoltypes;
    ctecoltypmods = v.ctecoltypmods;
    ctecolcollations = v.ctecolcollations;
  } : common_table_expr)

and decode_pb_partition_elem d =
  let v = default_partition_elem_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.opclass <- List.rev v.opclass;
      v.collation <- List.rev v.collation;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.name <- Pbrt.Decoder.string d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(partition_elem), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.expr <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(partition_elem), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.collation <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.collation;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(partition_elem), field(3)" pk
    | Some (4, Pbrt.Bytes) -> begin
      v.opclass <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.opclass;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(partition_elem), field(4)" pk
    | Some (5, Pbrt.Varint) -> begin
      v.location <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(partition_elem), field(5)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    name = v.name;
    expr = v.expr;
    collation = v.collation;
    opclass = v.opclass;
    location = v.location;
  } : partition_elem)

and decode_pb_partition_range_datum d =
  let v = default_partition_range_datum_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Varint) -> begin
      v.kind <- decode_pb_partition_range_datum_kind d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(partition_range_datum), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.value <- Some (decode_pb_node (Pbrt.Decoder.nested d));
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(partition_range_datum), field(2)" pk
    | Some (3, Pbrt.Varint) -> begin
      v.location <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(partition_range_datum), field(3)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    kind = v.kind;
    value = v.value;
    location = v.location;
  } : partition_range_datum)

and decode_pb_partition_cmd d =
  let v = default_partition_cmd_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.name <- Some (decode_pb_range_var (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(partition_cmd), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.bound <- Some (decode_pb_partition_bound_spec (Pbrt.Decoder.nested d));
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(partition_cmd), field(2)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    name = v.name;
    bound = v.bound;
  } : partition_cmd)

and decode_pb_vacuum_relation d =
  let v = default_vacuum_relation_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.va_cols <- List.rev v.va_cols;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.relation <- Some (decode_pb_range_var (Pbrt.Decoder.nested d));
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(vacuum_relation), field(1)" pk
    | Some (2, Pbrt.Varint) -> begin
      v.oid <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(vacuum_relation), field(2)" pk
    | Some (3, Pbrt.Bytes) -> begin
      v.va_cols <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.va_cols;
    end
    | Some (3, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(vacuum_relation), field(3)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    relation = v.relation;
    oid = v.oid;
    va_cols = v.va_cols;
  } : vacuum_relation)

and decode_pb_pglist d =
  let v = default_pglist_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.items <- List.rev v.items;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.items <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.items;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(pglist), field(1)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    items = v.items;
  } : pglist)

and decode_pb_int_list d =
  let v = default_int_list_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.items <- List.rev v.items;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.items <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.items;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(int_list), field(1)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    items = v.items;
  } : int_list)

and decode_pb_oid_list d =
  let v = default_oid_list_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.items <- List.rev v.items;
    ); continue__ := false
    | Some (1, Pbrt.Bytes) -> begin
      v.items <- (decode_pb_node (Pbrt.Decoder.nested d)) :: v.items;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(oid_list), field(1)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    items = v.items;
  } : oid_list)

let rec decode_pb_parse_result d =
  let v = default_parse_result_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.stmts <- List.rev v.stmts;
    ); continue__ := false
    | Some (1, Pbrt.Varint) -> begin
      v.version <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(parse_result), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.stmts <- (decode_pb_raw_stmt (Pbrt.Decoder.nested d)) :: v.stmts;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(parse_result), field(2)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    version = v.version;
    stmts = v.stmts;
  } : parse_result)

let rec decode_pb_token d = 
  match Pbrt.Decoder.int_as_varint d with
  | 0 -> (Nul:token)
  | 37 -> (Ascii_37:token)
  | 40 -> (Ascii_40:token)
  | 41 -> (Ascii_41:token)
  | 42 -> (Ascii_42:token)
  | 43 -> (Ascii_43:token)
  | 44 -> (Ascii_44:token)
  | 45 -> (Ascii_45:token)
  | 46 -> (Ascii_46:token)
  | 47 -> (Ascii_47:token)
  | 58 -> (Ascii_58:token)
  | 59 -> (Ascii_59:token)
  | 60 -> (Ascii_60:token)
  | 61 -> (Ascii_61:token)
  | 62 -> (Ascii_62:token)
  | 63 -> (Ascii_63:token)
  | 91 -> (Ascii_91:token)
  | 92 -> (Ascii_92:token)
  | 93 -> (Ascii_93:token)
  | 94 -> (Ascii_94:token)
  | 258 -> (Ident:token)
  | 259 -> (Uident:token)
  | 260 -> (Fconst:token)
  | 261 -> (Sconst:token)
  | 262 -> (Usconst:token)
  | 263 -> (Bconst:token)
  | 264 -> (Xconst:token)
  | 265 -> (Op:token)
  | 266 -> (Iconst:token)
  | 267 -> (Param:token)
  | 268 -> (Typecast:token)
  | 269 -> (Dot_dot:token)
  | 270 -> (Colon_equals:token)
  | 271 -> (Equals_greater:token)
  | 272 -> (Less_equals:token)
  | 273 -> (Greater_equals:token)
  | 274 -> (Not_equals:token)
  | 275 -> (Sql_comment:token)
  | 276 -> (C_comment:token)
  | 277 -> (Abort_p:token)
  | 278 -> (Absolute_p:token)
  | 279 -> (Access:token)
  | 280 -> (Action:token)
  | 281 -> (Add_p:token)
  | 282 -> (Admin:token)
  | 283 -> (After:token)
  | 284 -> (Aggregate:token)
  | 285 -> (All:token)
  | 286 -> (Also:token)
  | 287 -> (Alter:token)
  | 288 -> (Always:token)
  | 289 -> (Analyse:token)
  | 290 -> (Analyze:token)
  | 291 -> (And:token)
  | 292 -> (Any:token)
  | 293 -> (Array:token)
  | 294 -> (As:token)
  | 295 -> (Asc:token)
  | 296 -> (Assertion:token)
  | 297 -> (Assignment:token)
  | 298 -> (Asymmetric:token)
  | 299 -> (At:token)
  | 300 -> (Attach:token)
  | 301 -> (Attribute:token)
  | 302 -> (Authorization:token)
  | 303 -> (Backward:token)
  | 304 -> (Before:token)
  | 305 -> (Begin_p:token)
  | 306 -> (Between:token)
  | 307 -> (Bigint:token)
  | 308 -> (Binary:token)
  | 309 -> (Bit:token)
  | 310 -> (Boolean_p:token)
  | 311 -> (Both:token)
  | 312 -> (By:token)
  | 313 -> (Cache:token)
  | 314 -> (Call:token)
  | 315 -> (Called:token)
  | 316 -> (Cascade:token)
  | 317 -> (Cascaded:token)
  | 318 -> (Case:token)
  | 319 -> (Cast:token)
  | 320 -> (Catalog_p:token)
  | 321 -> (Chain:token)
  | 322 -> (Char_p:token)
  | 323 -> (Character:token)
  | 324 -> (Characteristics:token)
  | 325 -> (Check:token)
  | 326 -> (Checkpoint:token)
  | 327 -> (Class:token)
  | 328 -> (Close:token)
  | 329 -> (Cluster:token)
  | 330 -> (Coalesce:token)
  | 331 -> (Collate:token)
  | 332 -> (Collation:token)
  | 333 -> (Column:token)
  | 334 -> (Columns:token)
  | 335 -> (Comment:token)
  | 336 -> (Comments:token)
  | 337 -> (Commit:token)
  | 338 -> (Committed:token)
  | 339 -> (Concurrently:token)
  | 340 -> (Configuration:token)
  | 341 -> (Conflict:token)
  | 342 -> (Connection:token)
  | 343 -> (Constraint:token)
  | 344 -> (Constraints:token)
  | 345 -> (Content_p:token)
  | 346 -> (Continue_p:token)
  | 347 -> (Conversion_p:token)
  | 348 -> (Copy:token)
  | 349 -> (Cost:token)
  | 350 -> (Create:token)
  | 351 -> (Cross:token)
  | 352 -> (Csv:token)
  | 353 -> (Cube:token)
  | 354 -> (Current_p:token)
  | 355 -> (Current_catalog:token)
  | 356 -> (Current_date:token)
  | 357 -> (Current_role:token)
  | 358 -> (Current_schema:token)
  | 359 -> (Current_time:token)
  | 360 -> (Current_timestamp:token)
  | 361 -> (Current_user:token)
  | 362 -> (Cursor:token)
  | 363 -> (Cycle:token)
  | 364 -> (Data_p:token)
  | 365 -> (Database:token)
  | 366 -> (Day_p:token)
  | 367 -> (Deallocate:token)
  | 368 -> (Dec:token)
  | 369 -> (Decimal_p:token)
  | 370 -> (Declare:token)
  | 371 -> (Default:token)
  | 372 -> (Defaults:token)
  | 373 -> (Deferrable:token)
  | 374 -> (Deferred:token)
  | 375 -> (Definer:token)
  | 376 -> (Delete_p:token)
  | 377 -> (Delimiter:token)
  | 378 -> (Delimiters:token)
  | 379 -> (Depends:token)
  | 380 -> (Desc:token)
  | 381 -> (Detach:token)
  | 382 -> (Dictionary:token)
  | 383 -> (Disable_p:token)
  | 384 -> (Discard:token)
  | 385 -> (Distinct:token)
  | 386 -> (Do:token)
  | 387 -> (Document_p:token)
  | 388 -> (Domain_p:token)
  | 389 -> (Double_p:token)
  | 390 -> (Drop:token)
  | 391 -> (Each:token)
  | 392 -> (Else:token)
  | 393 -> (Enable_p:token)
  | 394 -> (Encoding:token)
  | 395 -> (Encrypted:token)
  | 396 -> (End_p:token)
  | 397 -> (Enum_p:token)
  | 398 -> (Escape:token)
  | 399 -> (Event:token)
  | 400 -> (Except:token)
  | 401 -> (Exclude:token)
  | 402 -> (Excluding:token)
  | 403 -> (Exclusive:token)
  | 404 -> (Execute:token)
  | 405 -> (Exists:token)
  | 406 -> (Explain:token)
  | 407 -> (Expression:token)
  | 408 -> (Extension:token)
  | 409 -> (External:token)
  | 410 -> (Extract:token)
  | 411 -> (False_p:token)
  | 412 -> (Family:token)
  | 413 -> (Fetch:token)
  | 414 -> (Filter:token)
  | 415 -> (First_p:token)
  | 416 -> (Float_p:token)
  | 417 -> (Following:token)
  | 418 -> (For:token)
  | 419 -> (Force:token)
  | 420 -> (Foreign:token)
  | 421 -> (Forward:token)
  | 422 -> (Freeze:token)
  | 423 -> (From:token)
  | 424 -> (Full:token)
  | 425 -> (Function:token)
  | 426 -> (Functions:token)
  | 427 -> (Generated:token)
  | 428 -> (Global:token)
  | 429 -> (Grant:token)
  | 430 -> (Granted:token)
  | 431 -> (Greatest:token)
  | 432 -> (Group_p:token)
  | 433 -> (Grouping:token)
  | 434 -> (Groups:token)
  | 435 -> (Handler:token)
  | 436 -> (Having:token)
  | 437 -> (Header_p:token)
  | 438 -> (Hold:token)
  | 439 -> (Hour_p:token)
  | 440 -> (Identity_p:token)
  | 441 -> (If_p:token)
  | 442 -> (Ilike:token)
  | 443 -> (Immediate:token)
  | 444 -> (Immutable:token)
  | 445 -> (Implicit_p:token)
  | 446 -> (Import_p:token)
  | 447 -> (In_p:token)
  | 448 -> (Include:token)
  | 449 -> (Including:token)
  | 450 -> (Increment:token)
  | 451 -> (Index:token)
  | 452 -> (Indexes:token)
  | 453 -> (Inherit:token)
  | 454 -> (Inherits:token)
  | 455 -> (Initially:token)
  | 456 -> (Inline_p:token)
  | 457 -> (Inner_p:token)
  | 458 -> (Inout:token)
  | 459 -> (Input_p:token)
  | 460 -> (Insensitive:token)
  | 461 -> (Insert:token)
  | 462 -> (Instead:token)
  | 463 -> (Int_p:token)
  | 464 -> (Integer:token)
  | 465 -> (Intersect:token)
  | 466 -> (Interval:token)
  | 467 -> (Into:token)
  | 468 -> (Invoker:token)
  | 469 -> (Is:token)
  | 470 -> (Isnull:token)
  | 471 -> (Isolation:token)
  | 472 -> (Join:token)
  | 473 -> (Key:token)
  | 474 -> (Label:token)
  | 475 -> (Language:token)
  | 476 -> (Large_p:token)
  | 477 -> (Last_p:token)
  | 478 -> (Lateral_p:token)
  | 479 -> (Leading:token)
  | 480 -> (Leakproof:token)
  | 481 -> (Least:token)
  | 482 -> (Left:token)
  | 483 -> (Level:token)
  | 484 -> (Like:token)
  | 485 -> (Limit:token)
  | 486 -> (Listen:token)
  | 487 -> (Load:token)
  | 488 -> (Local:token)
  | 489 -> (Localtime:token)
  | 490 -> (Localtimestamp:token)
  | 491 -> (Location:token)
  | 492 -> (Lock_p:token)
  | 493 -> (Locked:token)
  | 494 -> (Logged:token)
  | 495 -> (Mapping:token)
  | 496 -> (Match:token)
  | 497 -> (Materialized:token)
  | 498 -> (Maxvalue:token)
  | 499 -> (Method:token)
  | 500 -> (Minute_p:token)
  | 501 -> (Minvalue:token)
  | 502 -> (Mode:token)
  | 503 -> (Month_p:token)
  | 504 -> (Move:token)
  | 505 -> (Name_p:token)
  | 506 -> (Names:token)
  | 507 -> (National:token)
  | 508 -> (Natural:token)
  | 509 -> (Nchar:token)
  | 510 -> (New:token)
  | 511 -> (Next:token)
  | 512 -> (Nfc:token)
  | 513 -> (Nfd:token)
  | 514 -> (Nfkc:token)
  | 515 -> (Nfkd:token)
  | 516 -> (No:token)
  | 517 -> (None:token)
  | 518 -> (Normalize:token)
  | 519 -> (Normalized:token)
  | 520 -> (Not:token)
  | 521 -> (Nothing:token)
  | 522 -> (Notify:token)
  | 523 -> (Notnull:token)
  | 524 -> (Nowait:token)
  | 525 -> (Null_p:token)
  | 526 -> (Nullif:token)
  | 527 -> (Nulls_p:token)
  | 528 -> (Numeric:token)
  | 529 -> (Object_p:token)
  | 530 -> (Of:token)
  | 531 -> (Off:token)
  | 532 -> (Offset:token)
  | 533 -> (Oids:token)
  | 534 -> (Old:token)
  | 535 -> (On:token)
  | 536 -> (Only:token)
  | 537 -> (Operator:token)
  | 538 -> (Option:token)
  | 539 -> (Options:token)
  | 540 -> (Or:token)
  | 541 -> (Order:token)
  | 542 -> (Ordinality:token)
  | 543 -> (Others:token)
  | 544 -> (Out_p:token)
  | 545 -> (Outer_p:token)
  | 546 -> (Over:token)
  | 547 -> (Overlaps:token)
  | 548 -> (Overlay:token)
  | 549 -> (Overriding:token)
  | 550 -> (Owned:token)
  | 551 -> (Owner:token)
  | 552 -> (Parallel:token)
  | 553 -> (Parser:token)
  | 554 -> (Partial:token)
  | 555 -> (Partition:token)
  | 556 -> (Passing:token)
  | 557 -> (Password:token)
  | 558 -> (Placing:token)
  | 559 -> (Plans:token)
  | 560 -> (Policy:token)
  | 561 -> (Position:token)
  | 562 -> (Preceding:token)
  | 563 -> (Precision:token)
  | 564 -> (Preserve:token)
  | 565 -> (Prepare:token)
  | 566 -> (Prepared:token)
  | 567 -> (Primary:token)
  | 568 -> (Prior:token)
  | 569 -> (Privileges:token)
  | 570 -> (Procedural:token)
  | 571 -> (Procedure:token)
  | 572 -> (Procedures:token)
  | 573 -> (Program:token)
  | 574 -> (Publication:token)
  | 575 -> (Quote:token)
  | 576 -> (Range:token)
  | 577 -> (Read:token)
  | 578 -> (Real:token)
  | 579 -> (Reassign:token)
  | 580 -> (Recheck:token)
  | 581 -> (Recursive:token)
  | 582 -> (Ref_p:token)
  | 583 -> (References:token)
  | 584 -> (Referencing:token)
  | 585 -> (Refresh:token)
  | 586 -> (Reindex:token)
  | 587 -> (Relative_p:token)
  | 588 -> (Release:token)
  | 589 -> (Rename:token)
  | 590 -> (Repeatable:token)
  | 591 -> (Replace:token)
  | 592 -> (Replica:token)
  | 593 -> (Reset:token)
  | 594 -> (Restart:token)
  | 595 -> (Restrict:token)
  | 596 -> (Returning:token)
  | 597 -> (Returns:token)
  | 598 -> (Revoke:token)
  | 599 -> (Right:token)
  | 600 -> (Role:token)
  | 601 -> (Rollback:token)
  | 602 -> (Rollup:token)
  | 603 -> (Routine:token)
  | 604 -> (Routines:token)
  | 605 -> (Row:token)
  | 606 -> (Rows:token)
  | 607 -> (Rule:token)
  | 608 -> (Savepoint:token)
  | 609 -> (Schema:token)
  | 610 -> (Schemas:token)
  | 611 -> (Scroll:token)
  | 612 -> (Search:token)
  | 613 -> (Second_p:token)
  | 614 -> (Security:token)
  | 615 -> (Select:token)
  | 616 -> (Sequence:token)
  | 617 -> (Sequences:token)
  | 618 -> (Serializable:token)
  | 619 -> (Server:token)
  | 620 -> (Session:token)
  | 621 -> (Session_user:token)
  | 622 -> (Set:token)
  | 623 -> (Sets:token)
  | 624 -> (Setof:token)
  | 625 -> (Share:token)
  | 626 -> (Show:token)
  | 627 -> (Similar:token)
  | 628 -> (Simple:token)
  | 629 -> (Skip:token)
  | 630 -> (Smallint:token)
  | 631 -> (Snapshot:token)
  | 632 -> (Some:token)
  | 633 -> (Sql_p:token)
  | 634 -> (Stable:token)
  | 635 -> (Standalone_p:token)
  | 636 -> (Start:token)
  | 637 -> (Statement:token)
  | 638 -> (Statistics:token)
  | 639 -> (Stdin:token)
  | 640 -> (Stdout:token)
  | 641 -> (Storage:token)
  | 642 -> (Stored:token)
  | 643 -> (Strict_p:token)
  | 644 -> (Strip_p:token)
  | 645 -> (Subscription:token)
  | 646 -> (Substring:token)
  | 647 -> (Support:token)
  | 648 -> (Symmetric:token)
  | 649 -> (Sysid:token)
  | 650 -> (System_p:token)
  | 651 -> (Table:token)
  | 652 -> (Tables:token)
  | 653 -> (Tablesample:token)
  | 654 -> (Tablespace:token)
  | 655 -> (Temp:token)
  | 656 -> (Template:token)
  | 657 -> (Temporary:token)
  | 658 -> (Text_p:token)
  | 659 -> (Then:token)
  | 660 -> (Ties:token)
  | 661 -> (Time:token)
  | 662 -> (Timestamp:token)
  | 663 -> (To:token)
  | 664 -> (Trailing:token)
  | 665 -> (Transaction:token)
  | 666 -> (Transform:token)
  | 667 -> (Treat:token)
  | 668 -> (Trigger:token)
  | 669 -> (Trim:token)
  | 670 -> (True_p:token)
  | 671 -> (Truncate:token)
  | 672 -> (Trusted:token)
  | 673 -> (Type_p:token)
  | 674 -> (Types_p:token)
  | 675 -> (Uescape:token)
  | 676 -> (Unbounded:token)
  | 677 -> (Uncommitted:token)
  | 678 -> (Unencrypted:token)
  | 679 -> (Union:token)
  | 680 -> (Unique:token)
  | 681 -> (Unknown:token)
  | 682 -> (Unlisten:token)
  | 683 -> (Unlogged:token)
  | 684 -> (Until:token)
  | 685 -> (Update:token)
  | 686 -> (User:token)
  | 687 -> (Using:token)
  | 688 -> (Vacuum:token)
  | 689 -> (Valid:token)
  | 690 -> (Validate:token)
  | 691 -> (Validator:token)
  | 692 -> (Value_p:token)
  | 693 -> (Values:token)
  | 694 -> (Varchar:token)
  | 695 -> (Variadic:token)
  | 696 -> (Varying:token)
  | 697 -> (Verbose:token)
  | 698 -> (Version_p:token)
  | 699 -> (View:token)
  | 700 -> (Views:token)
  | 701 -> (Volatile:token)
  | 702 -> (When:token)
  | 703 -> (Where:token)
  | 704 -> (Whitespace_p:token)
  | 705 -> (Window:token)
  | 706 -> (With:token)
  | 707 -> (Within:token)
  | 708 -> (Without:token)
  | 709 -> (Work:token)
  | 710 -> (Wrapper:token)
  | 711 -> (Write:token)
  | 712 -> (Xml_p:token)
  | 713 -> (Xmlattributes:token)
  | 714 -> (Xmlconcat:token)
  | 715 -> (Xmlelement:token)
  | 716 -> (Xmlexists:token)
  | 717 -> (Xmlforest:token)
  | 718 -> (Xmlnamespaces:token)
  | 719 -> (Xmlparse:token)
  | 720 -> (Xmlpi:token)
  | 721 -> (Xmlroot:token)
  | 722 -> (Xmlserialize:token)
  | 723 -> (Xmltable:token)
  | 724 -> (Year_p:token)
  | 725 -> (Yes_p:token)
  | 726 -> (Zone:token)
  | 727 -> (Not_la:token)
  | 728 -> (Nulls_la:token)
  | 729 -> (With_la:token)
  | 730 -> (Postfixop:token)
  | 731 -> (Uminus:token)
  | _ -> Pbrt.Decoder.malformed_variant "token"

let rec decode_pb_keyword_kind d = 
  match Pbrt.Decoder.int_as_varint d with
  | 0 -> (No_keyword:keyword_kind)
  | 1 -> (Unreserved_keyword:keyword_kind)
  | 2 -> (Col_name_keyword:keyword_kind)
  | 3 -> (Type_func_name_keyword:keyword_kind)
  | 4 -> (Reserved_keyword:keyword_kind)
  | _ -> Pbrt.Decoder.malformed_variant "keyword_kind"

let rec decode_pb_scan_token d =
  let v = default_scan_token_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
    ); continue__ := false
    | Some (1, Pbrt.Varint) -> begin
      v.start <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(scan_token), field(1)" pk
    | Some (2, Pbrt.Varint) -> begin
      v.end_ <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(scan_token), field(2)" pk
    | Some (4, Pbrt.Varint) -> begin
      v.token <- decode_pb_token d;
    end
    | Some (4, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(scan_token), field(4)" pk
    | Some (5, Pbrt.Varint) -> begin
      v.keyword_kind <- decode_pb_keyword_kind d;
    end
    | Some (5, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(scan_token), field(5)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    start = v.start;
    end_ = v.end_;
    token = v.token;
    keyword_kind = v.keyword_kind;
  } : scan_token)

let rec decode_pb_scan_result d =
  let v = default_scan_result_mutable () in
  let continue__= ref true in
  while !continue__ do
    match Pbrt.Decoder.key d with
    | None -> (
      v.tokens <- List.rev v.tokens;
    ); continue__ := false
    | Some (1, Pbrt.Varint) -> begin
      v.version <- Pbrt.Decoder.int32_as_varint d;
    end
    | Some (1, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(scan_result), field(1)" pk
    | Some (2, Pbrt.Bytes) -> begin
      v.tokens <- (decode_pb_scan_token (Pbrt.Decoder.nested d)) :: v.tokens;
    end
    | Some (2, pk) -> 
      Pbrt.Decoder.unexpected_payload "Message(scan_result), field(2)" pk
    | Some (_, payload_kind) -> Pbrt.Decoder.skip d payload_kind
  done;
  ({
    version = v.version;
    tokens = v.tokens;
  } : scan_result)

let rec decode_pb_table_like_option d = 
  match Pbrt.Decoder.int_as_varint d with
  | 0 -> (Table_like_option_undefined:table_like_option)
  | 1 -> (Create_table_like_comments:table_like_option)
  | 2 -> (Create_table_like_constraints:table_like_option)
  | 3 -> (Create_table_like_defaults:table_like_option)
  | 4 -> (Create_table_like_generated:table_like_option)
  | 5 -> (Create_table_like_identity:table_like_option)
  | 6 -> (Create_table_like_indexes:table_like_option)
  | 7 -> (Create_table_like_statistics:table_like_option)
  | 8 -> (Create_table_like_storage:table_like_option)
  | 9 -> (Create_table_like_all:table_like_option)
  | _ -> Pbrt.Decoder.malformed_variant "table_like_option"

let rec decode_pb_cluster_option d = 
  match Pbrt.Decoder.int_as_varint d with
  | 0 -> (Cluster_option_undefined:cluster_option)
  | 1 -> (Cluopt_recheck:cluster_option)
  | 2 -> (Cluopt_verbose:cluster_option)
  | _ -> Pbrt.Decoder.malformed_variant "cluster_option"

let rec decode_pb_agg_strategy d = 
  match Pbrt.Decoder.int_as_varint d with
  | 0 -> (Agg_strategy_undefined:agg_strategy)
  | 1 -> (Agg_plain:agg_strategy)
  | 2 -> (Agg_sorted:agg_strategy)
  | 3 -> (Agg_hashed:agg_strategy)
  | 4 -> (Agg_mixed:agg_strategy)
  | _ -> Pbrt.Decoder.malformed_variant "agg_strategy"

let rec decode_pb_set_op_cmd d = 
  match Pbrt.Decoder.int_as_varint d with
  | 0 -> (Set_op_cmd_undefined:set_op_cmd)
  | 1 -> (Setopcmd_intersect:set_op_cmd)
  | 2 -> (Setopcmd_intersect_all:set_op_cmd)
  | 3 -> (Setopcmd_except:set_op_cmd)
  | 4 -> (Setopcmd_except_all:set_op_cmd)
  | _ -> Pbrt.Decoder.malformed_variant "set_op_cmd"

let rec decode_pb_set_op_strategy d = 
  match Pbrt.Decoder.int_as_varint d with
  | 0 -> (Set_op_strategy_undefined:set_op_strategy)
  | 1 -> (Setop_sorted:set_op_strategy)
  | 2 -> (Setop_hashed:set_op_strategy)
  | _ -> Pbrt.Decoder.malformed_variant "set_op_strategy"

let rec decode_pb_lock_tuple_mode d = 
  match Pbrt.Decoder.int_as_varint d with
  | 0 -> (Lock_tuple_mode_undefined:lock_tuple_mode)
  | 1 -> (Lock_tuple_key_share:lock_tuple_mode)
  | 2 -> (Lock_tuple_share:lock_tuple_mode)
  | 3 -> (Lock_tuple_no_key_exclusive:lock_tuple_mode)
  | 4 -> (Lock_tuple_exclusive:lock_tuple_mode)
  | _ -> Pbrt.Decoder.malformed_variant "lock_tuple_mode"
